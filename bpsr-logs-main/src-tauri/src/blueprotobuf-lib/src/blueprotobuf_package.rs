// This file is @generated by prost-build.
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountData {
    #[prost(string, optional, tag = "1")]
    pub open_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub sdk_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub account_uuid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "SystemType", optional, tag = "5")]
    pub os: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Achievement {
    #[prost(uint32, optional, tag = "1")]
    pub finish_num: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub has_received: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "3")]
    pub begin_progress: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActionInfo {
    #[prost(int32, optional, tag = "1")]
    pub action_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub period: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "3")]
    pub percent: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActorBodyPartInfo {
    #[prost(int32, optional, tag = "1")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub hp: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub max_hp: ::core::option::Option<u64>,
    #[prost(enumeration = "BodyPartState", optional, tag = "4")]
    pub state: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub fleshy_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActorBodyPartInfos {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub infos: ::prost::alloc::vec::Vec<ActorBodyPartInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AffixData {
    #[prost(int32, repeated, tag = "1")]
    pub affix_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnswerList {
    #[prost(int32, repeated, tag = "1")]
    pub answers: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AoiSyncDelta {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub attrs: ::core::option::Option<AttrCollection>,
    #[prost(message, optional, tag = "3")]
    pub temp_attrs: ::core::option::Option<TempAttrCollection>,
    #[prost(message, optional, tag = "4")]
    pub event_data_list: ::core::option::Option<EventDataList>,
    #[prost(message, optional, tag = "5")]
    pub bullet_event: ::core::option::Option<BulletEvent>,
    #[prost(message, optional, tag = "6")]
    pub body_part_infos: ::core::option::Option<ActorBodyPartInfos>,
    #[prost(message, optional, tag = "7")]
    pub skill_effects: ::core::option::Option<SkillEffect>,
    #[prost(message, optional, tag = "8")]
    pub passive_skill_infos: ::core::option::Option<SeqPassiveSkillInfo>,
    #[prost(message, optional, tag = "9")]
    pub passive_skill_end_infos: ::core::option::Option<SeqPassiveSkillEndInfo>,
    #[prost(message, optional, tag = "10")]
    pub buff_infos: ::core::option::Option<BuffInfoSync>,
    #[prost(message, optional, tag = "11")]
    pub buff_effect: ::core::option::Option<BuffEffectSync>,
    #[prost(message, repeated, tag = "12")]
    pub fake_bullets: ::prost::alloc::vec::Vec<FakeBulletInfo>,
    #[prost(message, repeated, tag = "13")]
    pub magnetic_ride_queue_change_info_list: ::prost::alloc::vec::Vec<
        MagneticRideQueueChangeInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttrCollection {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub attrs: ::prost::alloc::vec::Vec<Attr>,
    #[prost(message, repeated, tag = "3")]
    pub map_attrs: ::prost::alloc::vec::Vec<MapAttr>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Attr {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub raw_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapAttr {
    #[prost(bool, optional, tag = "1")]
    pub is_clear: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "3")]
    pub attrs: ::prost::alloc::vec::Vec<MapAttrValue>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MapAttrValue {
    #[prost(bool, optional, tag = "1")]
    pub is_remove: ::core::option::Option<bool>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub key: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TempAttrCollection {
    #[prost(message, repeated, tag = "1")]
    pub attrs: ::prost::alloc::vec::Vec<TempAttr>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TempAttr {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventDataList {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub events: ::prost::alloc::vec::Vec<EventData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventData {
    #[prost(int32, optional, tag = "1")]
    pub event_type: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "2")]
    pub int_params: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, repeated, tag = "3")]
    pub long_params: ::prost::alloc::vec::Vec<i64>,
    #[prost(float, repeated, tag = "4")]
    pub float_params: ::prost::alloc::vec::Vec<f32>,
    #[prost(string, repeated, tag = "5")]
    pub str_params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BulletEvent {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub enter_stage_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkillEffect {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub damages: ::prost::alloc::vec::Vec<SyncDamageInfo>,
    #[prost(int64, optional, tag = "3")]
    pub total_damage: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncDamageInfo {
    #[prost(enumeration = "EDamageSource", optional, tag = "1")]
    pub damage_source: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_miss: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_crit: ::core::option::Option<bool>,
    #[prost(enumeration = "EDamageType", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub type_flag: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub actual_value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub lucky_value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub hp_lessen_value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub shield_lessen_value: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "11")]
    pub attacker_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "12")]
    pub owner_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub owner_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "14")]
    pub owner_stage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "15")]
    pub hit_event_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "16")]
    pub is_normal: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub is_dead: ::core::option::Option<bool>,
    #[prost(enumeration = "EDamageProperty", optional, tag = "18")]
    pub property: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "19")]
    pub damage_pos: ::core::option::Option<Vector3>,
    #[prost(message, repeated, tag = "20")]
    pub part_infos: ::prost::alloc::vec::Vec<ClientHitPartInfo>,
    #[prost(int64, optional, tag = "21")]
    pub top_summoner_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "22")]
    pub damage_weight: ::core::option::Option<Vector2>,
    #[prost(uint32, optional, tag = "23")]
    pub passive_uuid: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "24")]
    pub is_rainbow: ::core::option::Option<bool>,
    #[prost(enumeration = "EDamageMode", optional, tag = "25")]
    pub damage_mode: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector3 {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientHitPartInfo {
    #[prost(int32, optional, tag = "1")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub damage_pos: ::core::option::Option<Vector3>,
    #[prost(int64, optional, tag = "3")]
    pub damage_val: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector2 {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeqPassiveSkillInfo {
    #[prost(int64, optional, tag = "1")]
    pub actor_uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub passive_infos: ::prost::alloc::vec::Vec<PassiveSkillInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PassiveSkillInfo {
    #[prost(int32, optional, tag = "1")]
    pub uuid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub stage_begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub stage_play_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub skill_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub skill_stage: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeqPassiveSkillEndInfo {
    #[prost(int64, optional, tag = "1")]
    pub actor_uuid: ::core::option::Option<i64>,
    #[prost(int64, repeated, tag = "2")]
    pub uuids: ::prost::alloc::vec::Vec<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffInfoSync {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub buff_infos: ::prost::alloc::vec::Vec<BuffInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffInfo {
    #[prost(int32, optional, tag = "1")]
    pub buff_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub base_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub host_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub table_uuid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub create_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub fire_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "8")]
    pub layer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub duration: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "12")]
    pub fight_source_info: ::core::option::Option<FightSourceInfo>,
    #[prost(message, repeated, tag = "13")]
    pub logic_effect: ::prost::alloc::vec::Vec<BuffEffectLogicInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FightSourceInfo {
    #[prost(int32, optional, tag = "1")]
    pub fight_source_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub source_config_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuffEffectLogicInfo {
    #[prost(enumeration = "EBuffEffectLogicPbType", optional, tag = "1")]
    pub effect_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub raw_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, optional, tag = "3")]
    pub is_loop: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffEffectSync {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub buff_effects: ::prost::alloc::vec::Vec<BuffEffect>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffEffect {
    #[prost(enumeration = "EBuffEventType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub buff_uuid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub host_uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub trigger_time: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "5")]
    pub logic_effect: ::prost::alloc::vec::Vec<BuffEffectLogicInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FakeBulletInfo {
    #[prost(int32, optional, tag = "1")]
    pub uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub bullet_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub target_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub offset: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "6")]
    pub rotate: ::core::option::Option<Vector3>,
    #[prost(int32, optional, tag = "7")]
    pub skin_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagneticRideQueueChangeInfo {
    #[prost(int64, optional, tag = "1")]
    pub queue_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub passenger_change_info: ::core::option::Option<MagneticRidePassengerChangeInfo>,
    #[prost(message, optional, tag = "3")]
    pub path_point_change_info: ::core::option::Option<MagneticRidePathPointChangeInfo>,
    #[prost(bool, optional, tag = "4")]
    pub is_circle: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub is_remove: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "6")]
    pub path_length: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagneticRidePassengerChangeInfo {
    #[prost(message, repeated, tag = "1")]
    pub passenger_change_list: ::prost::alloc::vec::Vec<PassengerChangeParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PassengerChangeParam {
    #[prost(bool, optional, tag = "1")]
    pub is_add_passenger: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "2")]
    pub add_or_remove_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagneticRidePathPointChangeInfo {
    #[prost(message, repeated, tag = "1")]
    pub path_point_change_list: ::prost::alloc::vec::Vec<PathPointChangeParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PathPointChangeParam {
    #[prost(int32, optional, tag = "1")]
    pub operation: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub add_point: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "3")]
    pub remove_point_count: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub dir: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AoiSyncToMeDelta {
    #[prost(message, optional, tag = "1")]
    pub base_delta: ::core::option::Option<AoiSyncDelta>,
    #[prost(int64, repeated, tag = "2")]
    pub sync_hate_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "3")]
    pub sync_skill_c_ds: ::prost::alloc::vec::Vec<SkillCd>,
    #[prost(message, repeated, tag = "4")]
    pub fight_res_c_ds: ::prost::alloc::vec::Vec<FightResCd>,
    #[prost(int64, optional, tag = "5")]
    pub uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SkillCd {
    #[prost(int32, optional, tag = "1")]
    pub skill_level_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub duration: ::core::option::Option<i32>,
    #[prost(enumeration = "ESkillCdType", optional, tag = "4")]
    pub skill_cd_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub valid_cd_time: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FightResCd {
    #[prost(int32, optional, tag = "1")]
    pub res_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub duration: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub valid_cd_time: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AvatarInfo {
    #[prost(int32, optional, tag = "1")]
    pub avatar_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub profile: ::core::option::Option<PictureInfo>,
    #[prost(message, optional, tag = "3")]
    pub half_body: ::core::option::Option<PictureInfo>,
    #[prost(int32, optional, tag = "4")]
    pub business_card_style_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub avatar_frame_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PictureInfo {
    #[prost(string, optional, tag = "1")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub verify: ::core::option::Option<PictureVerify>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PictureVerify {
    #[prost(uint32, optional, tag = "1")]
    pub size: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub review_start_time: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "3")]
    pub version: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BasicData {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub show_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub gender: ::core::option::Option<i32>,
    #[prost(enumeration = "EBodySize", optional, tag = "5")]
    pub body_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub scene_id: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "8")]
    pub personal_state: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, optional, tag = "9")]
    pub offline_time: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "10")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "11")]
    pub create_time: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "12")]
    pub cur_talent_pool_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "13")]
    pub bot_ai_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "14")]
    pub register_channel: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "15")]
    pub char_state: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "16")]
    pub online_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "17")]
    pub sum_save_diamond: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "18")]
    pub is_newbie: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePass {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub curexp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub week_exp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub exp_last_time: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "6")]
    pub is_unlock: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub buy_normal_pas: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub buy_prime_pass: ::core::option::Option<bool>,
    #[prost(map = "int32, message", tag = "9")]
    pub award: ::std::collections::HashMap<i32, BattlePassAwardInfo>,
    #[prost(bool, optional, tag = "10")]
    pub is_valid: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub is_sended_mail: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BattlePassAwardInfo {
    #[prost(bool, optional, tag = "1")]
    pub free_award: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub paid_award: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BattlePassData {
    #[prost(map = "int32, message", tag = "1")]
    pub battle_map: ::std::collections::HashMap<i32, BattlePass>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BossProgress {
    #[prost(int32, optional, tag = "1")]
    pub total_award_cnt: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotActiveTrigger {
    #[prost(int32, optional, tag = "1")]
    pub trigger_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotAddBuff {
    #[prost(int64, optional, tag = "1")]
    pub actor_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub buff_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub layer: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub duration: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BotMoveInfo {
    #[prost(message, optional, tag = "1")]
    pub dest_pos: ::core::option::Option<Vector3>,
    #[prost(enumeration = "EMoveType", optional, tag = "2")]
    pub move_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_set_dir: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "4")]
    pub cur_move_flag: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotPlayActionParam {
    #[prost(int32, optional, tag = "1")]
    pub action_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub action_source: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotRemoveBuff {
    #[prost(int32, optional, tag = "1")]
    pub buff_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotResurrectionParam {
    #[prost(int64, optional, tag = "1")]
    pub target_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub revive_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotSendChitChatMsgReq {
    #[prost(int32, optional, tag = "1")]
    pub emoji_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BotStartRideParam {
    #[prost(int32, optional, tag = "1")]
    pub ride_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BotTeleportParam {
    #[prost(int64, optional, tag = "1")]
    pub actor_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Position>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BotUseSkillInfo {
    #[prost(int64, optional, tag = "1")]
    pub actor_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub target_pos: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "6")]
    pub dmg_target_pos: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "7")]
    pub face_target_pos: ::core::option::Option<Vector3>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BubbleActData {
    #[prost(map = "int32, message", tag = "1")]
    pub bubble_info: ::std::collections::HashMap<i32, BubbleInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BubbleInfo {
    #[prost(uint32, optional, tag = "1")]
    pub bubble_score: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub bubble_award_count: ::core::option::Option<u32>,
    #[prost(uint64, repeated, tag = "3")]
    pub additional_target_uuid_list: ::prost::alloc::vec::Vec<u64>,
    #[prost(int64, optional, tag = "4")]
    pub last_refresh_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffAttrEffect {
    #[prost(message, repeated, tag = "1")]
    pub attr_show_info: ::prost::alloc::vec::Vec<BuffAttrShowInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuffAttrShowInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_gain: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuffDbData {
    #[prost(int64, optional, tag = "1")]
    pub buff_uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub firer_id: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "3")]
    pub buff_config_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub base_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub layer: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub duration: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "9")]
    pub create_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "10")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub create_scene_id: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "12")]
    pub custom_params_key: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, tag = "13")]
    pub custom_params: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuffDbInfo {
    #[prost(uint32, optional, tag = "1")]
    pub max_id: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "2")]
    pub all_buff_db_data: ::std::collections::HashMap<u32, BuffDbData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuffEffectLogicTension {
    #[prost(int64, optional, tag = "1")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "2")]
    pub strength: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "3")]
    pub strength_length: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub max_length: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BufferStream {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub buffer: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BuffProfessionEffectData {
    #[prost(int32, optional, tag = "1")]
    pub profession_type: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "2")]
    pub profession_point: ::prost::alloc::vec::Vec<i32>,
    #[prost(bool, repeated, tag = "3")]
    pub profession_switch: ::prost::alloc::vec::Vec<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraSchemeCache {
    #[prost(map = "string, message", tag = "1")]
    pub camera_scheme_dict: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        CameraSchemeInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraSchemeInfo {
    #[prost(enumeration = "CameraPatternType", optional, tag = "1")]
    pub camera_pattern_type: ::core::option::Option<i32>,
    #[prost(enumeration = "CameraSchemeType", optional, tag = "2")]
    pub camera_scheme_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub scheme_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub scheme_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub scheme_time: ::core::option::Option<u64>,
    #[prost(float, optional, tag = "6")]
    pub exposure: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub contrast: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub saturation: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub horizontal: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "10")]
    pub vertical: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "11")]
    pub angle: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "12")]
    pub depth_tag: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "13")]
    pub aperture: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "14")]
    pub near_blend: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "15")]
    pub far_blend: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "16")]
    pub focus_tag: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "17")]
    pub focus: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "18")]
    pub world_time: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "19")]
    pub is_head_follow: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "20")]
    pub is_eye_follow: ::core::option::Option<bool>,
    #[prost(map = "uint64, bool", tag = "21")]
    pub show_entity_dicts: ::std::collections::HashMap<u64, bool>,
    #[prost(map = "uint64, bool", tag = "22")]
    pub show_ui_dicts: ::std::collections::HashMap<u64, bool>,
    #[prost(string, optional, tag = "23")]
    pub filter_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "24")]
    pub id: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraSelectSchemeCache {
    #[prost(message, optional, tag = "1")]
    pub camera_scheme_cache: ::core::option::Option<CameraSchemeInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChallengeDungeonInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub dungeon_info: ::std::collections::HashMap<i32, DungeonInfo>,
    #[prost(map = "int32, message", tag = "2")]
    pub dungeon_target_award: ::std::collections::HashMap<i32, DungeonTargetAward>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonInfo {
    #[prost(int32, optional, tag = "1")]
    pub dungeon_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub complete_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award_flg: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub score: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub pass_time: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonTargetAward {
    #[prost(map = "int32, message", tag = "1")]
    pub dungeon_target_progress: ::std::collections::HashMap<i32, DungeonTargetProgress>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonTargetProgress {
    #[prost(int32, optional, tag = "1")]
    pub target_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_progress: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award_state: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharBaseInfo {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3")]
    pub show_id: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "4")]
    pub server_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "EGender", optional, tag = "6")]
    pub gender: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "7")]
    pub is_deleted: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub is_forbid: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "9")]
    pub is_mute: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "10")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "11")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "12")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "13")]
    pub dir: ::core::option::Option<f32>,
    #[prost(message, optional, tag = "14")]
    pub face_data: ::core::option::Option<FaceData>,
    #[prost(uint32, optional, tag = "15")]
    pub card_id: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "16")]
    pub create_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "17")]
    pub online_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "18")]
    pub offline_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "19")]
    pub profile_info: ::core::option::Option<ProfileInfo>,
    #[prost(message, optional, tag = "20")]
    pub team_info: ::core::option::Option<CharTeam>,
    #[prost(uint64, optional, tag = "21")]
    pub char_state: ::core::option::Option<u64>,
    #[prost(enumeration = "EBodySize", optional, tag = "22")]
    pub body_size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "23")]
    pub union_info: ::core::option::Option<UserUnion>,
    #[prost(int32, repeated, tag = "24")]
    pub personal_state: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "25")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(uint64, optional, tag = "26")]
    pub total_online_time: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "27")]
    pub open_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "28")]
    pub sdk_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "29")]
    pub os: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "31")]
    pub init_profession_id: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "32")]
    pub last_cal_total_time: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "33")]
    pub area_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "34")]
    pub client_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "35")]
    pub fight_point: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "36")]
    pub sum_save: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "37")]
    pub client_resource_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "38")]
    pub last_offline_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "39")]
    pub day_acc_dur_time: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "40")]
    pub last_acc_dur_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "41")]
    pub save_serial: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaceData {
    #[prost(map = "int32, int32", tag = "1")]
    pub face_info: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub color_info: ::std::collections::HashMap<i32, IntVec3>,
    #[prost(float, optional, tag = "3")]
    pub height: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntVec3 {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub z: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProfileInfo {
    #[prost(int32, optional, tag = "1")]
    pub profile_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub profile_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub half_body_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharTeam {
    #[prost(int64, optional, tag = "1")]
    pub team_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub leader_id: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "3")]
    pub team_target_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub team_num: ::core::option::Option<u32>,
    #[prost(int64, repeated, tag = "5")]
    pub char_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(bool, optional, tag = "6")]
    pub is_matching: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "7")]
    pub char_team_version: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "8")]
    pub team_member_data: ::std::collections::HashMap<i64, TeamMemData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamMemData {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "2")]
    pub enter_time: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "3")]
    pub call_status: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub talent_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub online_status: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub scene_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "7")]
    pub voice_is_open: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "8")]
    pub group_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub social_data: ::core::option::Option<TeamMemberSocialData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeamMemberSocialData {
    #[prost(message, optional, tag = "1")]
    pub basic_data: ::core::option::Option<BasicData>,
    #[prost(message, optional, tag = "2")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(message, optional, tag = "3")]
    pub face_data: ::core::option::Option<FaceData>,
    #[prost(message, optional, tag = "4")]
    pub profession_data: ::core::option::Option<ProfessionData>,
    #[prost(message, optional, tag = "5")]
    pub equip_data: ::core::option::Option<EquipData>,
    #[prost(message, optional, tag = "6")]
    pub fashion_data: ::core::option::Option<FashionData>,
    #[prost(message, optional, tag = "7")]
    pub user_scene_info: ::core::option::Option<UserSceneInfo>,
    #[prost(message, optional, tag = "8")]
    pub user_attr_data: ::core::option::Option<UserAttrData>,
    #[prost(message, optional, tag = "9")]
    pub personal_zone: ::core::option::Option<PersonalZoneShow>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProfessionData {
    #[prost(int32, optional, tag = "1")]
    pub profession_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub weapon_skin: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipData {
    #[prost(message, repeated, tag = "1")]
    pub equip_infos: ::prost::alloc::vec::Vec<EquipNine>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EquipNine {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub equip_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionData {
    #[prost(message, repeated, tag = "1")]
    pub fashion_infos: ::prost::alloc::vec::Vec<FashionInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionInfo {
    #[prost(int32, optional, tag = "1")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub fashion_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub colors: ::core::option::Option<FashionColorInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionColorInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub colors: ::std::collections::HashMap<i32, IntVec3>,
    #[prost(map = "int32, message", tag = "3")]
    pub attachment_color: ::std::collections::HashMap<i32, IntVec3>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserSceneInfo {
    #[prost(int32, optional, tag = "1")]
    pub scene_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub line_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserAttrData {
    #[prost(int32, optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub fight_point: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalZoneShow {
    #[prost(map = "int32, int32", tag = "1")]
    pub medals: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserUnion {
    #[prost(int64, optional, tag = "1")]
    pub union_id: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "2")]
    pub next_join_time: ::core::option::Option<u64>,
    #[prost(map = "int64, uint64", tag = "3")]
    pub req_union_times: ::std::collections::HashMap<i64, u64>,
    #[prost(bool, optional, tag = "4")]
    pub join_flag: ::core::option::Option<bool>,
    #[prost(int64, repeated, tag = "5")]
    pub collected_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, optional, tag = "6")]
    pub active_award_reset_time: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "7")]
    pub received_award_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "8")]
    pub history_active_points: ::prost::alloc::vec::Vec<UnionHistoryActive>,
    #[prost(int64, optional, tag = "9")]
    pub active_last_refresh_time: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "10")]
    pub finish_daily_active_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint64, optional, tag = "11")]
    pub leave_time: ::core::option::Option<u64>,
    /// changed
    #[prost(message, optional, tag = "13")]
    pub dance_record: ::core::option::Option<UnionDanceHistory>,
    #[prost(message, optional, tag = "14")]
    pub user_union_hunt_info: ::core::option::Option<UserUnionHuntInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionHistoryActive {
    #[prost(int64, optional, tag = "1")]
    pub union_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub active_points: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionDanceHistory {
    #[prost(int64, optional, tag = "1")]
    pub dance_end_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "2")]
    pub sent_dance_award: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub drawn_dance_award: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserUnionHuntInfo {
    #[prost(int32, optional, tag = "1")]
    pub hunt_rank: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CharSerialize {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub char_base: ::core::option::Option<CharBaseInfo>,
    #[prost(message, optional, tag = "3")]
    pub scene_data: ::core::option::Option<SceneData>,
    #[prost(message, optional, tag = "4")]
    pub scene_lua_data: ::core::option::Option<SceneLuaData>,
    #[prost(message, optional, tag = "5")]
    pub pioneer_data: ::core::option::Option<PioneerData>,
    #[prost(message, optional, tag = "6")]
    pub buff_info: ::core::option::Option<BuffDbInfo>,
    #[prost(message, optional, tag = "7")]
    pub item_package: ::core::option::Option<ItemPackage>,
    #[prost(message, optional, tag = "8")]
    pub quest_list: ::core::option::Option<QuestDataList>,
    #[prost(message, optional, tag = "9")]
    pub setting_data: ::core::option::Option<SettingData>,
    #[prost(message, optional, tag = "10")]
    pub misc_info: ::core::option::Option<MiscInfo>,
    #[prost(message, optional, tag = "11")]
    pub exchange_items: ::core::option::Option<ExchangeItem>,
    #[prost(message, optional, tag = "12")]
    pub equip: ::core::option::Option<EquipList>,
    #[prost(message, optional, tag = "13")]
    pub energy_item: ::core::option::Option<EnergyItem>,
    #[prost(message, optional, tag = "14")]
    pub map_data: ::core::option::Option<MapData>,
    #[prost(message, optional, tag = "15")]
    pub dungeon_list: ::core::option::Option<DungeonList>,
    #[prost(message, optional, tag = "16")]
    pub attr: ::core::option::Option<UserFightAttr>,
    #[prost(message, optional, tag = "17")]
    pub fashion: ::core::option::Option<FashionMgr>,
    #[prost(message, optional, tag = "18")]
    pub profile_list: ::core::option::Option<ProfileList>,
    #[prost(message, optional, tag = "19")]
    pub help: ::core::option::Option<PlayHelper>,
    #[prost(message, optional, tag = "20")]
    pub counter_list: ::core::option::Option<CounterList>,
    #[prost(message, optional, tag = "21")]
    pub personal_obj: ::core::option::Option<PersonalObject>,
    #[prost(message, optional, tag = "22")]
    pub role_level: ::core::option::Option<RoleLevel>,
    #[prost(message, optional, tag = "23")]
    pub pivot: ::core::option::Option<Pivot>,
    #[prost(message, optional, tag = "24")]
    pub transfer_point: ::core::option::Option<TransferPoint>,
    #[prost(message, optional, tag = "25")]
    pub planet_memory: ::core::option::Option<PlanetMemory>,
    #[prost(message, optional, tag = "26")]
    pub planet_memory_target: ::core::option::Option<SeasonTarget>,
    #[prost(message, optional, tag = "27")]
    pub red_dot: ::core::option::Option<RedDotData>,
    #[prost(message, optional, tag = "28")]
    pub resonance: ::core::option::Option<Resonance>,
    #[prost(message, optional, tag = "29")]
    pub cuts_state: ::core::option::Option<CutsState>,
    #[prost(message, optional, tag = "30")]
    pub investigate_list: ::core::option::Option<InvestigateList>,
    #[prost(message, optional, tag = "31")]
    pub records: ::core::option::Option<ParkourRecordList>,
    #[prost(message, optional, tag = "32")]
    pub interaction: ::core::option::Option<InteractionInfo>,
    #[prost(message, optional, tag = "33")]
    pub season_quest_list: ::core::option::Option<SeasonQuestList>,
    #[prost(message, optional, tag = "34")]
    pub role_face: ::core::option::Option<RoleFace>,
    #[prost(message, optional, tag = "35")]
    pub map_book_list: ::core::option::Option<MapBookInfoList>,
    #[prost(message, optional, tag = "36")]
    pub function_data: ::core::option::Option<FunctionData>,
    #[prost(message, optional, tag = "37")]
    pub anti_info: ::core::option::Option<AntiAddictionInfo>,
    #[prost(message, optional, tag = "38")]
    pub monster_explore_list: ::core::option::Option<MonsterExploreList>,
    #[prost(message, optional, tag = "39")]
    pub show_piece_data: ::core::option::Option<ShowPieceData>,
    /// changed
    #[prost(message, optional, tag = "42")]
    pub collection_book: ::core::option::Option<CollectionBook>,
    #[prost(message, optional, tag = "43")]
    pub not_get_proceed_award_times: ::core::option::Option<NotGetProceedAwardInfo>,
    #[prost(message, optional, tag = "44")]
    pub cook_list: ::core::option::Option<CookList>,
    #[prost(message, optional, tag = "45")]
    pub refresh_data_list: ::core::option::Option<TimerRefreshDataList>,
    #[prost(message, optional, tag = "46")]
    pub challenge_dungeon_info: ::core::option::Option<ChallengeDungeonInfo>,
    #[prost(message, optional, tag = "47")]
    pub sync_award_data: ::core::option::Option<SyncAwardData>,
    #[prost(message, optional, tag = "48")]
    pub season_achievement_list: ::core::option::Option<SeasonAchievementList>,
    #[prost(message, optional, tag = "49")]
    pub season_rank_list: ::core::option::Option<SeasonRankList>,
    #[prost(message, optional, tag = "50")]
    pub season_center: ::core::option::Option<SeasonCenter>,
    #[prost(message, optional, tag = "51")]
    pub personal_zone: ::core::option::Option<PersonalZone>,
    #[prost(message, optional, tag = "52")]
    pub season_medal_info: ::core::option::Option<SeasonMedalInfo>,
    #[prost(message, optional, tag = "53")]
    pub community_home_info: ::core::option::Option<CommunityHomeData>,
    #[prost(message, optional, tag = "54")]
    pub season_activation: ::core::option::Option<SeasonActivation>,
    #[prost(message, optional, tag = "55")]
    pub slots: ::core::option::Option<Slot>,
    #[prost(message, optional, tag = "56")]
    pub monster_hunt_info: ::core::option::Option<MonsterHuntInfo>,
    #[prost(message, optional, tag = "57")]
    pub r#mod: ::core::option::Option<Mod>,
    #[prost(message, optional, tag = "58")]
    pub world_event_map: ::core::option::Option<WorldEventMap>,
    #[prost(message, optional, tag = "59")]
    pub fish_setting: ::core::option::Option<FishSetting>,
    #[prost(message, optional, tag = "60")]
    pub freight_data: ::core::option::Option<FreightData>,
    #[prost(message, optional, tag = "61")]
    pub profession_list: ::core::option::Option<ProfessionList>,
    #[prost(message, optional, tag = "62")]
    pub trial_road: ::core::option::Option<TrialRoad>,
    #[prost(message, optional, tag = "63")]
    pub gasha_data: ::core::option::Option<GashaData>,
    #[prost(message, optional, tag = "64")]
    pub shop_data: ::core::option::Option<ShopData>,
    #[prost(message, optional, tag = "65")]
    pub personal_world_boss_info: ::core::option::Option<PersonalWorldBossInfo>,
    #[prost(message, optional, tag = "66")]
    pub craft_energy: ::core::option::Option<CraftEnergyRecord>,
    #[prost(message, optional, tag = "67")]
    pub weekly_tower: ::core::option::Option<WeeklyTowerRecord>,
    #[prost(message, optional, tag = "68")]
    pub cut_scene_infos: ::core::option::Option<CutSceneInfos>,
    #[prost(message, optional, tag = "69")]
    pub recommend_play_data: ::core::option::Option<UserRecommendPlayData>,
    #[prost(message, optional, tag = "70")]
    pub ride_list: ::core::option::Option<RideList>,
    #[prost(message, optional, tag = "71")]
    pub pay_order_list: ::core::option::Option<PayOrderList>,
    #[prost(message, optional, tag = "72")]
    pub life_profession: ::core::option::Option<LifeProfession>,
    #[prost(message, optional, tag = "73")]
    pub life_profession_work: ::core::option::Option<LifeProfessionWork>,
    #[prost(message, optional, tag = "74")]
    pub user_activity_list: ::core::option::Option<UserActivityList>,
    #[prost(message, optional, tag = "75")]
    pub player_record: ::core::option::Option<PlayerRecord>,
    #[prost(message, optional, tag = "76")]
    pub drop_container: ::core::option::Option<DropContainerInfo>,
    #[prost(message, optional, tag = "77")]
    pub monthly_card: ::core::option::Option<MonthlyCard>,
    #[prost(message, optional, tag = "78")]
    pub fashion_benefit: ::core::option::Option<FashionBenefit>,
    #[prost(message, optional, tag = "79")]
    pub item_currency: ::core::option::Option<ItemCurrency>,
    #[prost(message, optional, tag = "80")]
    pub privilege_effect_data: ::core::option::Option<PrivilegeEffectData>,
    #[prost(message, optional, tag = "81")]
    pub treasure: ::core::option::Option<Treasure>,
    #[prost(message, optional, tag = "82")]
    pub unlock_emoji_data: ::core::option::Option<UnlockEmojiData>,
    #[prost(message, optional, tag = "83")]
    pub player_order_comtainer_info: ::core::option::Option<PlayerOrderComtainerInfo>,
    #[prost(message, optional, tag = "84")]
    pub player_box: ::core::option::Option<PlayerBox>,
    #[prost(message, optional, tag = "85")]
    pub launch_privilege_data: ::core::option::Option<LaunchPrivilegeData>,
    #[prost(message, optional, tag = "86")]
    pub battle_pass_data: ::core::option::Option<BattlePassData>,
    #[prost(message, optional, tag = "87")]
    pub recharge_data: ::core::option::Option<RechargeData>,
    #[prost(message, optional, tag = "88")]
    pub lucky_value_mgr: ::core::option::Option<LuckyValueMgr>,
    #[prost(message, optional, tag = "89")]
    pub handbook_data: ::core::option::Option<HandbookData>,
    #[prost(message, optional, tag = "90")]
    pub master_mode_dungeon_info: ::core::option::Option<MasterModeDungeonInfo>,
    #[prost(message, optional, tag = "91")]
    pub statistics_data: ::core::option::Option<StatisticsData>,
    #[prost(message, optional, tag = "92")]
    pub compenstion_statistics: ::core::option::Option<CompensationStatistics>,
    #[prost(message, optional, tag = "93")]
    pub bubble_act_data: ::core::option::Option<BubbleActData>,
    #[prost(message, optional, tag = "94")]
    pub mail_claimed_info: ::core::option::Option<MailClaimedInfo>,
    #[prost(message, optional, tag = "95")]
    pub newbie_data: ::core::option::Option<NewbieData>,
    #[prost(message, optional, tag = "96")]
    pub fight_point: ::core::option::Option<FightPoint>,
    #[prost(message, optional, tag = "97")]
    pub sign: ::core::option::Option<SignInfo>,
    #[prost(message, optional, tag = "98")]
    pub char_statistics_data: ::core::option::Option<CharStatisticsData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneData {
    #[prost(uint32, optional, tag = "1")]
    pub map_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub channel_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int64, optional, tag = "4")]
    pub level_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub level_pos: ::core::option::Option<Position>,
    #[prost(uint32, optional, tag = "6")]
    pub level_map_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "7")]
    pub level_revive_id: ::core::option::Option<u32>,
    #[prost(map = "uint32, uint32", tag = "8")]
    pub record_id: ::std::collections::HashMap<u32, u32>,
    #[prost(uint32, optional, tag = "9")]
    pub plane_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub scene_layer: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "11")]
    pub can_switch_layer: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "12")]
    pub before_fall_pos: ::core::option::Option<Position>,
    #[prost(string, optional, tag = "13")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14")]
    pub dungeon_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "15")]
    pub line_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "16")]
    pub visual_layer_config_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "17")]
    pub last_scene_data: ::core::option::Option<LastSceneData>,
    #[prost(int32, optional, tag = "18")]
    pub scene_area_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "19")]
    pub level_area_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "20")]
    pub before_fall_scene_area_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LastSceneData {
    #[prost(uint32, optional, tag = "1")]
    pub scene_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub pos: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "3")]
    pub scene_area_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneLuaData {
    #[prost(map = "uint32, string", tag = "1")]
    pub scene_lua_info: ::std::collections::HashMap<u32, ::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PioneerData {
    #[prost(map = "uint32, message", tag = "1")]
    pub info_map: ::std::collections::HashMap<u32, PioneerInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PioneerInfo {
    #[prost(uint32, optional, tag = "1")]
    pub current_total: ::core::option::Option<u32>,
    #[prost(map = "uint32, uint32", tag = "2")]
    pub targets: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "int32, bool", tag = "3")]
    pub awards: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "uint32, bool", tag = "4")]
    pub entered_zones: ::std::collections::HashMap<u32, bool>,
    #[prost(uint32, optional, tag = "5")]
    pub id: ::core::option::Option<u32>,
    #[prost(enumeration = "EErrorCode", optional, tag = "6")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemPackage {
    #[prost(map = "int32, message", tag = "1")]
    pub packages: ::std::collections::HashMap<i32, Package>,
    #[prost(map = "int32, int32", tag = "2")]
    pub unlock_items: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "3")]
    pub quick_bar: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub item_uuid: ::core::option::Option<i32>,
    #[prost(map = "int32, int64", tag = "5")]
    pub use_group_cd: ::std::collections::HashMap<i32, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    #[prost(int32, optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub max_capacity: ::core::option::Option<i32>,
    #[prost(map = "int32, int64", tag = "3")]
    pub item_cd: ::std::collections::HashMap<i32, i64>,
    #[prost(map = "int64, message", tag = "4")]
    pub items: ::std::collections::HashMap<i64, Item>,
    #[prost(int64, optional, tag = "5")]
    pub public_cd: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "6")]
    pub change_version: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Item {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub config_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub count: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub invalid: ::core::option::Option<i32>,
    #[prost(enumeration = "EItemBindFlag", optional, tag = "5")]
    pub bind_flag: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub create_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub expire_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "8")]
    pub opt_src: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub quality: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "10")]
    pub equip_attr: ::core::option::Option<EquipAttr>,
    #[prost(message, optional, tag = "11")]
    pub mod_attr: ::core::option::Option<ModAttr>,
    #[prost(int64, optional, tag = "12")]
    pub cool_down_expire_time: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "13")]
    pub mod_new_attr: ::core::option::Option<ModNewAttr>,
    #[prost(message, optional, tag = "14")]
    pub affix_data: ::core::option::Option<AffixData>,
    #[prost(map = "int32, message", tag = "15")]
    pub extend_attr: ::std::collections::HashMap<i32, ItemExtendData>,
    #[prost(int32, optional, tag = "16")]
    pub reward_id: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "17")]
    pub gene_sequence: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipAttr {
    /// changed
    #[prost(map = "uint32, uint32", tag = "4")]
    pub base_attrs: ::std::collections::HashMap<u32, u32>,
    #[prost(int32, optional, tag = "7")]
    pub perfection_value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub recast_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub total_recast_count: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "10")]
    pub basic_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "11")]
    pub advance_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "12")]
    pub recast_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "13")]
    pub perfection_level: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "14")]
    pub rare_quality_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "15")]
    pub max_perfection_value: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "17")]
    pub equip_attr_set: ::core::option::Option<EquipAttrSet>,
    #[prost(int32, optional, tag = "18")]
    pub break_through_time: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipAttrSet {
    #[prost(map = "int32, int32", tag = "1")]
    pub basic_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "2")]
    pub advance_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "3")]
    pub recast_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "4")]
    pub rare_quality_attr: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModAttr {
    #[prost(int32, optional, tag = "1")]
    pub load_flag: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub level: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub mod_attr_info: ::prost::alloc::vec::Vec<ModAttrInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModAttrInfo {
    #[prost(int32, optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub value: ::core::option::Option<i32>,
    #[prost(map = "uint32, string", tag = "4")]
    pub effect_parameter: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModNewAttr {
    #[prost(int32, repeated, tag = "1")]
    pub mod_parts: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub upgrade_records: ::prost::alloc::vec::Vec<ModPartUpgradeRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ModPartUpgradeRecord {
    #[prost(int32, optional, tag = "1")]
    pub part_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_success: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ItemExtendData {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestDataList {
    #[prost(map = "uint32, message", tag = "1")]
    pub quest_map: ::std::collections::HashMap<u32, QuestData>,
    #[prost(map = "uint32, bool", tag = "2")]
    pub finish_quest: ::std::collections::HashMap<u32, bool>,
    #[prost(uint32, optional, tag = "3")]
    pub tracking_id: ::core::option::Option<u32>,
    #[prost(map = "uint32, uint32", tag = "4")]
    pub finish_reset_quest: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, message", tag = "5")]
    pub history_map: ::std::collections::HashMap<u32, QuestHistory>,
    #[prost(int64, optional, tag = "6")]
    pub world_quest_time_stamp: ::core::option::Option<i64>,
    #[prost(map = "uint32, message", tag = "7")]
    pub world_quest_info: ::std::collections::HashMap<u32, WorldQuestInfo>,
    #[prost(map = "uint32, uint32", tag = "8")]
    pub all_world_quest_list: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "9")]
    pub blue_world_quest_map: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "int32, message", tag = "10")]
    pub filter_event_id: ::std::collections::HashMap<i32, WorldQuestList>,
    #[prost(uint32, repeated, tag = "11")]
    pub accept_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "12")]
    pub follow_world_quest_list: ::prost::alloc::vec::Vec<u32>,
    #[prost(map = "uint32, uint32", tag = "13")]
    pub track_optional_quest: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, uint32", tag = "14")]
    pub finish_reset_quest_count: ::std::collections::HashMap<u32, u32>,
    #[prost(map = "uint32, bool", tag = "15")]
    pub accept_quest_map: ::std::collections::HashMap<u32, bool>,
    #[prost(uint64, optional, tag = "16")]
    pub version: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub step_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub state: ::core::option::Option<u32>,
    #[prost(map = "int32, int32", tag = "4")]
    pub target_num: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "5")]
    pub target_max_num: ::std::collections::HashMap<i32, i32>,
    #[prost(int64, optional, tag = "6")]
    pub step_limit_time: ::core::option::Option<i64>,
    #[prost(enumeration = "EQuestStepStatus", optional, tag = "7")]
    pub step_status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "8")]
    pub add_limit_time: ::core::option::Option<u32>,
    #[prost(map = "int32, int32", tag = "9")]
    pub target_type: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestHistory {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub step_history: ::std::collections::HashMap<u32, u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorldQuestInfo {
    #[prost(uint32, optional, tag = "1")]
    pub finish_points: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub rewards: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub exceeding_points: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorldQuestList {
    #[prost(int32, repeated, tag = "1")]
    pub quest_list: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettingData {
    #[prost(map = "int32, string", tag = "1")]
    pub setting_map: ::std::collections::HashMap<i32, ::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiscInfo {
    #[prost(map = "int32, int32", tag = "1")]
    pub expression_ids_learned: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangeItem {
    #[prost(map = "int32, message", tag = "1")]
    pub exchange_info: ::std::collections::HashMap<i32, ExchangeInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangeInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub exchange_data: ::std::collections::HashMap<i32, ExchangeData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExchangeData {
    #[prost(int32, optional, tag = "1")]
    pub item_config_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub unlock: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cur_exchange_count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub expire_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub last_refresh_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipList {
    #[prost(map = "int32, message", tag = "1")]
    pub equip_list: ::std::collections::HashMap<i32, EquipInfo>,
    #[prost(message, optional, tag = "2")]
    pub equip_attr: ::core::option::Option<EquipAttr>,
    #[prost(map = "uint64, message", tag = "4")]
    pub equip_recast_info: ::std::collections::HashMap<u64, EquipAttr>,
    #[prost(map = "int64, message", tag = "5")]
    pub equip_enchant: ::std::collections::HashMap<i64, EquipEnchantInfo>,
    #[prost(map = "int32, message", tag = "6")]
    pub suit_info_dict: ::std::collections::HashMap<i32, EquipSuitInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EquipInfo {
    #[prost(int32, optional, tag = "1")]
    pub equip_slot: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub item_uuid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "3")]
    pub equip_slot_refine_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub equip_slot_refine_failed_count: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EquipEnchantInfo {
    #[prost(int32, optional, tag = "1")]
    pub enchant_item_type_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub enchant_level: ::core::option::Option<i32>,
    #[prost(enumeration = "EEquipEnchantType", optional, tag = "3")]
    pub enchant_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EquipSuitInfo {
    #[prost(map = "int32, int32", tag = "1")]
    pub suit_attr: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "2")]
    pub attr_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnergyItem {
    #[prost(uint32, optional, tag = "1")]
    pub energy_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub extra_energy_limit: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "3")]
    pub energy_info: ::std::collections::HashMap<u32, EnergyInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnergyInfo {
    #[prost(uint32, optional, tag = "1")]
    pub energy_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub unlock_num: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "3")]
    pub energy_item_info: ::std::collections::HashMap<u32, EnergyItemInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnergyItemInfo {
    #[prost(uint32, optional, tag = "1")]
    pub queue_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub column_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub refine_state: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "4")]
    pub gain_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapData {
    #[prost(map = "int32, message", tag = "1")]
    pub mark_data_map: ::std::collections::HashMap<i32, MarkData>,
    #[prost(map = "int32, bool", tag = "2")]
    pub ares_map: ::std::collections::HashMap<i32, bool>,
    #[prost(int32, optional, tag = "3")]
    pub mark_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkData {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "2")]
    pub mark_info_map: ::std::collections::HashMap<i64, MarkInfo>,
    #[prost(int32, optional, tag = "3")]
    pub mark_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MarkInfo {
    #[prost(int64, optional, tag = "1")]
    pub tag_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub content: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub icon_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "5")]
    pub position: ::core::option::Option<MarkPosition>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MarkPosition {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonList {
    #[prost(map = "int32, message", tag = "1")]
    pub complete_dungeon: ::std::collections::HashMap<i32, DungeonInfo>,
    #[prost(uint32, optional, tag = "2")]
    pub reset_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub normal_dungeon_pass_count: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub dungeon_enter_limit: ::core::option::Option<DungeonEnterLimit>,
    #[prost(message, optional, tag = "5")]
    pub week_target: ::core::option::Option<DungeonWeekTargetList>,
    #[prost(bool, optional, tag = "6")]
    pub is_assist: ::core::option::Option<bool>,
    #[prost(map = "int32, message", tag = "7")]
    pub raid_record_table: ::std::collections::HashMap<i32, RaidRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEnterLimit {
    #[prost(map = "int32, message", tag = "1")]
    pub enter_count: ::std::collections::HashMap<i32, DungeonEnterCount>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonEnterCount {
    #[prost(uint32, optional, tag = "1")]
    pub enter_time: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub enter_count: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonWeekTargetList {
    #[prost(map = "int32, message", tag = "1")]
    pub week_target: ::std::collections::HashMap<i32, DungeonTargetProgress>,
    #[prost(uint32, optional, tag = "2")]
    pub refresh_time: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaidRecord {
    #[prost(map = "int32, message", tag = "1")]
    pub boss_progress: ::std::collections::HashMap<i32, BossProgress>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserFightAttr {
    #[prost(int64, optional, tag = "1")]
    pub cur_hp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub max_hp: ::core::option::Option<i64>,
    #[prost(float, optional, tag = "3")]
    pub origin_energy: ::core::option::Option<f32>,
    #[prost(uint32, repeated, tag = "4")]
    pub resource_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "5")]
    pub resources: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, optional, tag = "6")]
    pub is_dead: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "7")]
    pub dead_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "8")]
    pub revive_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "9")]
    pub cd_info: ::prost::alloc::vec::Vec<SkillCdInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SkillCdInfo {
    #[prost(int32, optional, tag = "1")]
    pub skill_level_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub skill_begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub duration: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "4")]
    pub skill_cd_type: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "6")]
    pub profession_hold_begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "7")]
    pub charge_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub valid_cd_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub sub_cd_ratio: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "10")]
    pub sub_cd_fixed: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "11")]
    pub accelerate_cd_ratio: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionMgr {
    #[prost(map = "int32, int32", tag = "1")]
    pub wear_info: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub fashion_datas: ::std::collections::HashMap<i32, FashionColorInfo>,
    #[prost(map = "int32, message", tag = "3")]
    pub unlock_color: ::std::collections::HashMap<i32, UnlockColorInfo>,
    #[prost(map = "int32, bool", tag = "4")]
    pub fashion_reward: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "5")]
    pub all_fashion: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "6")]
    pub all_ride: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "7")]
    pub all_weapon_skin: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, message", tag = "8")]
    pub fashion_advance: ::std::collections::HashMap<i32, FashionAdvanceInfo>,
    #[prost(int32, optional, tag = "9")]
    pub fashion_collect_point: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "10")]
    pub ride_collect_point: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "11")]
    pub weapon_skin_collect_point: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "12")]
    pub all_fashion_num: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "13")]
    pub all_ride_num: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int32", tag = "14")]
    pub all_weapon_skin_num: ::std::collections::HashMap<i32, i32>,
    #[prost(bool, optional, tag = "15")]
    pub is_fashion_init: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub is_ride_init: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub is_weapon_skin_init: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockColorInfo {
    #[prost(map = "int32, bool", tag = "1")]
    pub color_info_map: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "2")]
    pub color_block_info_map: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FashionAdvanceInfo {
    #[prost(int32, optional, tag = "1")]
    pub fashion_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub using_advance_id: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub advance_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfileList {
    #[prost(map = "int32, bool", tag = "1")]
    pub unlock_profile_list: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayHelper {
    #[prost(map = "int32, bool", tag = "1")]
    pub displayed_helper_list: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "2")]
    pub completed_guide: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CounterList {
    #[prost(map = "int32, message", tag = "1")]
    pub counter_map: ::std::collections::HashMap<i32, CounterInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CounterInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub counter: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalObject {
    #[prost(map = "int32, message", tag = "1")]
    pub scene_obj_data: ::std::collections::HashMap<i32, ScenePersonalObject>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScenePersonalObject {
    #[prost(map = "int64, message", tag = "1")]
    pub personal_obj_data: ::std::collections::HashMap<
        i64,
        ServerStateObjectInteractionParam,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerStateObjectInteractionParam {
    #[prost(int64, optional, tag = "1")]
    pub obj_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub state_value: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub last_interaction_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleLevel {
    #[prost(int32, optional, tag = "1")]
    pub level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub cur_level_exp: ::core::option::Option<i64>,
    #[prost(map = "int32, bool", tag = "3")]
    pub received_level_list: ::std::collections::HashMap<i32, bool>,
    #[prost(message, optional, tag = "4")]
    pub proficiency_info: ::core::option::Option<LevelProficiency>,
    #[prost(map = "int32, int64", tag = "5")]
    pub active_exp_map: ::std::collections::HashMap<i32, i64>,
    #[prost(int32, optional, tag = "6")]
    pub last_season_day: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "7")]
    pub bless_exp_pool: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub grant_bless_exp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub accumulate_bless_exp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub accumulate_exp: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "11")]
    pub prev_season_max_lv: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LevelProficiency {
    #[prost(map = "int32, int32", tag = "1")]
    pub using_proficiency_map: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub unlock_proficiency_map: ::std::collections::HashMap<i32, UnlockProficiency>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnlockProficiency {
    #[prost(int32, repeated, tag = "1")]
    pub unlock_buffer_id: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pivot {
    #[prost(map = "int32, message", tag = "1")]
    pub pivots: ::std::collections::HashMap<i32, PivotInfo>,
    #[prost(map = "int32, message", tag = "2")]
    pub map_pivots: ::std::collections::HashMap<i32, PivotInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PivotInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "2")]
    pub break_point: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub reward_stage: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub reward_full_state: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferPoint {
    #[prost(map = "int32, int32", tag = "1")]
    pub points: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlanetMemory {
    #[prost(int32, repeated, tag = "1")]
    pub pass_room: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonTarget {
    #[prost(map = "int32, message", tag = "1")]
    pub target_info: ::std::collections::HashMap<i32, SeasonTargetInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeasonTargetInfo {
    #[prost(int32, optional, tag = "1")]
    pub target_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_progress: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award_state: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedDotData {
    #[prost(map = "int32, bool", tag = "1")]
    pub permanent_closed_red_dot: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, int32", tag = "2")]
    pub red_dot_count: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resonance {
    #[prost(map = "uint32, int64", tag = "1")]
    pub resonances: ::std::collections::HashMap<u32, i64>,
    #[prost(uint32, repeated, tag = "2")]
    pub installed: ::prost::alloc::vec::Vec<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutsState {
    #[prost(map = "int32, int32", tag = "1")]
    pub state_info: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvestigateList {
    #[prost(map = "uint32, message", tag = "1")]
    pub investigate_map: ::std::collections::HashMap<u32, InvestigateData>,
    #[prost(map = "uint32, bool", tag = "2")]
    pub comp_investigate_map: ::std::collections::HashMap<u32, bool>,
    #[prost(uint32, repeated, tag = "3")]
    pub comp_reasoning_map: ::prost::alloc::vec::Vec<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvestigateData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(map = "int32, message", tag = "2")]
    pub step_ids: ::std::collections::HashMap<i32, InvestigateStep>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvestigateStep {
    #[prost(int32, repeated, tag = "1")]
    pub clues: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub reasoning_map: ::std::collections::HashMap<i32, AnswerList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParkourRecordList {
    #[prost(map = "uint32, message", tag = "1")]
    pub record_list: ::std::collections::HashMap<u32, ParkourRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParkourRecord {
    #[prost(uint32, optional, tag = "1")]
    pub time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub state: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub perfect_time: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InteractionInfo {
    #[prost(int32, optional, tag = "1")]
    pub interaction_stage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub action_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub originator_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub invitee_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "5")]
    pub is_originator: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub interaction_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonQuestList {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_map: ::std::collections::HashMap<u32, SeasonQuestData>,
    #[prost(int32, optional, tag = "2")]
    pub refresh_week: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub refresh_time_stamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeasonQuestData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub target_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleFace {
    #[prost(map = "int32, bool", tag = "1")]
    pub unlock_item_map: ::std::collections::HashMap<i32, bool>,
    #[prost(bool, optional, tag = "2")]
    pub save_need_consume: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapBookInfoList {
    #[prost(map = "uint32, message", tag = "1")]
    pub map_book_map: ::std::collections::HashMap<u32, MapBookInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapBookInfo {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "2")]
    pub map_sticker_map: ::std::collections::HashMap<u32, MapStickerInfo>,
    #[prost(uint32, optional, tag = "3")]
    pub award_flag: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapStickerInfo {
    #[prost(map = "uint32, message", tag = "1")]
    pub sticker_map: ::std::collections::HashMap<u32, MapStickerTaskInfo>,
    #[prost(uint32, repeated, tag = "2")]
    pub finish_map: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub award_flag: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapStickerTaskInfo {
    #[prost(uint32, optional, tag = "1")]
    pub task_id: ::core::option::Option<u32>,
    #[prost(map = "int32, int32", tag = "2")]
    pub target_num: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionData {
    #[prost(map = "int32, bool", tag = "1")]
    pub unlocked_map: ::std::collections::HashMap<i32, bool>,
    #[prost(int32, repeated, tag = "2")]
    pub drawn_function_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AntiAddictionInfo {
    #[prost(uint32, optional, tag = "1")]
    pub last_time: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterExploreList {
    #[prost(map = "int32, message", tag = "1")]
    pub monster_explore_list: ::std::collections::HashMap<i32, MonsterExploreInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterExploreInfo {
    #[prost(bool, optional, tag = "1")]
    pub is_unlock: ::core::option::Option<bool>,
    #[prost(map = "int32, int32", tag = "2")]
    pub target_num: ::std::collections::HashMap<i32, i32>,
    #[prost(uint32, optional, tag = "3")]
    pub award_flag: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "4")]
    pub is_flag: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowPieceData {
    #[prost(map = "int32, message", tag = "1")]
    pub often_use_type_list: ::std::collections::HashMap<i32, ShowPieceIdList>,
    #[prost(map = "int32, message", tag = "2")]
    pub unlock_type_list: ::std::collections::HashMap<i32, ShowPieceIdList>,
    #[prost(map = "int32, message", tag = "3")]
    pub roulette_pos_piece_info: ::std::collections::HashMap<i32, ShowPiecePair>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShowPieceIdList {
    #[prost(int32, repeated, tag = "1")]
    pub piece_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShowPiecePair {
    #[prost(enumeration = "EShowPieceType", optional, tag = "1")]
    pub piece_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub piece_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollectionBook {
    #[prost(map = "uint32, bool", tag = "1")]
    pub mod_book_map: ::std::collections::HashMap<u32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotGetProceedAwardInfo {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub award_id_times: ::std::collections::HashMap<u32, u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CookList {
    #[prost(map = "uint32, message", tag = "1")]
    pub book_data: ::std::collections::HashMap<u32, CookBook>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CookBook {
    #[prost(uint32, optional, tag = "1")]
    pub create_time: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerRefreshDataList {
    #[prost(map = "uint32, message", tag = "1")]
    pub refresh_data_list: ::std::collections::HashMap<u32, TimerRefreshList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerRefreshList {
    #[prost(map = "uint32, message", tag = "1")]
    pub refresh_data: ::std::collections::HashMap<u32, TimerRefreshInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimerRefreshInfo {
    #[prost(int64, optional, tag = "1")]
    pub last_refresh_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncAwardData {
    #[prost(map = "uint32, message", tag = "1")]
    pub level_up_award_infos: ::std::collections::HashMap<u32, LevelUpAward>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LevelUpAward {
    #[prost(uint32, optional, tag = "1")]
    pub drop_times: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "2")]
    pub last_drop_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonAchievementList {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_achievement_list: ::std::collections::HashMap<u32, SeasonAchievement>,
    #[prost(map = "uint32, bool", tag = "2")]
    pub has_init_dones: ::std::collections::HashMap<u32, bool>,
    #[prost(uint64, optional, tag = "3")]
    pub version: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonAchievement {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_achievement: ::std::collections::HashMap<u32, Achievement>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonRankList {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_rank_list: ::std::collections::HashMap<u32, SeasonRankInfo>,
    #[prost(uint32, optional, tag = "2")]
    pub show_armband_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeasonRankInfo {
    #[prost(uint32, optional, tag = "1")]
    pub cur_ran_k_star: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub received_rank_star: ::prost::alloc::vec::Vec<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonCenter {
    #[prost(int32, optional, tag = "1")]
    pub season_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub battle_pass: ::core::option::Option<BattlePass>,
    #[prost(message, optional, tag = "3")]
    pub bp_quest_list: ::core::option::Option<SeasonBpQuestList>,
    #[prost(map = "uint32, message", tag = "4")]
    pub season_history: ::std::collections::HashMap<u32, SeasonCenterHistory>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonBpQuestList {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_map: ::std::collections::HashMap<u32, SeasonBpQuestData>,
    #[prost(uint32, repeated, tag = "2")]
    pub random_map: ::prost::alloc::vec::Vec<u32>,
    #[prost(int64, optional, tag = "3")]
    pub refresh_time_stamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeasonBpQuestData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub target_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonCenterHistory {
    #[prost(message, optional, tag = "1")]
    pub battle_pass: ::core::option::Option<BattlePass>,
    #[prost(message, optional, tag = "2")]
    pub bp_quest_list: ::core::option::Option<SeasonBpQuestList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalZone {
    /// changed
    #[prost(int32, repeated, tag = "2")]
    pub online_periods: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub tags: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, int32", tag = "5")]
    pub medals: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "6")]
    pub theme_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub business_card_style_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub avatar_frame_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub action_info: ::core::option::Option<ActionInfo>,
    #[prost(message, repeated, tag = "10")]
    pub ui_position: ::prost::alloc::vec::Vec<EditorUiPosition>,
    #[prost(int32, optional, tag = "11")]
    pub title_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "12")]
    pub fashion_refresh_flag: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "13")]
    pub fashion_collect_point: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "14")]
    pub fashion_collect_quality_count: ::std::collections::HashMap<
        i32,
        FashionQualityCollectInfo,
    >,
    #[prost(int32, repeated, tag = "15")]
    pub photos: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, int32", tag = "16")]
    pub unlock_target_record: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, bool", tag = "17")]
    pub unlock_get_reward_record: ::std::collections::HashMap<i32, bool>,
    #[prost(int32, optional, tag = "18")]
    pub ride_collect_point: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "19")]
    pub ride_collect_quality_count: ::std::collections::HashMap<
        i32,
        RideQualityCollectInfo,
    >,
    #[prost(int32, optional, tag = "20")]
    pub weapon_skin_collect_point: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "21")]
    pub photos_wall: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EditorUiPosition {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "2")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub y: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionQualityCollectInfo {
    #[prost(map = "int32, int32", tag = "1")]
    pub quality_count: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RideQualityCollectInfo {
    #[prost(map = "int32, int32", tag = "1")]
    pub quality_count: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonMedalInfo {
    #[prost(uint32, optional, tag = "1")]
    pub season_id: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "2")]
    pub normal_hole_infos: ::std::collections::HashMap<u32, MedalHole>,
    #[prost(message, optional, tag = "3")]
    pub core_hole_info: ::core::option::Option<MedalHole>,
    #[prost(map = "uint32, message", tag = "4")]
    pub core_hole_node_infos: ::std::collections::HashMap<u32, MedalNode>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MedalHole {
    #[prost(uint32, optional, tag = "1")]
    pub hole_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub hole_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub cur_exp: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MedalNode {
    #[prost(uint32, optional, tag = "1")]
    pub node_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub node_level: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3")]
    pub choose: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityHomeData {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub buy_count: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "4")]
    pub unlocked_recipes: ::std::collections::HashMap<i32, CommunityHomelandRecipe>,
    #[prost(int32, optional, tag = "5")]
    pub level: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityHomelandRecipe {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonActivation {
    #[prost(int32, optional, tag = "1")]
    pub season_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub activation_point: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub refresh_time: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "4")]
    pub activation_targets: ::std::collections::HashMap<i32, SeasonActivationTarget>,
    #[prost(map = "uint32, int32", tag = "5")]
    pub stage_reward_status: ::std::collections::HashMap<u32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeasonActivationTarget {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub target_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub reward_rate: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub progress: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub completed_times: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slot {
    #[prost(map = "int32, message", tag = "1")]
    pub slots: ::std::collections::HashMap<i32, SlotInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_auto_battle_close: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterHuntInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub monster_hunt_list: ::std::collections::HashMap<i32, MonsterHuntTarget>,
    #[prost(int32, optional, tag = "2")]
    pub cur_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cur_exp: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "4")]
    pub level_award_flag: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, int64", tag = "5")]
    pub monster_hunt_refrsh_time: ::std::collections::HashMap<i32, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonsterHuntTarget {
    #[prost(int32, optional, tag = "1")]
    pub monster_id: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub target_info_list: ::std::collections::HashMap<i32, MonsterTargetInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonsterTargetInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub target_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub target_num: ::core::option::Option<i32>,
    #[prost(enumeration = "MonsterTargetAward", optional, tag = "5")]
    pub award_flag: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mod {
    #[prost(map = "int32, int64", tag = "1")]
    pub mod_slots: ::std::collections::HashMap<i32, i64>,
    #[prost(map = "int64, message", tag = "2")]
    pub mod_infos: ::std::collections::HashMap<i64, ModInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModInfo {
    #[prost(int32, repeated, tag = "1")]
    pub part_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub upgrade_records: ::prost::alloc::vec::Vec<ModPartUpgradeRecord>,
    #[prost(int32, optional, tag = "3")]
    pub success_rate: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "4")]
    pub init_link_nums: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldEventMap {
    #[prost(map = "uint32, message", tag = "1")]
    pub event_map: ::std::collections::HashMap<u32, WorldEventData>,
    #[prost(int32, optional, tag = "2")]
    pub accept_count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub last_update_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub refresh_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorldEventData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "2")]
    pub target_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishSetting {
    /// changed
    #[prost(int32, optional, tag = "2")]
    pub bait_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub experiences: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub research_fish_id: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "5")]
    pub fish_records: ::std::collections::HashMap<i32, FishRecord>,
    #[prost(map = "uint64, int32", tag = "6")]
    pub fish_rod_durability: ::std::collections::HashMap<u64, i32>,
    #[prost(uint64, optional, tag = "7")]
    pub rod_uuid: ::core::option::Option<u64>,
    #[prost(map = "int32, bool", tag = "8")]
    pub level_reward: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, int64", tag = "9")]
    pub zero_fish_times: ::std::collections::HashMap<i32, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishRecord {
    #[prost(int32, optional, tag = "1")]
    pub fish_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub first_flag: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "3")]
    pub size: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub millisecond: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub research: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "6")]
    pub count: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "7")]
    pub min_size: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "8")]
    pub min_sizemillisecond: ::core::option::Option<i64>,
    #[prost(map = "int32, int64", tag = "9")]
    pub star_cnts: ::std::collections::HashMap<i32, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FreightData {
    #[prost(int64, optional, tag = "1")]
    pub refresh_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub goods_value: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub set_off: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub can_receive: ::core::option::Option<bool>,
    #[prost(int32, repeated, tag = "5")]
    pub up_goods_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "6")]
    pub keep_goods_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, tag = "7")]
    pub down_goods_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, optional, tag = "8")]
    pub can_reward_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfessionList {
    /// changed
    #[prost(int32, optional, tag = "1")]
    pub cur_profession_id: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub cur_assist_professions: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, message", tag = "4")]
    pub profession_list: ::std::collections::HashMap<i32, ProfessionInfo>,
    #[prost(map = "int32, message", tag = "7")]
    pub aoyi_skill_info_map: ::std::collections::HashMap<i32, ProfessionSkillInfo>,
    #[prost(uint32, optional, tag = "8")]
    pub total_talent_points: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub total_talent_reset_count: ::core::option::Option<u32>,
    #[prost(map = "int32, message", tag = "10")]
    pub talent_list: ::std::collections::HashMap<i32, ProfessionTalentInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfessionInfo {
    #[prost(int32, optional, tag = "1")]
    pub profession_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub experience: ::core::option::Option<i64>,
    #[prost(map = "int32, message", tag = "4")]
    pub skill_info_map: ::std::collections::HashMap<i32, ProfessionSkillInfo>,
    #[prost(int32, repeated, tag = "6")]
    pub active_skill_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, int32", tag = "7")]
    pub slot_skill_info_map: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "8")]
    pub use_skin_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProfessionSkillInfo {
    #[prost(int32, optional, tag = "1")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub replace_skill_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub remodel_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub cur_skill_skin: ::core::option::Option<i32>,
    #[prost(map = "int32, bool", tag = "6")]
    pub active_skill_skins: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProfessionTalentInfo {
    #[prost(uint32, optional, tag = "1")]
    pub used_talent_points: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub talent_node_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, optional, tag = "3")]
    pub talent_stage_cfg_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialRoad {
    #[prost(int32, repeated, tag = "1")]
    pub pass_room: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub room_target_award: ::std::collections::HashMap<i32, TrialRoadRoomTargetAward>,
    #[prost(message, optional, tag = "3")]
    pub target_award: ::core::option::Option<TrialRoadTargetAward>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialRoadRoomTargetAward {
    #[prost(map = "int32, message", tag = "1")]
    pub target_progress: ::std::collections::HashMap<i32, TrialRoadTargetProgress>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TrialRoadTargetProgress {
    #[prost(int32, optional, tag = "1")]
    pub target_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_progress: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award_state: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialRoadTargetAward {
    #[prost(map = "int32, message", tag = "1")]
    pub target_progress: ::std::collections::HashMap<i32, TrialRoadTargetProgress>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GashaData {
    #[prost(map = "uint32, message", tag = "1")]
    pub gasha_infos: ::std::collections::HashMap<u32, GashaInfo>,
    #[prost(map = "uint32, message", tag = "2")]
    pub gasha_guarantee_infos: ::std::collections::HashMap<u32, GashaGuaranteeInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GashaInfo {
    /// changed
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub draw_count: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "5")]
    pub refresh_time: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "8")]
    pub wish_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "9")]
    pub wish_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub wish_finish_count: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "11")]
    pub wish_reset_time: ::core::option::Option<i64>,
    #[prost(uint32, optional, tag = "12")]
    pub wish_limit: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GashaGuaranteeInfo {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub guarantee_x: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub guarantee_y: ::core::option::Option<u32>,
    #[prost(int32, optional, tag = "4")]
    pub residue_guarantee_time_x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub residue_guarantee_time_y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub residue_guarantee_time_z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "7")]
    pub guarantee_z: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopData {
    #[prost(map = "int32, message", tag = "1")]
    pub refresh_list: ::std::collections::HashMap<i32, ShopRefreshRecord>,
    #[prost(map = "int32, message", tag = "2")]
    pub normal_shop_records: ::std::collections::HashMap<i32, PlayerBuyRecord>,
    #[prost(map = "int32, message", tag = "3")]
    pub season_shop_records: ::std::collections::HashMap<i32, PlayerBuyRecord>,
    #[prost(message, optional, tag = "4")]
    pub compensation_item_data: ::core::option::Option<ShopCompensationData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopRefreshRecord {
    /// changed
    #[prost(int64, optional, tag = "3")]
    pub refresh_timestamp: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub refresh_count: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "5")]
    pub shop_refresh_records: ::std::collections::HashMap<i32, PlayerRefreshShopRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayerRefreshShopRecord {
    /// changed
    #[prost(int32, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayerBuyRecord {
    #[prost(int32, optional, tag = "2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub buy_timestamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShopCompensationData {
    #[prost(map = "uint32, message", tag = "1")]
    pub items: ::std::collections::HashMap<u32, ShopCompensationInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShopCompensationInfo {
    #[prost(int64, optional, tag = "1")]
    pub entor_store_num: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub buy_num: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalWorldBossInfo {
    #[prost(int32, optional, tag = "1")]
    pub score: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub score_award_info: ::std::collections::HashMap<i32, CommonAwardInfo>,
    #[prost(map = "int32, message", tag = "3")]
    pub boss_award_info: ::std::collections::HashMap<i32, CommonAwardInfo>,
    #[prost(int32, optional, tag = "4")]
    pub uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommonAwardInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(enumeration = "EReceiveRewardStatus", optional, tag = "2")]
    pub award_status: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CraftEnergyRecord {
    #[prost(map = "int32, int32", tag = "1")]
    pub records: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WeeklyTowerRecord {
    #[prost(int64, optional, tag = "1")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub max_climb_up_id: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub award_climb_up_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "4")]
    pub rule_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutSceneInfos {
    #[prost(map = "int32, message", tag = "1")]
    pub cut_scene_infos: ::std::collections::HashMap<i32, CutSceneInfo>,
    #[prost(map = "int32, bool", tag = "2")]
    pub finished_cut_scenes: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int64, bool", tag = "3")]
    pub finished_infos: ::std::collections::HashMap<i64, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CutSceneInfo {
    #[prost(int32, optional, tag = "1")]
    pub cut_scene_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub flag: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub scene_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "4")]
    pub event_data: ::core::option::Option<EventData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserRecommendPlayData {
    #[prost(map = "int32, int64", tag = "1")]
    pub play_mail: ::std::collections::HashMap<i32, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RideList {
    #[prost(map = "int32, message", tag = "1")]
    pub rides: ::std::collections::HashMap<i32, RideData>,
    #[prost(enumeration = "ERidePropertyType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "3")]
    pub skin_data: ::std::collections::HashMap<i32, RideSkinContainer>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RideData {
    #[prost(int32, optional, tag = "1")]
    pub ride_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RideSkinContainer {
    #[prost(int32, optional, tag = "1")]
    pub ride_skin_id: ::core::option::Option<i32>,
    #[prost(map = "uint32, message", tag = "2")]
    pub sinks: ::std::collections::HashMap<u32, RideSkinData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RideSkinData {
    #[prost(int64, optional, tag = "1")]
    pub activate_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayOrderList {
    #[prost(string, repeated, tag = "1")]
    pub pay_order_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub pay_refund_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub first_pay: ::core::option::Option<PayData>,
    #[prost(map = "string, int32", tag = "4")]
    pub order_list: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    #[prost(map = "int64, int32", tag = "5")]
    pub order_index_list: ::std::collections::HashMap<i64, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PayData {
    #[prost(map = "int32, message", tag = "1")]
    pub pay_data: ::std::collections::HashMap<i32, FirstPayInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FirstPayInfo {
    #[prost(int32, optional, tag = "1")]
    pub first_pay_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifeProfession {
    #[prost(map = "int32, message", tag = "1")]
    pub profession_info: ::std::collections::HashMap<i32, LifeProfessionBasic>,
    #[prost(map = "int32, message", tag = "2")]
    pub life_target_info: ::std::collections::HashMap<i32, LifeProfessionTargetInfo>,
    #[prost(map = "int32, message", tag = "3")]
    pub life_profession_recipe: ::std::collections::HashMap<i32, LifeProfessionRecipe>,
    #[prost(message, optional, tag = "4")]
    pub life_profession_alchemy_info: ::core::option::Option<LifeProfessionAlchemyInfo>,
    #[prost(map = "int32, int32", tag = "5")]
    pub spare_energy: ::std::collections::HashMap<i32, i32>,
    #[prost(int32, optional, tag = "6")]
    pub point: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifeProfessionBasic {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub exp: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "5")]
    pub specialization: ::std::collections::HashMap<i32, LiftProfessionSpecialization>,
    #[prost(int32, optional, tag = "6")]
    pub current_specialization_point: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LiftProfessionSpecialization {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LifeProfessionTargetInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub level: ::core::option::Option<i32>,
    #[prost(uint32, repeated, tag = "4")]
    pub life_target_reward_states: ::prost::alloc::vec::Vec<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LifeProfessionRecipe {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub unlock_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LifeProfessionAlchemyInfo {
    #[prost(uint32, optional, tag = "1")]
    pub failure_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub rd_count: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "3")]
    pub last_reset_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifeProfessionWork {
    #[prost(message, optional, tag = "1")]
    pub life_profession_work_info: ::core::option::Option<LifeProfessionWorkInfo>,
    #[prost(message, repeated, tag = "2")]
    pub life_profession_work_history_info: ::prost::alloc::vec::Vec<
        LifeProfessionWorkInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LifeProfessionWorkInfo {
    #[prost(uint32, optional, tag = "1")]
    pub life_profession_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub begin_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub end_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub cost: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "6")]
    pub reward: ::prost::alloc::vec::Vec<Item>,
    #[prost(uint32, optional, tag = "7")]
    pub cost_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActivityList {
    #[prost(map = "int64, message", tag = "1")]
    pub activities: ::std::collections::HashMap<i64, UserActivityInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActivityInfo {
    #[prost(uint64, optional, tag = "2")]
    pub start_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub end_time: ::core::option::Option<u64>,
    #[prost(map = "uint32, message", tag = "4")]
    pub rewards: ::std::collections::HashMap<u32, UserActivityRewardInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActivityRewardInfo {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub status: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "3")]
    pub functions: ::std::collections::HashMap<u32, GameFunctionData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GameFunctionData {
    #[prost(uint32, optional, tag = "1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "2")]
    pub state: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "3")]
    pub product_id: ::core::option::Option<u32>,
    #[prost(map = "uint32, message", tag = "4")]
    pub function_times: ::std::collections::HashMap<u32, FunctionTimeData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FunctionTimeData {
    #[prost(uint32, optional, tag = "1")]
    pub times: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub timestamp: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRecord {
    #[prost(map = "int32, message", tag = "1")]
    pub player_record_infos: ::std::collections::HashMap<i32, PlayerRecordInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRecordInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub player_records: ::std::collections::HashMap<i32, PlayerRecordSingle>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayerRecordSingle {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub total_count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub cycle_count: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub cycle_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropContainerInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub drop_containers: ::std::collections::HashMap<i32, DropContainerSingle>,
    #[prost(map = "int32, message", tag = "2")]
    pub drop_award_histories: ::std::collections::HashMap<i32, DropAwardHistory>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DropContainerSingle {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub cycle_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub history_count: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DropAwardHistory {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub cycle_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MonthlyCard {
    #[prost(int64, optional, tag = "1")]
    pub expire_time: ::core::option::Option<i64>,
    #[prost(map = "int32, message", tag = "2")]
    pub monthly_card_info: ::std::collections::HashMap<i32, MonthlyCardInfo>,
    #[prost(int32, optional, tag = "3")]
    pub last_award_monthly_card_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub tips_clicked: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub tips_day: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "6")]
    pub items: ::prost::alloc::vec::Vec<Item>,
    #[prost(map = "int64, message", tag = "7")]
    pub monthly_card_buy_list: ::std::collections::HashMap<i64, MonthlyCardBuyList>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonthlyCardInfo {
    #[prost(enumeration = "EReceiveRewardStatus", optional, tag = "1")]
    pub limit_award_status: ::core::option::Option<i32>,
    #[prost(enumeration = "EReceiveRewardStatus", optional, tag = "2")]
    pub award_status: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub month_card_item: ::core::option::Option<MonthCardItem>,
    #[prost(int64, optional, tag = "4")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub end_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonthCardItem {
    #[prost(int32, optional, tag = "1")]
    pub item_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub create_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonthlyCardBuyList {
    #[prost(int64, optional, tag = "1")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub last_award_day_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FashionBenefit {
    #[prost(int32, optional, tag = "1")]
    pub last_reward_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub points_task: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub points_cycle: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub points_collection: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "6")]
    pub task_list: ::std::collections::HashMap<i32, FashionBenefitTaskInfo>,
    #[prost(message, repeated, tag = "7")]
    pub collection_history: ::prost::alloc::vec::Vec<FashionBenefitCollectionHistory>,
    #[prost(int64, optional, tag = "8")]
    pub next_refresh_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "9")]
    pub max_points: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "10")]
    pub last_add_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "11")]
    pub cur_day_max_points: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub expire_cycle: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "13")]
    pub last_level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "14")]
    pub firt_expire_time: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "15")]
    pub last_reward_ids: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FashionBenefitTaskInfo {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub progress: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FashionBenefitCollectionHistory {
    #[prost(int32, optional, tag = "1")]
    pub fashion_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub parameter: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItemCurrency {
    #[prost(bool, optional, tag = "1")]
    pub is_init: ::core::option::Option<bool>,
    #[prost(map = "int32, message", tag = "2")]
    pub currency_datas: ::std::collections::HashMap<i32, CurrencyData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyData {
    #[prost(int32, optional, tag = "1")]
    pub config_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub count: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivilegeEffectData {
    #[prost(int32, optional, tag = "1")]
    pub normal_pass_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub prime_pass_id: ::core::option::Option<i32>,
    #[prost(map = "int32, bool", tag = "3")]
    pub normal_pass_id_map: ::std::collections::HashMap<i32, bool>,
    #[prost(map = "int32, bool", tag = "4")]
    pub prime_pass_id_map: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Treasure {
    #[prost(map = "int32, message", tag = "1")]
    pub rows: ::std::collections::HashMap<i32, TreasureItemRow>,
    #[prost(map = "int32, message", tag = "2")]
    pub history_rows: ::std::collections::HashMap<i32, TreasureItemRow>,
    #[prost(bool, optional, tag = "3")]
    pub flag: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "4")]
    pub refresh_time: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "5")]
    pub selected_reward: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "6")]
    pub season_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub last_season_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "8")]
    pub last_refresh_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureItemRow {
    #[prost(int32, optional, tag = "1")]
    pub config_id: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub main_targets: ::std::collections::HashMap<i32, TreasureItemTarget>,
    #[prost(map = "int32, message", tag = "3")]
    pub sub_targets: ::std::collections::HashMap<i32, TreasureItemTarget>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureItemTarget {
    #[prost(int32, optional, tag = "1")]
    pub target_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub target_num: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub reward: ::core::option::Option<TreasureItem>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreasureItem {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<Item>,
    #[prost(int32, optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockEmojiData {
    #[prost(map = "int32, bool", tag = "1")]
    pub unlock_map: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayerOrderComtainerInfo {
    #[prost(int32, optional, tag = "1")]
    pub index: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerBox {
    #[prost(map = "uint64, message", tag = "1")]
    pub scenes: ::std::collections::HashMap<u64, PlayerBoxData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerBoxData {
    #[prost(uint64, optional, tag = "1")]
    pub scene_uuid: ::core::option::Option<u64>,
    #[prost(map = "int64, int64", tag = "2")]
    pub boxs: ::std::collections::HashMap<i64, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LaunchPrivilegeData {
    #[prost(enumeration = "LaunchPlatform", optional, tag = "1")]
    pub launch_platform: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_privilege: ::core::option::Option<bool>,
    #[prost(enumeration = "LaunchPlatform", optional, tag = "3")]
    pub bak_launch_platform: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub bak_privilege: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RechargeData {
    #[prost(int64, optional, tag = "1")]
    pub accumulate_amount: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub last_recharge_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub last_recharge_amount: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub last_diamond_amount: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LuckyValueMgr {
    #[prost(map = "int32, message", tag = "1")]
    pub luck_value_info: ::std::collections::HashMap<i32, LuckyValueInfo>,
    #[prost(bool, optional, tag = "2")]
    pub init_value: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LuckyValueInfo {
    #[prost(int32, optional, tag = "1")]
    pub luck_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub luck_value: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub next_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HandbookData {
    #[prost(map = "int32, message", tag = "1")]
    pub unlock_note_important_role_map: ::std::collections::HashMap<i32, HandBookStruct>,
    #[prost(map = "int32, message", tag = "2")]
    pub unlock_note_reading_book_map: ::std::collections::HashMap<i32, HandBookStruct>,
    #[prost(map = "int32, message", tag = "3")]
    pub unlock_note_dictionary_map: ::std::collections::HashMap<i32, HandBookStruct>,
    #[prost(map = "int32, message", tag = "4")]
    pub unlock_note_post_card_map: ::std::collections::HashMap<i32, HandBookStruct>,
    #[prost(map = "int32, message", tag = "5")]
    pub unlock_note_month_card_map: ::std::collections::HashMap<i32, HandBookStruct>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HandBookStruct {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub unlock: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterModeDungeonInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub master_mode_dungeon_info: ::std::collections::HashMap<
        i32,
        SeasonMasterModeDungeonInfo,
    >,
    #[prost(bool, optional, tag = "2")]
    pub is_show: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonMasterModeDungeonInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub master_mode_diff_info: ::std::collections::HashMap<
        i32,
        MasterModeDiffDungeonInfo,
    >,
    #[prost(int64, optional, tag = "2")]
    pub dungeon_info_update_time: ::core::option::Option<i64>,
    #[prost(map = "int32, int32", tag = "3")]
    pub season_awards: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MasterModeDiffDungeonInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub dungeon_info: ::std::collections::HashMap<i32, DungeonInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatisticsData {
    #[prost(map = "int32, message", tag = "1")]
    pub stat_record_map: ::std::collections::HashMap<i32, StatRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatRecord {
    #[prost(uint64, optional, tag = "1")]
    pub cnt: ::core::option::Option<u64>,
    #[prost(map = "int32, uint64", tag = "2")]
    pub group_cnts: ::std::collections::HashMap<i32, u64>,
    #[prost(map = "int32, message", tag = "3")]
    pub scene_records: ::std::collections::HashMap<i32, SceneRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SceneRecord {
    #[prost(uint64, optional, tag = "1")]
    pub cnt: ::core::option::Option<u64>,
    #[prost(map = "int32, uint64", tag = "2")]
    pub group_cnts: ::std::collections::HashMap<i32, u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationStatistics {
    #[prost(map = "uint32, message", tag = "1")]
    pub season_data: ::std::collections::HashMap<u32, CompensationSeasonStatistics>,
    #[prost(uint32, optional, tag = "2")]
    pub last_season_id: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "3")]
    pub cur_point: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub max_point: ::core::option::Option<i64>,
    #[prost(map = "uint32, int32", tag = "5")]
    pub last_week: ::std::collections::HashMap<u32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationSeasonStatistics {
    #[prost(map = "uint32, message", tag = "1")]
    pub week_data: ::std::collections::HashMap<u32, CompensationRecord>,
    #[prost(map = "uint32, int32", tag = "2")]
    pub compensation: ::std::collections::HashMap<u32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompensationRecord {
    #[prost(map = "uint32, message", tag = "1")]
    pub compensation_data: ::std::collections::HashMap<u32, CompensationData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompensationData {
    #[prost(int64, optional, tag = "1")]
    pub overflow_energy: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub finish_times: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub climb_up_layer_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MailClaimedInfo {
    #[prost(int64, repeated, tag = "1")]
    pub attachment_mail_list: ::prost::alloc::vec::Vec<i64>,
    #[prost(map = "int64, int64", tag = "2")]
    pub claimed_mails: ::std::collections::HashMap<i64, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewbieData {
    #[prost(int64, optional, tag = "1")]
    pub total_online_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "2")]
    pub is_newbie: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_cancel_newbie: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FightPoint {
    #[prost(int32, optional, tag = "1")]
    pub total_fight_point: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub fight_point_data: ::std::collections::HashMap<i32, FightPointData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FightPointData {
    #[prost(int32, optional, tag = "1")]
    pub function_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub total_point: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub point: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "4")]
    pub sub_function_data: ::std::collections::HashMap<i32, FightPointSubData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FightPointSubData {
    #[prost(int32, optional, tag = "1")]
    pub function_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub root_function_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub point: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignInfo {
    #[prost(map = "int32, message", tag = "1")]
    pub sign_info: ::std::collections::HashMap<i32, SignStatusList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignStatusList {
    #[prost(map = "int32, message", tag = "1")]
    pub sign_status_data: ::std::collections::HashMap<i32, SignStatus>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignStatus {
    #[prost(bool, optional, tag = "1")]
    pub is_signed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub is_rewarded: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_supplement: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "4")]
    pub sign_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub reward_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CharStatisticsData {
    #[prost(int32, optional, tag = "1")]
    pub login_days: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub last_login_time: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientHitInfo {
    #[prost(enumeration = "EDamageSource", optional, tag = "1")]
    pub source_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub stage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "7")]
    pub attack_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub attack_uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "10")]
    pub attack_pos: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "11")]
    pub target_pos: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "12")]
    pub damage_pos: ::core::option::Option<Vector3>,
    #[prost(message, repeated, tag = "13")]
    pub part_infos: ::prost::alloc::vec::Vec<ClientHitPartInfo>,
    #[prost(bool, optional, tag = "14")]
    pub is_dodge_success: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "15")]
    pub skill_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Clutter {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub config_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub position_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClutterGenerationRecord {
    #[prost(bool, optional, tag = "1")]
    pub generated: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectingItem {
    #[prost(int32, optional, tag = "1")]
    pub item_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub collected_num: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub collect_price: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub is_high: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityAuthorityInfo {
    #[prost(map = "int32, bool", tag = "1")]
    pub authority: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityBuildFurnitureInfo {
    #[prost(int64, optional, tag = "1")]
    pub build_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub furniture_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub furniture_count: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "7")]
    pub accelerate_count: ::core::option::Option<i32>,
    #[prost(map = "int32, int32", tag = "8")]
    pub accelerate_items: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityCharBasicData {
    #[prost(message, optional, tag = "1")]
    pub basic_data: ::core::option::Option<BasicData>,
    #[prost(message, optional, tag = "2")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(message, optional, tag = "3")]
    pub profession_data: ::core::option::Option<ProfessionData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityData {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int64, repeated, tag = "3")]
    pub cohabitant_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(int64, optional, tag = "4")]
    pub last_exit_cohabitation_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub buy_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub level: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityGetHomeLandBaseInfoReply {
    #[prost(message, optional, tag = "1")]
    pub homeland_base_info: ::core::option::Option<HomelandBaseInfo>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomelandBaseInfo {
    #[prost(int64, optional, tag = "1")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub exp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub home_resource: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub cleanliness: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub lastsubtractcleanlinesstime: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "7")]
    pub home_land_clutter: ::core::option::Option<HomeLandClutterInfo>,
    #[prost(message, optional, tag = "8")]
    pub home_land_clutter_generation_record: ::core::option::Option<
        HomeLandClutterGenerationRecord,
    >,
    #[prost(message, optional, tag = "9")]
    pub home_land_sell_shop_info: ::core::option::Option<HomeLandSellShopInfo>,
    #[prost(map = "int64, message", tag = "10")]
    pub items: ::std::collections::HashMap<i64, HomeLandItemInstance>,
    #[prost(map = "int64, int64", tag = "11")]
    pub slots: ::std::collections::HashMap<i64, i64>,
    #[prost(map = "int64, int64", tag = "12")]
    pub item_to_slot: ::std::collections::HashMap<i64, i64>,
    #[prost(int64, optional, tag = "13")]
    pub capacity: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "14")]
    pub used_slots: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "15")]
    pub house_owner_char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "16")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "17")]
    pub check_in_content: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18")]
    pub introduction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "19")]
    pub transfer_community: ::core::option::Option<CommunityTransfer>,
    #[prost(map = "int64, message", tag = "20")]
    pub cohabitant: ::std::collections::HashMap<i64, CommunityPlayerInfo>,
    #[prost(map = "int32, int32", tag = "21")]
    pub furniture_state: ::std::collections::HashMap<i32, i32>,
    #[prost(message, optional, tag = "22")]
    pub authority_info: ::core::option::Option<CommunityAuthorityInfo>,
    #[prost(int32, optional, tag = "23")]
    pub field_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "24")]
    pub outer_decoration_info: ::core::option::Option<HomelandDecorationInfo>,
    #[prost(message, optional, tag = "25")]
    pub inner_decoration_info: ::core::option::Option<HomelandDecorationInfo>,
    #[prost(int32, repeated, tag = "26")]
    pub unlocked_areas: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "27")]
    pub housing_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "28")]
    pub outer_empty_land: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "29")]
    pub inner_empty_land: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "30")]
    pub flowers_num: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLandClutterInfo {
    #[prost(map = "int64, message", tag = "1")]
    pub home_land_clutter: ::std::collections::HashMap<i64, Clutter>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLandClutterGenerationRecord {
    #[prost(map = "int32, message", tag = "1")]
    pub home_land_clutter_record: ::std::collections::HashMap<
        i32,
        ClutterGenerationRecord,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLandSellShopInfo {
    #[prost(bool, optional, tag = "1")]
    pub is_init: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "2")]
    pub next_reflush_time: ::core::option::Option<i64>,
    #[prost(map = "int32, message", tag = "3")]
    pub collecting_items: ::std::collections::HashMap<i32, CollectingItem>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLandItemInstance {
    #[prost(int64, optional, tag = "1")]
    pub instance_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub config_id: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "3")]
    pub owner_to_stack_map: ::std::collections::HashMap<i64, Item>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityTransfer {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub last_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityPlayerInfo {
    #[prost(message, optional, tag = "1")]
    pub community_char: ::core::option::Option<CommunityCharBasicData>,
    #[prost(message, optional, tag = "2")]
    pub player_authority_info: ::core::option::Option<CommunityPlayerAuthorityInfo>,
    #[prost(message, optional, tag = "3")]
    pub quit_cohabitant: ::core::option::Option<CommunityQuitCohabitant>,
    #[prost(message, optional, tag = "4")]
    pub home_land_player_task_info: ::core::option::Option<HomeLandPlayerTaskInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityPlayerAuthorityInfo {
    #[prost(map = "int32, bool", tag = "1")]
    pub authority: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityQuitCohabitant {
    #[prost(bool, optional, tag = "1")]
    pub is_initiative_quit: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "2")]
    pub time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeLandPlayerTaskInfo {
    #[prost(int64, optional, tag = "1")]
    pub next_task_reflush_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub cur_left_times: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "3")]
    pub cur_task_map: ::std::collections::HashMap<i32, HomeLandTask>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HomeLandTask {
    #[prost(bool, optional, tag = "1")]
    pub finished: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomelandDecorationInfo {
    #[prost(message, optional, tag = "1")]
    pub lamplight_info: ::core::option::Option<HomelandLamplightInfo>,
    #[prost(map = "int32, message", tag = "2")]
    pub material_infos: ::std::collections::HashMap<i32, HomelandMaterialInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HomelandLamplightInfo {
    #[prost(int32, optional, tag = "1")]
    pub lamplight_level: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub lamplight_color: ::core::option::Option<IntVec3>,
    #[prost(int32, optional, tag = "3")]
    pub day_night_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub mode: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HomelandMaterialInfo {
    #[prost(int32, optional, tag = "1")]
    pub material_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub char_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityGetHomeLandBaseInfoRequest {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityGrainUpdateStructureReply {
    #[prost(enumeration = "EErrorCode", optional, tag = "1")]
    pub err_code: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub structures: ::prost::alloc::vec::Vec<CommunityUpdateStructureReplyOpt>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityUpdateStructureReplyOpt {
    #[prost(enumeration = "EErrorCode", optional, tag = "1")]
    pub err_code: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub structure_op: ::core::option::Option<StructureOp>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructureOp {
    #[prost(enumeration = "StructureOpType", optional, tag = "1")]
    pub op_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub structure: ::core::option::Option<Structure>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Structure {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub client_uuid: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub group_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub item_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "6")]
    pub position: ::core::option::Option<IntVec3>,
    #[prost(message, optional, tag = "7")]
    pub quaternion: ::core::option::Option<Vector4>,
    #[prost(int64, optional, tag = "8")]
    pub operator_char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "9")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub material_info: ::core::option::Option<StructureMaterialInfo>,
    #[prost(message, optional, tag = "11")]
    pub lamplight_info: ::core::option::Option<StructureLamplightInfo>,
    #[prost(message, optional, tag = "12")]
    pub farmland_info: ::core::option::Option<StructureFarmlandInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Vector4 {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StructureMaterialInfo {
    #[prost(int32, optional, tag = "1")]
    pub material_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub char_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StructureLamplightInfo {
    #[prost(enumeration = "EHomelandLamplightState", optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructureFarmlandInfo {
    #[prost(int64, optional, tag = "1")]
    pub operator_char_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub seed_instance: ::core::option::Option<HomeLandItemInstance>,
    #[prost(bool, optional, tag = "3")]
    pub need_water: ::core::option::Option<bool>,
    #[prost(enumeration = "EFarmlandState", optional, tag = "4")]
    pub farmland_state: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "5")]
    pub seeding_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub grow_end_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub pollinate_begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub pollinate_end_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub harvest_begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "10")]
    pub harvest_end_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "11")]
    pub is_end: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "12")]
    pub flower_instance: ::core::option::Option<HomeLandItemInstance>,
    #[prost(int32, optional, tag = "13")]
    pub next_segment_index: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "14")]
    pub records: ::prost::alloc::vec::Vec<DroughtRecord>,
    #[prost(int32, repeated, tag = "15")]
    pub fertilizes: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "16")]
    pub pollen_instance: ::core::option::Option<HomeLandItemInstance>,
    #[prost(map = "int64, int32", tag = "17")]
    pub pick_up_players: ::std::collections::HashMap<i64, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DroughtRecord {
    #[prost(int64, optional, tag = "1")]
    pub trigger_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub segment_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub duration: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub actual_end_time: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "5")]
    pub is_watered: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub is_expired: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletedTargetInfo {
    #[prost(map = "int32, bool", tag = "1")]
    pub completed_target_list: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectWorldResult {
    #[prost(enumeration = "WorldReconnectStatus", optional, tag = "1")]
    pub result: ::core::option::Option<i32>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "3")]
    pub ack_client_sequence: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub session_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub connect_guid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DanceBall {
    #[prost(int32, optional, tag = "1")]
    pub dance_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub rand_index: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "5")]
    pub dancers: ::std::collections::HashMap<i64, DancerInfo>,
    #[prost(int32, optional, tag = "6")]
    pub buff_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub npc_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub npc_pos_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub sum_dance_score: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "10")]
    pub has_notify_npc: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DancerInfo {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub dance_secs: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_dancing: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub has_drawn: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub has_send: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelayHitInfo {
    #[prost(int32, optional, tag = "1")]
    pub effect_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub buff_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub play_time: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "5")]
    pub target_infos: ::prost::alloc::vec::Vec<DelayHitTargetInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DelayHitTargetInfo {
    #[prost(int64, optional, tag = "1")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub hit_pos: ::core::option::Option<Vector3>,
    #[prost(float, optional, tag = "3")]
    pub delay_time: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DirtyMask {
    #[prost(int64, repeated, tag = "1")]
    pub dirty_key: ::prost::alloc::vec::Vec<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DrawingLines {
    #[prost(message, optional, tag = "1")]
    pub color: ::core::option::Option<Vector3>,
    #[prost(float, optional, tag = "2")]
    pub width: ::core::option::Option<f32>,
    #[prost(int64, optional, tag = "3")]
    pub delete_time: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "4")]
    pub points: ::prost::alloc::vec::Vec<Position>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonAffixData {
    #[prost(uint32, repeated, tag = "1")]
    pub affix_data: ::prost::alloc::vec::Vec<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonAward {
    #[prost(map = "int64, message", tag = "1")]
    pub items: ::std::collections::HashMap<i64, Item>,
    #[prost(int32, optional, tag = "2")]
    pub flag_assist: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub award_count: ::core::option::Option<i32>,
    #[prost(int64, repeated, tag = "4")]
    pub first_items: ::prost::alloc::vec::Vec<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonBossRank {
    #[prost(map = "int32, message", tag = "1")]
    pub boss_rank: ::std::collections::HashMap<i32, RankData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RankData {
    #[prost(int32, optional, tag = "1")]
    pub rank: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub score: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonDamage {
    #[prost(map = "int64, int64", tag = "1")]
    pub damages: ::std::collections::HashMap<i64, i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEvent {
    #[prost(map = "int32, message", tag = "1")]
    pub dungeon_event_data: ::std::collections::HashMap<i32, DungeonEventData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonEventData {
    #[prost(int32, optional, tag = "1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub start_time: ::core::option::Option<i32>,
    #[prost(enumeration = "DungeonEventState", optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
    #[prost(enumeration = "DungeonEventResult", optional, tag = "4")]
    pub result: ::core::option::Option<i32>,
    #[prost(map = "int32, message", tag = "5")]
    pub dungeon_target: ::std::collections::HashMap<i32, DungeonTargetData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonTargetData {
    #[prost(int32, optional, tag = "1")]
    pub target_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub nums: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub complete: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonFlowInfo {
    #[prost(enumeration = "EDungeonState", optional, tag = "1")]
    pub state: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub active_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub ready_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub play_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub end_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub settlement_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub dungeon_times: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub result: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonHeroKeyInfo {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub hero_key_item: ::prost::alloc::vec::Vec<Item>,
    #[prost(map = "uint32, message", tag = "3")]
    pub key_info: ::std::collections::HashMap<u32, HeroKeyItemInfo>,
    #[prost(message, optional, tag = "4")]
    pub use_item: ::core::option::Option<Item>,
    #[prost(message, repeated, tag = "5")]
    pub hero_key_award_item: ::prost::alloc::vec::Vec<Item>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeroKeyItemInfo {
    #[prost(message, optional, tag = "1")]
    pub item: ::core::option::Option<Item>,
    #[prost(map = "uint32, message", tag = "2")]
    pub roll_info: ::std::collections::HashMap<u32, HeroKeyRollInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HeroKeyRollInfo {
    #[prost(enumeration = "EHeroKeyRollType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub avatar: ::core::option::Option<AvatarInfo>,
    #[prost(uint32, optional, tag = "5")]
    pub roll_value: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonPioneer {
    #[prost(map = "int32, message", tag = "1")]
    pub completed_target_this_time: ::std::collections::HashMap<
        i32,
        CompletedTargetInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonPlanetMemoryRoom {
    #[prost(int32, optional, tag = "1")]
    pub room_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonPlayerInfo {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub social_data: ::core::option::Option<SocialData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SocialData {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub basic_data: ::core::option::Option<BasicData>,
    #[prost(message, optional, tag = "4")]
    pub avatar_info: ::core::option::Option<AvatarInfo>,
    #[prost(message, optional, tag = "5")]
    pub face_data: ::core::option::Option<FaceData>,
    #[prost(message, optional, tag = "6")]
    pub profession_data: ::core::option::Option<ProfessionData>,
    #[prost(message, optional, tag = "7")]
    pub equip_data: ::core::option::Option<EquipData>,
    #[prost(message, optional, tag = "8")]
    pub fashion_data: ::core::option::Option<FashionData>,
    #[prost(message, optional, tag = "9")]
    pub setting_data: ::core::option::Option<SettingData>,
    #[prost(message, optional, tag = "10")]
    pub scene_data: ::core::option::Option<SceneData>,
    #[prost(message, optional, tag = "11")]
    pub user_attr_data: ::core::option::Option<UserAttrData>,
    #[prost(message, optional, tag = "12")]
    pub team_data: ::core::option::Option<CharTeam>,
    #[prost(message, optional, tag = "13")]
    pub union_data: ::core::option::Option<UnionData>,
    #[prost(message, optional, tag = "14")]
    pub account_data: ::core::option::Option<AccountData>,
    #[prost(message, optional, tag = "15")]
    pub function_data: ::core::option::Option<FunctionData>,
    #[prost(message, optional, tag = "16")]
    pub personal_zone: ::core::option::Option<PersonalZone>,
    #[prost(message, optional, tag = "17")]
    pub warehouse: ::core::option::Option<WarehouseData>,
    #[prost(message, optional, tag = "18")]
    pub season_rank: ::core::option::Option<SeasonRankData>,
    #[prost(message, optional, tag = "19")]
    pub fish_data: ::core::option::Option<FishSocialData>,
    #[prost(message, optional, tag = "20")]
    pub community_data: ::core::option::Option<CommunityData>,
    #[prost(message, optional, tag = "21")]
    pub privilege_data: ::core::option::Option<PrivilegeData>,
    #[prost(message, optional, tag = "22")]
    pub master_mode_dungeon_data: ::core::option::Option<MasterModeDungeonData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionData {
    #[prost(int64, optional, tag = "1")]
    pub unionid: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub union_hunt_rank: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WarehouseData {
    #[prost(int64, optional, tag = "1")]
    pub warehouse_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SeasonRankData {
    #[prost(map = "uint32, uint32", tag = "1")]
    pub season_ranks: ::std::collections::HashMap<u32, u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FishSocialData {
    #[prost(map = "int32, message", tag = "1")]
    pub fish_records: ::std::collections::HashMap<i32, FishRecord>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivilegeData {
    #[prost(enumeration = "LaunchPlatform", optional, tag = "1")]
    pub launch_platform: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_privilege: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "3")]
    pub last_update_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MasterModeDungeonData {
    #[prost(int32, optional, tag = "1")]
    pub season_score: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_show: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonPlayerList {
    #[prost(map = "uint32, message", tag = "1")]
    pub player_infos: ::std::collections::HashMap<u32, DungeonPlayerInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonRaidInfo {}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonRandomEntityConfigIdInfo {
    #[prost(map = "int64, int32", tag = "1")]
    pub random_entity_map: ::std::collections::HashMap<i64, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonRankInfo {
    #[prost(int32, optional, tag = "1")]
    pub num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub rank: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonRankList {
    #[prost(map = "int32, message", tag = "1")]
    pub dungeon_rank_map: ::std::collections::HashMap<i32, DungeonRankInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonReviveInfo {
    #[prost(int32, repeated, tag = "1")]
    pub revive_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(map = "int32, int32", tag = "2")]
    pub revive_map: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonSceneInfo {
    #[prost(int32, optional, tag = "1")]
    pub difficulty: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonScore {
    #[prost(int32, optional, tag = "1")]
    pub total_score: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub cur_ratio: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonSettlement {
    #[prost(int32, optional, tag = "1")]
    pub pass_time: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "2")]
    pub award: ::std::collections::HashMap<i64, DungeonAward>,
    #[prost(map = "uint32, message", tag = "3")]
    pub settlement_pos: ::std::collections::HashMap<u32, SettlementPosition>,
    #[prost(message, optional, tag = "4")]
    pub world_boss_settlement: ::core::option::Option<DungeonWorldBossSettlement>,
    #[prost(int32, optional, tag = "5")]
    pub master_mode_score: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettlementPosition {
    #[prost(message, optional, tag = "1")]
    pub pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "2")]
    pub rotate: ::core::option::Option<Position>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonWorldBossSettlement {
    #[prost(int32, optional, tag = "1")]
    pub boss_hp_percent: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub dungeon_boss_rank: ::core::option::Option<DungeonBossRank>,
    #[prost(map = "int64, message", tag = "3")]
    pub award: ::std::collections::HashMap<i64, DungeonAward>,
    #[prost(map = "int64, message", tag = "4")]
    pub boss_rank_award: ::std::collections::HashMap<i64, DungeonAward>,
    #[prost(map = "int64, message", tag = "5")]
    pub last_hit_award: ::std::collections::HashMap<i64, DungeonAward>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonSyncData {
    #[prost(int64, optional, tag = "1")]
    pub scene_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub flow_info: ::core::option::Option<DungeonFlowInfo>,
    #[prost(message, optional, tag = "3")]
    pub title: ::core::option::Option<DungeonTitle>,
    #[prost(message, optional, tag = "4")]
    pub target: ::core::option::Option<DungeonTarget>,
    #[prost(message, optional, tag = "5")]
    pub damage: ::core::option::Option<DungeonDamage>,
    #[prost(message, optional, tag = "6")]
    pub vote: ::core::option::Option<DungeonVote>,
    #[prost(message, optional, tag = "7")]
    pub settlement: ::core::option::Option<DungeonSettlement>,
    #[prost(message, optional, tag = "8")]
    pub dungeon_pioneer: ::core::option::Option<DungeonPioneer>,
    #[prost(message, optional, tag = "9")]
    pub planet_room_info: ::core::option::Option<DungeonPlanetMemoryRoom>,
    #[prost(message, optional, tag = "10")]
    pub dungeon_var: ::core::option::Option<DungeonVar>,
    #[prost(message, optional, tag = "11")]
    pub dungeon_rank: ::core::option::Option<DungeonRankList>,
    #[prost(message, optional, tag = "12")]
    pub dungeon_affix_data: ::core::option::Option<DungeonAffixData>,
    #[prost(message, optional, tag = "13")]
    pub dungeon_event: ::core::option::Option<DungeonEvent>,
    #[prost(message, optional, tag = "14")]
    pub dungeon_score: ::core::option::Option<DungeonScore>,
    #[prost(message, optional, tag = "15")]
    pub timer_info: ::core::option::Option<DungeonTimerInfo>,
    #[prost(message, optional, tag = "16")]
    pub hero_key: ::core::option::Option<DungeonHeroKeyInfo>,
    #[prost(message, optional, tag = "17")]
    pub dungeon_union_info: ::core::option::Option<DungeonUnionInfo>,
    #[prost(message, optional, tag = "18")]
    pub dungeon_player_list: ::core::option::Option<DungeonPlayerList>,
    #[prost(message, optional, tag = "19")]
    pub revive_info: ::core::option::Option<DungeonReviveInfo>,
    #[prost(message, optional, tag = "20")]
    pub random_entity_config_id_info: ::core::option::Option<
        DungeonRandomEntityConfigIdInfo,
    >,
    #[prost(message, optional, tag = "21")]
    pub dungeon_scene_info: ::core::option::Option<DungeonSceneInfo>,
    #[prost(message, optional, tag = "22")]
    pub dungeon_var_all: ::core::option::Option<DungeonVarAll>,
    #[prost(message, optional, tag = "23")]
    pub dungeon_raid_info: ::core::option::Option<DungeonRaidInfo>,
    #[prost(enumeration = "EErrorCode", optional, tag = "24")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonTitle {
    #[prost(map = "int64, message", tag = "1")]
    pub title_list: ::std::collections::HashMap<i64, DungeonTitleList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonTitleList {
    #[prost(map = "int32, message", tag = "1")]
    pub title_info: ::std::collections::HashMap<i32, DungeonTitleInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonTitleInfo {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub title_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonTarget {
    #[prost(map = "int32, message", tag = "1")]
    pub target_data: ::std::collections::HashMap<i32, DungeonTargetData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonVote {
    #[prost(map = "int64, int32", tag = "1")]
    pub vote: ::std::collections::HashMap<i64, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonVar {
    #[prost(message, repeated, tag = "1")]
    pub dungeon_var_data: ::prost::alloc::vec::Vec<DungeonVarData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonVarData {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub value: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DungeonTimerInfo {
    #[prost(enumeration = "EDungeonTimerType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub start_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub dungeon_times: ::core::option::Option<i32>,
    #[prost(enumeration = "EDungeonTimerDirection", optional, tag = "4")]
    pub direction: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub change_time: ::core::option::Option<i32>,
    #[prost(enumeration = "EDungeonTimerEffectType", optional, tag = "7")]
    pub effect_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "8")]
    pub pause_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "9")]
    pub pause_total_time: ::core::option::Option<i32>,
    #[prost(enumeration = "EDungeonTimerTimerLookType", optional, tag = "10")]
    pub out_look_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonUnionInfo {
    #[prost(int64, optional, tag = "1")]
    pub union_id: ::core::option::Option<i64>,
    #[prost(map = "int32, message", tag = "2")]
    pub union_buildings: ::std::collections::HashMap<i32, UnionBuilding>,
    #[prost(map = "int32, message", tag = "3")]
    pub e_screen_infos: ::std::collections::HashMap<i32, UnionEScreenInfo>,
    #[prost(message, optional, tag = "4")]
    pub dance_ball: ::core::option::Option<DanceBall>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionBuilding {
    #[prost(int32, optional, tag = "1")]
    pub building_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub building_level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub upgrade_finish_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub has_speed_up_sec: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnionEScreenInfo {
    #[prost(int32, optional, tag = "1")]
    pub e_screen_id: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "2")]
    pub photo_graphs: ::prost::alloc::vec::Vec<PhotoGraphShow>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PhotoGraphShow {
    #[prost(uint32, optional, tag = "1")]
    pub photo_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag = "2")]
    pub images: ::prost::alloc::vec::Vec<ImageInfo>,
    #[prost(string, optional, tag = "3")]
    pub render_info: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub photo_desc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub owner_info: ::core::option::Option<PhotoOwnerData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageInfo {
    #[prost(enumeration = "EPictureType", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub size: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub version: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "4")]
    pub cos_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub extra_info: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "6")]
    pub review_start_time: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhotoOwnerData {
    #[prost(int64, optional, tag = "1")]
    pub upload_char_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub expire_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub show_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "4")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DungeonVarAll {
    #[prost(map = "int64, message", tag = "1")]
    pub dungeon_var_all_map: ::std::collections::HashMap<i64, DungeonVar>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterSceneInfo {
    #[prost(message, optional, tag = "1")]
    pub scene_attrs: ::core::option::Option<AttrCollection>,
    #[prost(message, optional, tag = "2")]
    pub player_ent: ::core::option::Option<Entity>,
    #[prost(string, optional, tag = "3")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub connect_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "5")]
    pub subscene_attrs: ::core::option::Option<AttrCollection>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entity {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(enumeration = "EEntityType", optional, tag = "2")]
    pub ent_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub attrs: ::core::option::Option<AttrCollection>,
    #[prost(message, optional, tag = "4")]
    pub temp_attrs: ::core::option::Option<TempAttrCollection>,
    #[prost(message, optional, tag = "5")]
    pub body_part_infos: ::core::option::Option<ActorBodyPartInfos>,
    #[prost(message, optional, tag = "6")]
    pub passive_skill_infos: ::core::option::Option<SeqPassiveSkillInfo>,
    #[prost(message, optional, tag = "7")]
    pub buff_infos: ::core::option::Option<BuffInfoSync>,
    #[prost(message, optional, tag = "8")]
    pub buff_effect: ::core::option::Option<BuffEffectSync>,
    #[prost(enumeration = "EAppearType", optional, tag = "9")]
    pub appear_type: ::core::option::Option<i32>,
    #[prost(map = "int64, message", tag = "10")]
    pub magnetic_ride_queue_change_info_dict: ::std::collections::HashMap<
        i64,
        MagneticQueueAppearInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagneticQueueAppearInfo {
    #[prost(int64, repeated, tag = "1")]
    pub passenger_uuid_list: ::prost::alloc::vec::Vec<i64>,
    #[prost(bool, optional, tag = "2")]
    pub is_circle: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "3")]
    pub path_length: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FaceDataDb {
    #[prost(map = "int32, int32", tag = "1")]
    pub face_info: ::std::collections::HashMap<i32, i32>,
    #[prost(map = "int32, message", tag = "2")]
    pub color_info: ::std::collections::HashMap<i32, IntVec3Db>,
    #[prost(float, optional, tag = "3")]
    pub height: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntVec3Db {
    #[prost(int32, optional, tag = "1")]
    pub x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub z: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FishingData {
    #[prost(int32, optional, tag = "1")]
    pub rod_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub area_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub fish_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub stage: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5")]
    pub is_get_fish: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub size: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FishingSetStageRequest {
    #[prost(int32, optional, tag = "1")]
    pub stage: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClientOptionsReply {
    #[prost(map = "string, string", tag = "1")]
    pub options: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientOptionsRequest {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGitVersionReply {
    #[prost(string, optional, tag = "1")]
    pub git_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGitVersionRequest {}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHomelandBuildFurnitureInfoReply {
    #[prost(message, repeated, tag = "1")]
    pub furniture_info: ::prost::alloc::vec::Vec<CommunityBuildFurnitureInfo>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHomelandBuildFurnitureInfoRequest {
    #[prost(int32, optional, tag = "1")]
    pub build_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPathReply {
    #[prost(enumeration = "EErrorCode", optional, tag = "1")]
    pub err_code: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "2")]
    pub reply_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPathRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub request_bytes: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSocialDataReply {
    #[prost(int64, optional, tag = "1")]
    pub mask: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "2")]
    pub data: ::core::option::Option<SocialData>,
    #[prost(enumeration = "EErrorCode", optional, tag = "3")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSocialDataRequest {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub mask: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GmCmd {
    #[prost(string, optional, tag = "1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub target_char_id: ::core::option::Option<i64>,
    #[prost(enumeration = "EGmParsingType", optional, tag = "3")]
    pub parsing_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "4")]
    pub parameter: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GmResult {
    #[prost(bool, optional, tag = "1")]
    pub success: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "2")]
    pub fail_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub ret_params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "EErrorCode", optional, tag = "4")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpCachePhotoInfo {
    #[prost(map = "string, string", tag = "1")]
    pub http_cache_photo_info_dict: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitHomeLandInfo {
    #[prost(bool, optional, tag = "1")]
    pub is_outer: ::core::option::Option<bool>,
    #[prost(map = "int64, message", tag = "2")]
    pub structures: ::std::collections::HashMap<i64, Structure>,
    #[prost(message, optional, tag = "3")]
    pub decoration_info: ::core::option::Option<HomelandDecorationInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InteractionTemplateData {
    #[prost(enumeration = "EInteractionTemplateAction", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "2")]
    pub object_id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "3")]
    pub template_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "5")]
    pub pos_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub sub_template_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkingInfo {
    #[prost(bool, optional, tag = "1")]
    pub is_delete: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub effectid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub buff_uuid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "4")]
    pub target_uuids: ::prost::alloc::vec::Vec<ActorUuidStru>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActorUuidStru {
    #[prost(int32, optional, tag = "1")]
    pub actor_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_summon: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "3")]
    pub instance_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadMapSuccessParam {
    #[prost(string, optional, tag = "1")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub aoi_sync_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub connect_guid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LuaSceneAttrReply {
    #[prost(string, optional, tag = "1")]
    pub attr: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyAntiDataRequest {
    #[prost(message, optional, tag = "1")]
    pub tss_info: ::core::option::Option<TssAccountInfoProto>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TssAccountInfoProto {
    #[prost(string, optional, tag = "1")]
    pub account: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "2")]
    pub account_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub plat_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub game_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "5")]
    pub world_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "6")]
    pub channel_id: ::core::option::Option<u32>,
    #[prost(int64, optional, tag = "7")]
    pub role_id: ::core::option::Option<i64>,
    #[prost(bytes = "vec", optional, tag = "8")]
    pub anti_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "9")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub client_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "11")]
    pub role_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "12")]
    pub index: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyBuildFurnitureOp {
    #[prost(enumeration = "BuildFurnitureOpType", optional, tag = "1")]
    pub op_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "2")]
    pub furniture: ::core::option::Option<CommunityBuildFurnitureInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyCommunityHomeLandDecorationInfoRequest {
    #[prost(bool, optional, tag = "1")]
    pub is_outer: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub decoration_info: ::core::option::Option<HomelandDecorationInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyCommunityHomeLandHousingTypeUpdateRequest {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub old_housing_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub new_housing_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyCommunityHomeLandUnlockedAreasUpdateRequest {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "3")]
    pub unlock_outer_areas: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyEnterWorldRequest {
    #[prost(string, optional, tag = "1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub scene_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "4")]
    pub scene_port: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "5")]
    pub transform: ::core::option::Option<TransferParam>,
    #[prost(message, optional, tag = "6")]
    pub scene_line_data: ::core::option::Option<SceneLineData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferParam {
    #[prost(int32, optional, tag = "1")]
    pub scene_id: ::core::option::Option<i32>,
    #[prost(enumeration = "EUserTransferType", optional, tag = "2")]
    pub transfer_type: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub position_param: ::core::option::Option<PositionParam>,
    #[prost(int64, optional, tag = "4")]
    pub change_flag: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "5")]
    pub is_server_switch: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "6")]
    pub visual_layer_config_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "7")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub connect_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "9")]
    pub sub_scene_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositionParam {
    #[prost(message, optional, tag = "1")]
    pub scene_point_info: ::core::option::Option<ScenePointInfo>,
    #[prost(message, optional, tag = "2")]
    pub scene_pos_info: ::core::option::Option<ScenePosIdInfo>,
    #[prost(message, optional, tag = "3")]
    pub cut_scene_point_info: ::core::option::Option<CutScenePointInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScenePointInfo {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "2")]
    pub camera_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub scene_area_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScenePosIdInfo {
    #[prost(int32, optional, tag = "1")]
    pub scene_pos_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CutScenePointInfo {
    #[prost(int32, optional, tag = "1")]
    pub cut_scene_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SceneLineData {
    #[prost(uint32, optional, tag = "1")]
    pub line_id: ::core::option::Option<u32>,
    #[prost(enumeration = "ESceneLineStatus", optional, tag = "2")]
    pub status: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyFunctionParams {
    #[prost(int32, repeated, tag = "1")]
    pub close_function: ::prost::alloc::vec::Vec<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyHomelandBuildFurnitureOpRequest {
    #[prost(int64, optional, tag = "1")]
    pub community_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub homeland_id: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "3")]
    pub is_outer: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub build_furniture_infos: ::prost::alloc::vec::Vec<NotifyBuildFurnitureOp>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyKickOutOffRequest {
    #[prost(enumeration = "EErrorCode", optional, tag = "1")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyLoadSceneEndResponse {
    #[prost(int32, optional, tag = "1")]
    pub scene_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "2")]
    pub scene_guid: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyPlayerBeginInteractionParam {
    #[prost(uint64, optional, tag = "1")]
    pub object_id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "2")]
    pub template_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifySwitchSceneRequest {
    #[prost(message, optional, tag = "1")]
    pub transfer_param: ::core::option::Option<TransferParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyTimerListParam {
    #[prost(message, repeated, tag = "1")]
    pub timer_info_list: ::prost::alloc::vec::Vec<TimerInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimerInfo {
    #[prost(int32, optional, tag = "1")]
    pub cfg_id: ::core::option::Option<i32>,
    #[prost(enumeration = "ETimerType", optional, tag = "2")]
    pub timer_type: ::core::option::Option<i32>,
    #[prost(enumeration = "ETimerExeType", optional, tag = "3")]
    pub cur_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub start_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub end_timestamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub last_time_stamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "7")]
    pub last_end_time_stamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "8")]
    pub next_time_stamp: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "9")]
    pub next_end_time_stamp: ::core::option::Option<i64>,
    #[prost(int32, repeated, tag = "10")]
    pub offset_list: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag = "11")]
    pub duration: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathNodeList {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub nodes: ::prost::alloc::vec::Vec<PathNode>,
    #[prost(enumeration = "EErrorCode", optional, tag = "3")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PathNode {
    #[prost(float, optional, tag = "1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub z: ::core::option::Option<f32>,
    #[prost(bool, optional, tag = "4")]
    pub is_before: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub is_ground: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhotoInfo {
    #[prost(string, repeated, tag = "1")]
    pub temp_photo_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderBuff {
    #[prost(int32, optional, tag = "1")]
    pub buff_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderFishItem {
    #[prost(int32, optional, tag = "1")]
    pub fish_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderFishPersonalTotal {
    #[prost(int64, optional, tag = "1")]
    pub total: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub myth_total: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub sum_fish_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub sum_sea_life_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub sum_trash_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "6")]
    pub most_fish_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "7")]
    pub favour_zero: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "8")]
    pub user_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub union_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "10")]
    pub is_newbie: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderFishRank {
    #[prost(int32, optional, tag = "1")]
    pub fish_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub rank: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaceHolderItem {
    #[prost(uint32, optional, tag = "1")]
    pub config_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "2")]
    pub item_detail: ::core::option::Option<Item>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlaceHolderMasterMode {
    #[prost(map = "int32, message", tag = "1")]
    pub master_mode_info: ::std::collections::HashMap<i32, MasterModeDiffDungeonInfo>,
    #[prost(string, optional, tag = "2")]
    pub user_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub season_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderPlayer {
    #[prost(int64, optional, tag = "1")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderStr {
    #[prost(string, optional, tag = "1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderTimestamp {
    #[prost(int64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderUnion {
    #[prost(uint32, optional, tag = "1")]
    pub build: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceHolderVal {
    #[prost(uint32, optional, tag = "1")]
    pub value: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayActionParam {
    #[prost(int32, optional, tag = "1")]
    pub action_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub is_upper: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3")]
    pub is_dance_together: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "4")]
    pub mount_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub mount_size: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecvAntiDataRequest {
    #[prost(message, optional, tag = "1")]
    pub tss_info: ::core::option::Option<TssAccountInfoProto>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestConnectWorld {
    #[prost(string, optional, tag = "1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "2")]
    pub char_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "4")]
    pub ack_server_sequence: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "5")]
    pub session_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "6")]
    pub is_ai_bot: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "7")]
    pub client_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub client_resource_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "9")]
    pub os: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReviveInfo {
    #[prost(map = "int32, int32", tag = "1")]
    pub revive_count: ::std::collections::HashMap<i32, i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SceneInteractionInfo {
    #[prost(int32, optional, tag = "1")]
    pub obj_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub pos_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<Vector3>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SchemeInfo {
    #[prost(string, repeated, tag = "1")]
    pub scheme_info_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerSkillStageEnd {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag = "2")]
    pub stage_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "3")]
    pub new_stage_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "4")]
    pub condition_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerStateObjectInteractionList {
    #[prost(message, repeated, tag = "1")]
    pub personal_obj_list: ::prost::alloc::vec::Vec<ServerStateObjectInteractionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSlotAutoBattleRequest {
    #[prost(map = "int32, bool", tag = "1")]
    pub slots: ::std::collections::HashMap<i32, bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShowPieceAttr {
    #[prost(message, optional, tag = "1")]
    pub piece_info: ::core::option::Option<ShowPiecePair>,
    #[prost(int64, optional, tag = "2")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub end_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowPieceAttrList {
    #[prost(message, repeated, tag = "1")]
    pub show_piece_attrs: ::prost::alloc::vec::Vec<ShowPieceAttr>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SkillSkin {
    #[prost(uint32, optional, tag = "1")]
    pub skill_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "2")]
    pub skin_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotData {
    #[prost(map = "int32, message", tag = "1")]
    pub slots: ::std::collections::HashMap<i32, SlotInfoData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlotInfoData {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_replace: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "4")]
    pub show_effect: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "5")]
    pub cd: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "6")]
    pub is_auto_battle_close: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchSceneRequest {
    #[prost(message, optional, tag = "1")]
    pub transfer_param: ::core::option::Option<TransferParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchSceneResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer_param: ::core::option::Option<TransferParam>,
    #[prost(enumeration = "EErrorCode", optional, tag = "2")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOnActivateRideSkinParam {
    #[prost(int32, optional, tag = "1")]
    pub skin_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOnSetRideSkinParam {
    #[prost(int32, optional, tag = "1")]
    pub skin_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TeleportParams {
    #[prost(message, optional, tag = "1")]
    pub transfer_params: ::core::option::Option<TransferParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TempPhotoCache {
    #[prost(map = "string, message", tag = "1")]
    pub temp_photo_cache_dict: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TempPhotoCacheInfo,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TempPhotoCacheInfo {
    #[prost(string, optional, tag = "1")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub temp_photo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub temp_ori_photo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub temp_thumb_photo: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "5")]
    pub shot_time: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "6")]
    pub shot_time_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub shot_place: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub decorate_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "9")]
    pub height: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub width: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ThrowMoveInfo {
    #[prost(int64, optional, tag = "1")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub skill_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "4")]
    pub stage_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub event_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnlockInfo {
    #[prost(uint64, optional, tag = "1")]
    pub object_id: ::core::option::Option<u64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStructureRequest {
    #[prost(int64, optional, tag = "1")]
    pub home_id: ::core::option::Option<i64>,
    #[prost(message, repeated, tag = "2")]
    pub ops: ::prost::alloc::vec::Vec<StructureOp>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserControlInfo {
    #[prost(bool, optional, tag = "1")]
    pub is_begin: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub secondary_type: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "4")]
    pub remain_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub step: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "6")]
    pub hor_velocity: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "7")]
    pub ver_velocity: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "8")]
    pub pitch_angle: ::core::option::Option<f32>,
    #[prost(int64, optional, tag = "9")]
    pub time_stamp: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "10")]
    pub run_dir: ::core::option::Option<Vector2>,
    #[prost(message, optional, tag = "11")]
    pub normal: ::core::option::Option<Vector3>,
    #[prost(message, optional, tag = "12")]
    pub cur_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "13")]
    pub dest_pos: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "14")]
    pub move_version: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserNotifyTriggerInfo {
    #[prost(enumeration = "ENotifyTrigger", optional, tag = "1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(enumeration = "EEntityType", optional, tag = "3")]
    pub trigger_actor_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "4")]
    pub trigger_actor_is_summon: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "5")]
    pub trigger_actor_instance_id: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "6")]
    pub trigger_actor_table_uid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseSkillParam {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub skillid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub skill_level: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub begin_time: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "5")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "6")]
    pub target_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "7")]
    pub cur_pos: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "8")]
    pub target_part_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "9")]
    pub target_part_pos: ::core::option::Option<Position>,
    #[prost(bool, optional, tag = "10")]
    pub is_passive: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "11")]
    pub is_activate_roulette: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UseSlotRequest {
    #[prost(int32, optional, tag = "1")]
    pub slot_id: ::core::option::Option<i32>,
    #[prost(enumeration = "EUseSlotType", optional, tag = "2")]
    pub use_type: ::core::option::Option<i32>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub extra_data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifySwitchScene {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<NotifySwitchSceneRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifySwitchSceneEnd {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<SwitchSceneResponse>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterScene {
    #[prost(message, optional, tag = "1")]
    pub enter_scene_info: ::core::option::Option<EnterSceneInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyLoadSceneEnd {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<NotifyLoadSceneEndResponse>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Teleport {
    #[prost(message, optional, tag = "1")]
    pub teleport_params: ::core::option::Option<TeleportParams>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncNearEntities {
    #[prost(message, repeated, tag = "1")]
    pub appear: ::prost::alloc::vec::Vec<Entity>,
    #[prost(message, repeated, tag = "2")]
    pub disappear: ::prost::alloc::vec::Vec<DisappearEntity>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisappearEntity {
    #[prost(int64, optional, tag = "1")]
    pub uuid: ::core::option::Option<i64>,
    #[prost(enumeration = "EDisappearType", optional, tag = "2")]
    pub r#type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncSceneAttrs {
    #[prost(message, optional, tag = "1")]
    pub attrs: ::core::option::Option<AttrCollection>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncSceneEvents {
    #[prost(message, optional, tag = "1")]
    pub evt: ::core::option::Option<EventDataList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncEntityBehaviorTree {
    #[prost(int64, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "2")]
    pub json: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncPlayCameraAnimation {
    #[prost(int32, optional, tag = "1")]
    pub id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncFieldOfView {
    #[prost(string, optional, tag = "1")]
    pub json: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncLog {
    #[prost(string, optional, tag = "1")]
    pub log: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorldNtfSyncPathNode {
    #[prost(message, optional, tag = "1")]
    pub lists: ::core::option::Option<PathNodeList>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncServerData {
    #[prost(message, optional, tag = "1")]
    pub server_data: ::core::option::Option<ServerData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerData {
    #[prost(int64, optional, tag = "1")]
    pub open_server_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ForcedPullBack {
    #[prost(message, optional, tag = "1")]
    pub cur_pos: ::core::option::Option<Position>,
    #[prost(bool, optional, tag = "2")]
    pub force: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineDrawing {
    #[prost(message, optional, tag = "1")]
    pub lines: ::core::option::Option<DrawingLines>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncContainerData {
    #[prost(message, optional, tag = "1")]
    pub v_data: ::core::option::Option<CharSerialize>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncContainerDirtyData {
    #[prost(message, optional, tag = "1")]
    pub v_data: ::core::option::Option<BufferStream>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncDungeonData {
    #[prost(message, optional, tag = "1")]
    pub v_data: ::core::option::Option<DungeonSyncData>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncDungeonDirtyData {
    #[prost(message, optional, tag = "1")]
    pub v_data: ::core::option::Option<BufferStream>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncPersonalObject {
    #[prost(message, optional, tag = "1")]
    pub v_datas: ::core::option::Option<ScenePersonalObject>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PersonalObjectUpdate {
    #[prost(message, optional, tag = "1")]
    pub v_param: ::core::option::Option<ServerStateObjectInteractionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyReviveUser {
    #[prost(int64, optional, tag = "1")]
    pub v_actor_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncServerTime {
    #[prost(int64, optional, tag = "1")]
    pub client_milliseconds: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "2")]
    pub server_milliseconds: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncNearDeltaInfo {
    #[prost(message, repeated, tag = "1")]
    pub delta_infos: ::prost::alloc::vec::Vec<AoiSyncDelta>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncToMeDeltaInfo {
    #[prost(message, optional, tag = "1")]
    pub delta_info: ::core::option::Option<AoiSyncToMeDelta>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyClientKickOff {
    #[prost(enumeration = "EErrorCode", optional, tag = "1")]
    pub err_code: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalGroupObjectUpdate {
    #[prost(message, optional, tag = "1")]
    pub v_param_list: ::core::option::Option<ServerStateObjectInteractionList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyUserCloseFunction {
    #[prost(message, optional, tag = "1")]
    pub v_param: ::core::option::Option<NotifyFunctionParams>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyServerCloseFunction {
    #[prost(message, optional, tag = "1")]
    pub v_param: ::core::option::Option<NotifyFunctionParams>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BounceJump {
    #[prost(int32, optional, tag = "1")]
    pub bounce_jump_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub axis_ref_uuid: ::core::option::Option<i64>,
    #[prost(float, optional, tag = "3")]
    pub vel_dir_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub vel_dir_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "5")]
    pub vel_dir_z: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerStateObjectUpdate {
    #[prost(message, optional, tag = "1")]
    pub v_object: ::core::option::Option<ServerStateObjectInteractionList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncAllServerStateObject {
    #[prost(message, optional, tag = "1")]
    pub v_object: ::core::option::Option<ServerStateObjectInteractionList>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyTimerList {
    #[prost(message, optional, tag = "1")]
    pub timer_info: ::core::option::Option<NotifyTimerListParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyTimerUpdate {
    #[prost(message, optional, tag = "1")]
    pub timer_info: ::core::option::Option<TimerInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyPlayerBeginInteraction {
    #[prost(message, optional, tag = "1")]
    pub v_param: ::core::option::Option<NotifyPlayerBeginInteractionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncSubSceneAttrs {
    #[prost(message, optional, tag = "1")]
    pub attrs: ::core::option::Option<AttrCollection>,
    #[prost(bool, optional, tag = "2")]
    pub is_first_enter: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncClientUseSkill {
    #[prost(int64, optional, tag = "1")]
    pub skill_target_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub skill_level_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyBuffChange {
    #[prost(int32, optional, tag = "1")]
    pub old_buff_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub new_buff_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncServerSkillStageEnd {
    #[prost(message, optional, tag = "1")]
    pub skill_stage_end_info: ::core::option::Option<ServerSkillStageEnd>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncServerSkillEnd {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncServerSkillSingingTimeSub {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub time: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyKickOutOff {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<NotifyKickOutOffRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyEnterWorld {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<NotifyEnterWorldRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangeCharFunctionState {
    #[prost(enumeration = "EActorState", optional, tag = "1")]
    pub state_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientBreakState {
    #[prost(int32, optional, tag = "1")]
    pub v_operator: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GmCommand {
    #[prost(message, optional, tag = "1")]
    pub cmd: ::core::option::Option<GmCmd>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonitorBehaviorTreeOfEntity {
    #[prost(int64, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReqServerTime {
    #[prost(int64, optional, tag = "1")]
    pub client_milliseconds: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncPathNode {
    #[prost(int64, optional, tag = "1")]
    pub entity_id: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayEmote {
    #[prost(int32, optional, tag = "1")]
    pub emote_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LearnExpressionAction {
    #[prost(int32, optional, tag = "1")]
    pub expression_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonsterCastSkill {
    #[prost(int64, optional, tag = "1")]
    pub self_uuid: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub skill_id: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub target_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncDirWhenAiming {
    #[prost(float, optional, tag = "1")]
    pub dir: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub aim_dir: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetPersonalState {
    #[prost(int32, optional, tag = "1")]
    pub v_personal_state: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub v_is_remove: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstallResonanceSkillReq {
    #[prost(int32, optional, tag = "1")]
    pub v_position: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub v_resonance_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlayAction {
    #[prost(message, optional, tag = "1")]
    pub play_action_param: ::core::option::Option<PlayActionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectWorld {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<RequestConnectWorld>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UseSkill {
    #[prost(message, optional, tag = "1")]
    pub param: ::core::option::Option<UseSkillParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccumulateEnd {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub end_time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttrInBattleShowSync {
    #[prost(int32, optional, tag = "1")]
    pub attr_in_battle_show: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncSkillLocation {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub skill_stage: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub cur_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "4")]
    pub dest_pos: ::core::option::Option<Position>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncHitInfo {
    #[prost(message, repeated, tag = "1")]
    pub hit_infos: ::prost::alloc::vec::Vec<ClientHitInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChannelingEnd {
    #[prost(int32, optional, tag = "1")]
    pub skill_uuid: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub time: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncSkillStageTrigger {
    #[prost(int32, optional, tag = "1")]
    pub trigger_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "3")]
    pub skill_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientStageEnd {
    #[prost(int32, optional, tag = "1")]
    pub cur_stage_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub next_stage_index: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "3")]
    pub time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "4")]
    pub condition_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub skill_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientTargetChange {
    #[prost(int32, optional, tag = "1")]
    pub skillid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub skill_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub cur_stage_index: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub target_uuid: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "5")]
    pub target_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "6")]
    pub cur_pos: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "7")]
    pub target_part_id: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "8")]
    pub target_part_pos: ::core::option::Option<Position>,
    #[prost(int32, optional, tag = "9")]
    pub skill_uuid: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncBulletHitInfo {
    #[prost(message, repeated, tag = "1")]
    pub hit_infos: ::prost::alloc::vec::Vec<ClientHitInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFakeBulletHitInfo {
    #[prost(message, repeated, tag = "1")]
    pub hit_infos: ::prost::alloc::vec::Vec<ClientHitInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncUserBeHitInfo {
    #[prost(message, repeated, tag = "1")]
    pub behit_infos: ::prost::alloc::vec::Vec<ClientHitInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiBotMove {
    #[prost(message, optional, tag = "1")]
    pub move_param: ::core::option::Option<BotMoveInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiBotUseSkill {
    #[prost(message, optional, tag = "1")]
    pub use_skill_param: ::core::option::Option<BotUseSkillInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotAddBuffByConfigId {
    #[prost(message, optional, tag = "1")]
    pub add_buff_param: ::core::option::Option<BotAddBuff>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotRemoveBuffByConfigId {
    #[prost(message, optional, tag = "1")]
    pub remove_buff_param: ::core::option::Option<BotRemoveBuff>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotActiveTrigger {
    #[prost(message, optional, tag = "1")]
    pub active_trigger_param: ::core::option::Option<BotActiveTrigger>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AiBotTeleportToPos {
    #[prost(message, optional, tag = "1")]
    pub teleport_param: ::core::option::Option<BotTeleportParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotPlayAction {
    #[prost(message, optional, tag = "1")]
    pub play_action_param: ::core::option::Option<BotPlayActionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotSendGmMsg {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<GmCmd>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotStartRide {
    #[prost(message, optional, tag = "1")]
    pub start_ride_param: ::core::option::Option<BotStartRideParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotSendChitChatMsg {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<BotSendChitChatMsgReq>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AiBotResurrection {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<BotResurrectionParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReqSwitchScene {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<SwitchSceneRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadMapSuccess {
    #[prost(message, optional, tag = "1")]
    pub v_param: ::core::option::Option<LoadMapSuccessParam>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserDoAction {
    #[prost(string, optional, tag = "1")]
    pub v_selected_str: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserNotifyTrigger {
    #[prost(message, optional, tag = "1")]
    pub v_info: ::core::option::Option<UserNotifyTriggerInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetLuaSceneAttr {
    #[prost(string, optional, tag = "1")]
    pub v_attribute_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SaveUserSingleSceneCutsState {
    #[prost(int32, optional, tag = "1")]
    pub cuts_key: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub cuts_value: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetAoiSyncUserCount {
    #[prost(int32, optional, tag = "1")]
    pub v_count: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CutScenePlayEnd {
    #[prost(uint32, optional, tag = "1")]
    pub v_cut_scene_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FlowPlayEnd {
    #[prost(uint32, optional, tag = "1")]
    pub v_flow_id: ::core::option::Option<u32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncSceneArea {
    #[prost(int32, optional, tag = "1")]
    pub scene_area_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartPlayAction {
    #[prost(int64, optional, tag = "1")]
    pub v_invitee_id: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "2")]
    pub v_action_id: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub v_is_upper: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetInteractionPartnerPos {
    #[prost(message, optional, tag = "1")]
    pub v_cur_pos: ::core::option::Option<Position>,
    #[prost(message, optional, tag = "2")]
    pub v_dest_pos: ::core::option::Option<Position>,
    #[prost(enumeration = "EMoveType", optional, tag = "3")]
    pub v_move_type: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "4")]
    pub v_time_stamp: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InteractionWithNotPlayer {
    #[prost(int32, optional, tag = "1")]
    pub v_entity_config_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub v_entity_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3")]
    pub v_action_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetAiming {
    #[prost(bool, optional, tag = "1")]
    pub is_aiming: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttachVelocity {
    #[prost(float, optional, tag = "1")]
    pub attach_speed: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub vel_dir_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub vel_dir_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "4")]
    pub vel_dir_z: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "5")]
    pub attach_source: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "6")]
    pub source_ent_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResetAttachVelocity {
    #[prost(int32, optional, tag = "1")]
    pub attach_source: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "2")]
    pub source_ent_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetTunnel {
    #[prost(int32, optional, tag = "1")]
    pub tunnel_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewMove {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<UserControlInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PersonalObjectAction {
    #[prost(int64, optional, tag = "1")]
    pub v_obj_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOnShowPiece {
    #[prost(enumeration = "EShowPieceType", optional, tag = "1")]
    pub v_piece_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub v_piece_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOffShowPiece {
    #[prost(enumeration = "EShowPieceType", optional, tag = "1")]
    pub v_piece_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub v_piece_id: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Interaction {
    #[prost(message, optional, tag = "1")]
    pub v_info: ::core::option::Option<InteractionTemplateData>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InteractionActionEnd {
    #[prost(int32, optional, tag = "1")]
    pub cur_stage: ::core::option::Option<i32>,
    #[prost(enumeration = "EInteractionAction", optional, tag = "2")]
    pub action_type: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub is_success: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UploadTLogBody {
    #[prost(string, optional, tag = "1")]
    pub t_log_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub t_log_body: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CommunityGetHomeLandBaseInfo {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<CommunityGetHomeLandBaseInfoRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStructure {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<UpdateStructureRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetHomelandBuildFurnitureInfo {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<GetHomelandBuildFurnitureInfoRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UseSlot {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<UseSlotRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSlotAutoBattle {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<SetSlotAutoBattleRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MonsterHuntUnlockMonster {
    #[prost(message, optional, tag = "1")]
    pub info: ::core::option::Option<UnlockInfo>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FishingSetStage {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<FishingSetStageRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSocialData {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<GetSocialDataRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StopRide {
    #[prost(bool, optional, tag = "1")]
    pub is_force: ::core::option::Option<bool>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DetachRideMagnetic {
    #[prost(enumeration = "EDetachMagneticType", optional, tag = "1")]
    pub detach_type: ::core::option::Option<i32>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RideMagneticAttachTo {
    #[prost(int64, optional, tag = "1")]
    pub target_uuid: ::core::option::Option<i64>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOnActivateRideSkin {
    #[prost(message, optional, tag = "1")]
    pub param: ::core::option::Option<TakeOnActivateRideSkinParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TakeOnSetRideSkin {
    #[prost(message, optional, tag = "1")]
    pub param: ::core::option::Option<TakeOnSetRideSkinParam>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SyncCirclePathLength {
    #[prost(float, optional, tag = "1")]
    pub path_length: ::core::option::Option<f32>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPath {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<GetPathRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyHomelandBuildFurnitureOp {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<NotifyHomelandBuildFurnitureOpRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifyCommunityHomeLandDecorationInfo {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<NotifyCommunityHomeLandDecorationInfoRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyCommunityHomeLandHousingTypeUpdate {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<NotifyCommunityHomeLandHousingTypeUpdateRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyCommunityHomeLandUnlockedAreasUpdate {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<
        NotifyCommunityHomeLandUnlockedAreasUpdateRequest,
    >,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGitVersion {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<GetGitVersionRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientOptions {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<GetClientOptionsRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NotifyAntiData {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<NotifyAntiDataRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecvAntiData {
    #[prost(message, optional, tag = "1")]
    pub v_request: ::core::option::Option<RecvAntiDataRequest>,
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SystemType {
    Null = 0,
    Android = 1,
    Ios = 2,
    Web = 3,
    Linux = 4,
    Windows = 5,
}
impl SystemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "SystemType_Null",
            Self::Android => "SystemType_Android",
            Self::Ios => "SystemType_Ios",
            Self::Web => "SystemType_Web",
            Self::Linux => "SystemType_Linux",
            Self::Windows => "SystemType_Windows",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SystemType_Null" => Some(Self::Null),
            "SystemType_Android" => Some(Self::Android),
            "SystemType_Ios" => Some(Self::Ios),
            "SystemType_Web" => Some(Self::Web),
            "SystemType_Linux" => Some(Self::Linux),
            "SystemType_Windows" => Some(Self::Windows),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BodyPartState {
    Default = 0,
    Injury = 1,
    Dead = 2,
}
impl BodyPartState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "BodyPartStateDefault",
            Self::Injury => "BodyPartStateInjury",
            Self::Dead => "BodyPartStateDead",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BodyPartStateDefault" => Some(Self::Default),
            "BodyPartStateInjury" => Some(Self::Injury),
            "BodyPartStateDead" => Some(Self::Dead),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDamageSource {
    Skill = 0,
    Bullet = 1,
    Buff = 2,
    Fall = 3,
    FakeBullet = 4,
    Other = 100,
}
impl EDamageSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Skill => "EDamageSourceSkill",
            Self::Bullet => "EDamageSourceBullet",
            Self::Buff => "EDamageSourceBuff",
            Self::Fall => "EDamageSourceFall",
            Self::FakeBullet => "EDamageSourceFakeBullet",
            Self::Other => "EDamageSourceOther",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDamageSourceSkill" => Some(Self::Skill),
            "EDamageSourceBullet" => Some(Self::Bullet),
            "EDamageSourceBuff" => Some(Self::Buff),
            "EDamageSourceFall" => Some(Self::Fall),
            "EDamageSourceFakeBullet" => Some(Self::FakeBullet),
            "EDamageSourceOther" => Some(Self::Other),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDamageType {
    Normal = 0,
    Miss = 1,
    Heal = 2,
    Immune = 3,
    Fall = 4,
    Absorbed = 5,
}
impl EDamageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "Normal",
            Self::Miss => "Miss",
            Self::Heal => "Heal",
            Self::Immune => "Immune",
            Self::Fall => "Fall",
            Self::Absorbed => "Absorbed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Normal" => Some(Self::Normal),
            "Miss" => Some(Self::Miss),
            "Heal" => Some(Self::Heal),
            "Immune" => Some(Self::Immune),
            "Fall" => Some(Self::Fall),
            "Absorbed" => Some(Self::Absorbed),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDamageProperty {
    General = 0,
    Fire = 1,
    Water = 2,
    Electricity = 3,
    Wood = 4,
    Wind = 5,
    Rock = 6,
    Light = 7,
    Dark = 8,
    Count = 9,
}
impl EDamageProperty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::General => "General",
            Self::Fire => "Fire",
            Self::Water => "Water",
            Self::Electricity => "Electricity",
            Self::Wood => "Wood",
            Self::Wind => "Wind",
            Self::Rock => "Rock",
            Self::Light => "Light",
            Self::Dark => "Dark",
            Self::Count => "Count",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "General" => Some(Self::General),
            "Fire" => Some(Self::Fire),
            "Water" => Some(Self::Water),
            "Electricity" => Some(Self::Electricity),
            "Wood" => Some(Self::Wood),
            "Wind" => Some(Self::Wind),
            "Rock" => Some(Self::Rock),
            "Light" => Some(Self::Light),
            "Dark" => Some(Self::Dark),
            "Count" => Some(Self::Count),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDamageMode {
    DamageNormal = 0,
    DamagePhysical = 1,
    DamageMagical = 2,
}
impl EDamageMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DamageNormal => "DamageNormal",
            Self::DamagePhysical => "DamagePhysical",
            Self::DamageMagical => "DamageMagical",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DamageNormal" => Some(Self::DamageNormal),
            "DamagePhysical" => Some(Self::DamagePhysical),
            "DamageMagical" => Some(Self::DamageMagical),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EBuffEffectLogicPbType {
    PlayEffect = 0,
    Gravity = 1,
    ParabolaEffect = 2,
    Linking = 3,
    ConfusionEffect = 4,
    ZoomScale = 5,
    BuffProfessionEffect = 7,
    TeleportBelt = 8,
    BuffEffectRainbow = 9,
    BuffEffectAttrHud = 11,
    BuffEffectStop = 12,
    BuffEffectProgress = 13,
    BuffEffectEnergyDisplay = 14,
    BuffEffectStopAll = 15,
    BuffEffectLayerChange = 16,
    Tension = 17,
}
impl EBuffEffectLogicPbType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PlayEffect => "PlayEffect",
            Self::Gravity => "Gravity",
            Self::ParabolaEffect => "ParabolaEffect",
            Self::Linking => "Linking",
            Self::ConfusionEffect => "ConfusionEffect",
            Self::ZoomScale => "ZoomScale",
            Self::BuffProfessionEffect => "BuffProfessionEffect",
            Self::TeleportBelt => "TeleportBelt",
            Self::BuffEffectRainbow => "BuffEffectRainbow",
            Self::BuffEffectAttrHud => "BuffEffectAttrHUD",
            Self::BuffEffectStop => "BuffEffectStop",
            Self::BuffEffectProgress => "BuffEffectProgress",
            Self::BuffEffectEnergyDisplay => "BuffEffectEnergyDisplay",
            Self::BuffEffectStopAll => "BuffEffectStopAll",
            Self::BuffEffectLayerChange => "BuffEffectLayerChange",
            Self::Tension => "Tension",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PlayEffect" => Some(Self::PlayEffect),
            "Gravity" => Some(Self::Gravity),
            "ParabolaEffect" => Some(Self::ParabolaEffect),
            "Linking" => Some(Self::Linking),
            "ConfusionEffect" => Some(Self::ConfusionEffect),
            "ZoomScale" => Some(Self::ZoomScale),
            "BuffProfessionEffect" => Some(Self::BuffProfessionEffect),
            "TeleportBelt" => Some(Self::TeleportBelt),
            "BuffEffectRainbow" => Some(Self::BuffEffectRainbow),
            "BuffEffectAttrHUD" => Some(Self::BuffEffectAttrHud),
            "BuffEffectStop" => Some(Self::BuffEffectStop),
            "BuffEffectProgress" => Some(Self::BuffEffectProgress),
            "BuffEffectEnergyDisplay" => Some(Self::BuffEffectEnergyDisplay),
            "BuffEffectStopAll" => Some(Self::BuffEffectStopAll),
            "BuffEffectLayerChange" => Some(Self::BuffEffectLayerChange),
            "Tension" => Some(Self::Tension),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EBuffEventType {
    BuffEventUnknown = 0,
    BuffEventAddTo = 1,
    BuffEventRemove = 2,
    BuffEventReplace = 3,
    BuffEventTimer = 4,
    BuffEventStackLayer = 5,
    BuffEventRemoveLayer = 6,
    BuffEventOnHitTargetBefore = 7,
    BuffEventOnHitTargetAfter = 8,
    BuffEventOnHittedBefore = 9,
    BuffEventOnHittedAfter = 10,
    BuffEventOnReachMaxLayer = 11,
    BuffEventHostDeath = 12,
    BuffEventOnSkillHitAfter = 13,
    BuffEventTrigTimingAura = 14,
    BuffEventBodyPartDead = 15,
    BuffEventBodyPartHit = 16,
    BuffEventBodyPartStateChange = 17,
    BuffEventOnPartHittedBefore = 18,
    BuffEventOnPartHittedAfter = 19,
    BuffEventGravitational = 20,
    BuffEventFightResChange = 21,
    BuffEventOnKillActor = 23,
    BuffEventAttrWatcher = 24,
    BuffEventOnHittedLhBefore = 25,
    BuffEventOnBeHittedLhBefore = 26,
    BuffEventAddByTarget = 27,
    BuffEventRemoveByTarget = 28,
    BuffEventInCombatState = 29,
    BuffEventOutCombatState = 30,
    BuffEventSkillBegin = 31,
    BuffEventSkillEnd = 32,
    BuffEventSingingEnd = 34,
    BuffEventSummonBuffAdd = 35,
    BuffEventSummonEntity = 36,
    BuffEventGuideEnd = 37,
    BuffEventOnDelayHit = 39,
    BuffEventTeamBuffAdd = 40,
    BuffEventChangeProfession = 41,
    BuffEventDodgeSuccess = 42,
    BuffEventHealBefore = 43,
    BuffEventHealAfter = 44,
    BuffEventProduceHealBefore = 45,
    BuffEventProduceHealAfter = 46,
    BuffEventShieldBroken = 47,
    BuffEventLinkingStart = 48,
    BuffEventLinkingEnd = 49,
    BuffEventLinkingWatcher = 50,
    BuffEventSuperArmorBroken = 51,
    BuffEventAddedByTargetTag = 52,
    BuffEventAddToTargetTag = 53,
    BuffEventOnBeHitLessenHp = 57,
    BuffEventEnterBreaking = 58,
    BuffEventTeleportBelt = 59,
    BuffEventOnBeHitAfterOnly = 63,
    BuffEventOnHitAfterOnly = 64,
    BuffEventOnBeHealAfterOnly = 65,
    BuffEventOnHealAfterOnly = 66,
    BuffEventHealCalcAttrBefore = 67,
    BuffEventProduceHealCalcAttrBefore = 68,
    BuffEventReviveSuccessEnd = 69,
    BuffEventAfterReviveFirstMove = 70,
    BuffEventMonsterIntoAlert = 71,
    BuffEventMonsterOutAlert = 72,
    BuffEventOnAddShieldCalcBefore = 73,
    BuffEventOnAddShieldBefore = 74,
    BuffEventOnAddShieldAfter = 75,
    BuffEventOnBeAddedShieldCalcBefore = 76,
    BuffEventOnBeAddedShieldBefore = 77,
    BuffEventOnBeAddedShieldAfter = 78,
    BuffEventProgressWatcher = 79,
    BuffEventOnLuckyDamage = 80,
    BuffEventSkillCdEnd = 81,
    BuffEventMotionless = 82,
    BuffEventParticipateKill = 83,
    BuffEventProfessionBdTypeChange = 84,
    BuffEventSingingBegin = 85,
    BuffEventGuideBegin = 86,
    BuffEventRandTimer = 87,
    BuffEventIntoFractureState = 88,
    BuffEventTakeOnRide = 89,
    BuffEventTakeOffRide = 90,
    BuffEventStartJump = 91,
    BuffEventPlayAction = 92,
    BuffEventPlayEmote = 93,
    BuffEventCheck = 1001,
    BuffEventCustomize = 1002,
    BuffEventShapeshiftEndEvent = 1003,
    BuffEventAttrRefresh = 1004,
    BuffEventMonitorTeamKillActor = 1005,
    BuffEventSpecialEffects = 10001,
}
impl EBuffEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BuffEventUnknown => "BuffEventUnknown",
            Self::BuffEventAddTo => "BuffEventAddTo",
            Self::BuffEventRemove => "BuffEventRemove",
            Self::BuffEventReplace => "BuffEventReplace",
            Self::BuffEventTimer => "BuffEventTimer",
            Self::BuffEventStackLayer => "BuffEventStackLayer",
            Self::BuffEventRemoveLayer => "BuffEventRemoveLayer",
            Self::BuffEventOnHitTargetBefore => "BuffEventOnHitTargetBefore",
            Self::BuffEventOnHitTargetAfter => "BuffEventOnHitTargetAfter",
            Self::BuffEventOnHittedBefore => "BuffEventOnHittedBefore",
            Self::BuffEventOnHittedAfter => "BuffEventOnHittedAfter",
            Self::BuffEventOnReachMaxLayer => "BuffEventOnReachMaxLayer",
            Self::BuffEventHostDeath => "BuffEventHostDeath",
            Self::BuffEventOnSkillHitAfter => "BuffEventOnSkillHitAfter",
            Self::BuffEventTrigTimingAura => "BuffEventTrigTimingAura",
            Self::BuffEventBodyPartDead => "BuffEventBodyPartDead",
            Self::BuffEventBodyPartHit => "BuffEventBodyPartHit",
            Self::BuffEventBodyPartStateChange => "BuffEventBodyPartStateChange",
            Self::BuffEventOnPartHittedBefore => "BuffEventOnPartHittedBefore",
            Self::BuffEventOnPartHittedAfter => "BuffEventOnPartHittedAfter",
            Self::BuffEventGravitational => "BuffEventGravitational",
            Self::BuffEventFightResChange => "BuffEventFightResChange",
            Self::BuffEventOnKillActor => "BuffEventOnKillActor",
            Self::BuffEventAttrWatcher => "BuffEventAttrWatcher",
            Self::BuffEventOnHittedLhBefore => "BuffEventOnHittedLHBefore",
            Self::BuffEventOnBeHittedLhBefore => "BuffEventOnBeHittedLHBefore",
            Self::BuffEventAddByTarget => "BuffEventAddByTarget",
            Self::BuffEventRemoveByTarget => "BuffEventRemoveByTarget",
            Self::BuffEventInCombatState => "BuffEventInCombatState",
            Self::BuffEventOutCombatState => "BuffEventOutCombatState",
            Self::BuffEventSkillBegin => "BuffEventSkillBegin",
            Self::BuffEventSkillEnd => "BuffEventSkillEnd",
            Self::BuffEventSingingEnd => "BuffEventSingingEnd",
            Self::BuffEventSummonBuffAdd => "BuffEventSummonBuffAdd",
            Self::BuffEventSummonEntity => "BuffEventSummonEntity",
            Self::BuffEventGuideEnd => "BuffEventGuideEnd",
            Self::BuffEventOnDelayHit => "BuffEventOnDelayHit",
            Self::BuffEventTeamBuffAdd => "BuffEventTeamBuffAdd",
            Self::BuffEventChangeProfession => "BuffEventChangeProfession",
            Self::BuffEventDodgeSuccess => "BuffEventDodgeSuccess",
            Self::BuffEventHealBefore => "BuffEventHealBefore",
            Self::BuffEventHealAfter => "BuffEventHealAfter",
            Self::BuffEventProduceHealBefore => "BuffEventProduceHealBefore",
            Self::BuffEventProduceHealAfter => "BuffEventProduceHealAfter",
            Self::BuffEventShieldBroken => "BuffEventShieldBroken",
            Self::BuffEventLinkingStart => "BuffEventLinkingStart",
            Self::BuffEventLinkingEnd => "BuffEventLinkingEnd",
            Self::BuffEventLinkingWatcher => "BuffEventLinkingWatcher",
            Self::BuffEventSuperArmorBroken => "BuffEventSuperArmorBroken",
            Self::BuffEventAddedByTargetTag => "BuffEventAddedByTargetTag",
            Self::BuffEventAddToTargetTag => "BuffEventAddToTargetTag",
            Self::BuffEventOnBeHitLessenHp => "BuffEventOnBeHitLessenHp",
            Self::BuffEventEnterBreaking => "BuffEventEnterBreaking",
            Self::BuffEventTeleportBelt => "BuffEventTeleportBelt",
            Self::BuffEventOnBeHitAfterOnly => "BuffEventOnBeHitAfterOnly",
            Self::BuffEventOnHitAfterOnly => "BuffEventOnHitAfterOnly",
            Self::BuffEventOnBeHealAfterOnly => "BuffEventOnBeHealAfterOnly",
            Self::BuffEventOnHealAfterOnly => "BuffEventOnHealAfterOnly",
            Self::BuffEventHealCalcAttrBefore => "BuffEventHealCalcAttrBefore",
            Self::BuffEventProduceHealCalcAttrBefore => {
                "BuffEventProduceHealCalcAttrBefore"
            }
            Self::BuffEventReviveSuccessEnd => "BuffEventReviveSuccessEnd",
            Self::BuffEventAfterReviveFirstMove => "BuffEventAfterReviveFirstMove",
            Self::BuffEventMonsterIntoAlert => "BuffEventMonsterIntoAlert",
            Self::BuffEventMonsterOutAlert => "BuffEventMonsterOutAlert",
            Self::BuffEventOnAddShieldCalcBefore => "BuffEventOnAddShieldCalcBefore",
            Self::BuffEventOnAddShieldBefore => "BuffEventOnAddShieldBefore",
            Self::BuffEventOnAddShieldAfter => "BuffEventOnAddShieldAfter",
            Self::BuffEventOnBeAddedShieldCalcBefore => {
                "BuffEventOnBeAddedShieldCalcBefore"
            }
            Self::BuffEventOnBeAddedShieldBefore => "BuffEventOnBeAddedShieldBefore",
            Self::BuffEventOnBeAddedShieldAfter => "BuffEventOnBeAddedShieldAfter",
            Self::BuffEventProgressWatcher => "BuffEventProgressWatcher",
            Self::BuffEventOnLuckyDamage => "BuffEventOnLuckyDamage",
            Self::BuffEventSkillCdEnd => "BuffEventSkillCDEnd",
            Self::BuffEventMotionless => "BuffEventMotionless",
            Self::BuffEventParticipateKill => "BuffEventParticipateKill",
            Self::BuffEventProfessionBdTypeChange => "BuffEventProfessionBDTypeChange",
            Self::BuffEventSingingBegin => "BuffEventSingingBegin",
            Self::BuffEventGuideBegin => "BuffEventGuideBegin",
            Self::BuffEventRandTimer => "BuffEventRandTimer",
            Self::BuffEventIntoFractureState => "BuffEventIntoFractureState",
            Self::BuffEventTakeOnRide => "BuffEventTakeOnRide",
            Self::BuffEventTakeOffRide => "BuffEventTakeOffRide",
            Self::BuffEventStartJump => "BuffEventStartJump",
            Self::BuffEventPlayAction => "BuffEventPlayAction",
            Self::BuffEventPlayEmote => "BuffEventPlayEmote",
            Self::BuffEventCheck => "BuffEventCheck",
            Self::BuffEventCustomize => "BuffEventCustomize",
            Self::BuffEventShapeshiftEndEvent => "BuffEventShapeshiftEndEvent",
            Self::BuffEventAttrRefresh => "BuffEventAttrRefresh",
            Self::BuffEventMonitorTeamKillActor => "BuffEventMonitorTeamKillActor",
            Self::BuffEventSpecialEffects => "BuffEventSpecialEffects",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BuffEventUnknown" => Some(Self::BuffEventUnknown),
            "BuffEventAddTo" => Some(Self::BuffEventAddTo),
            "BuffEventRemove" => Some(Self::BuffEventRemove),
            "BuffEventReplace" => Some(Self::BuffEventReplace),
            "BuffEventTimer" => Some(Self::BuffEventTimer),
            "BuffEventStackLayer" => Some(Self::BuffEventStackLayer),
            "BuffEventRemoveLayer" => Some(Self::BuffEventRemoveLayer),
            "BuffEventOnHitTargetBefore" => Some(Self::BuffEventOnHitTargetBefore),
            "BuffEventOnHitTargetAfter" => Some(Self::BuffEventOnHitTargetAfter),
            "BuffEventOnHittedBefore" => Some(Self::BuffEventOnHittedBefore),
            "BuffEventOnHittedAfter" => Some(Self::BuffEventOnHittedAfter),
            "BuffEventOnReachMaxLayer" => Some(Self::BuffEventOnReachMaxLayer),
            "BuffEventHostDeath" => Some(Self::BuffEventHostDeath),
            "BuffEventOnSkillHitAfter" => Some(Self::BuffEventOnSkillHitAfter),
            "BuffEventTrigTimingAura" => Some(Self::BuffEventTrigTimingAura),
            "BuffEventBodyPartDead" => Some(Self::BuffEventBodyPartDead),
            "BuffEventBodyPartHit" => Some(Self::BuffEventBodyPartHit),
            "BuffEventBodyPartStateChange" => Some(Self::BuffEventBodyPartStateChange),
            "BuffEventOnPartHittedBefore" => Some(Self::BuffEventOnPartHittedBefore),
            "BuffEventOnPartHittedAfter" => Some(Self::BuffEventOnPartHittedAfter),
            "BuffEventGravitational" => Some(Self::BuffEventGravitational),
            "BuffEventFightResChange" => Some(Self::BuffEventFightResChange),
            "BuffEventOnKillActor" => Some(Self::BuffEventOnKillActor),
            "BuffEventAttrWatcher" => Some(Self::BuffEventAttrWatcher),
            "BuffEventOnHittedLHBefore" => Some(Self::BuffEventOnHittedLhBefore),
            "BuffEventOnBeHittedLHBefore" => Some(Self::BuffEventOnBeHittedLhBefore),
            "BuffEventAddByTarget" => Some(Self::BuffEventAddByTarget),
            "BuffEventRemoveByTarget" => Some(Self::BuffEventRemoveByTarget),
            "BuffEventInCombatState" => Some(Self::BuffEventInCombatState),
            "BuffEventOutCombatState" => Some(Self::BuffEventOutCombatState),
            "BuffEventSkillBegin" => Some(Self::BuffEventSkillBegin),
            "BuffEventSkillEnd" => Some(Self::BuffEventSkillEnd),
            "BuffEventSingingEnd" => Some(Self::BuffEventSingingEnd),
            "BuffEventSummonBuffAdd" => Some(Self::BuffEventSummonBuffAdd),
            "BuffEventSummonEntity" => Some(Self::BuffEventSummonEntity),
            "BuffEventGuideEnd" => Some(Self::BuffEventGuideEnd),
            "BuffEventOnDelayHit" => Some(Self::BuffEventOnDelayHit),
            "BuffEventTeamBuffAdd" => Some(Self::BuffEventTeamBuffAdd),
            "BuffEventChangeProfession" => Some(Self::BuffEventChangeProfession),
            "BuffEventDodgeSuccess" => Some(Self::BuffEventDodgeSuccess),
            "BuffEventHealBefore" => Some(Self::BuffEventHealBefore),
            "BuffEventHealAfter" => Some(Self::BuffEventHealAfter),
            "BuffEventProduceHealBefore" => Some(Self::BuffEventProduceHealBefore),
            "BuffEventProduceHealAfter" => Some(Self::BuffEventProduceHealAfter),
            "BuffEventShieldBroken" => Some(Self::BuffEventShieldBroken),
            "BuffEventLinkingStart" => Some(Self::BuffEventLinkingStart),
            "BuffEventLinkingEnd" => Some(Self::BuffEventLinkingEnd),
            "BuffEventLinkingWatcher" => Some(Self::BuffEventLinkingWatcher),
            "BuffEventSuperArmorBroken" => Some(Self::BuffEventSuperArmorBroken),
            "BuffEventAddedByTargetTag" => Some(Self::BuffEventAddedByTargetTag),
            "BuffEventAddToTargetTag" => Some(Self::BuffEventAddToTargetTag),
            "BuffEventOnBeHitLessenHp" => Some(Self::BuffEventOnBeHitLessenHp),
            "BuffEventEnterBreaking" => Some(Self::BuffEventEnterBreaking),
            "BuffEventTeleportBelt" => Some(Self::BuffEventTeleportBelt),
            "BuffEventOnBeHitAfterOnly" => Some(Self::BuffEventOnBeHitAfterOnly),
            "BuffEventOnHitAfterOnly" => Some(Self::BuffEventOnHitAfterOnly),
            "BuffEventOnBeHealAfterOnly" => Some(Self::BuffEventOnBeHealAfterOnly),
            "BuffEventOnHealAfterOnly" => Some(Self::BuffEventOnHealAfterOnly),
            "BuffEventHealCalcAttrBefore" => Some(Self::BuffEventHealCalcAttrBefore),
            "BuffEventProduceHealCalcAttrBefore" => {
                Some(Self::BuffEventProduceHealCalcAttrBefore)
            }
            "BuffEventReviveSuccessEnd" => Some(Self::BuffEventReviveSuccessEnd),
            "BuffEventAfterReviveFirstMove" => Some(Self::BuffEventAfterReviveFirstMove),
            "BuffEventMonsterIntoAlert" => Some(Self::BuffEventMonsterIntoAlert),
            "BuffEventMonsterOutAlert" => Some(Self::BuffEventMonsterOutAlert),
            "BuffEventOnAddShieldCalcBefore" => {
                Some(Self::BuffEventOnAddShieldCalcBefore)
            }
            "BuffEventOnAddShieldBefore" => Some(Self::BuffEventOnAddShieldBefore),
            "BuffEventOnAddShieldAfter" => Some(Self::BuffEventOnAddShieldAfter),
            "BuffEventOnBeAddedShieldCalcBefore" => {
                Some(Self::BuffEventOnBeAddedShieldCalcBefore)
            }
            "BuffEventOnBeAddedShieldBefore" => {
                Some(Self::BuffEventOnBeAddedShieldBefore)
            }
            "BuffEventOnBeAddedShieldAfter" => Some(Self::BuffEventOnBeAddedShieldAfter),
            "BuffEventProgressWatcher" => Some(Self::BuffEventProgressWatcher),
            "BuffEventOnLuckyDamage" => Some(Self::BuffEventOnLuckyDamage),
            "BuffEventSkillCDEnd" => Some(Self::BuffEventSkillCdEnd),
            "BuffEventMotionless" => Some(Self::BuffEventMotionless),
            "BuffEventParticipateKill" => Some(Self::BuffEventParticipateKill),
            "BuffEventProfessionBDTypeChange" => {
                Some(Self::BuffEventProfessionBdTypeChange)
            }
            "BuffEventSingingBegin" => Some(Self::BuffEventSingingBegin),
            "BuffEventGuideBegin" => Some(Self::BuffEventGuideBegin),
            "BuffEventRandTimer" => Some(Self::BuffEventRandTimer),
            "BuffEventIntoFractureState" => Some(Self::BuffEventIntoFractureState),
            "BuffEventTakeOnRide" => Some(Self::BuffEventTakeOnRide),
            "BuffEventTakeOffRide" => Some(Self::BuffEventTakeOffRide),
            "BuffEventStartJump" => Some(Self::BuffEventStartJump),
            "BuffEventPlayAction" => Some(Self::BuffEventPlayAction),
            "BuffEventPlayEmote" => Some(Self::BuffEventPlayEmote),
            "BuffEventCheck" => Some(Self::BuffEventCheck),
            "BuffEventCustomize" => Some(Self::BuffEventCustomize),
            "BuffEventShapeshiftEndEvent" => Some(Self::BuffEventShapeshiftEndEvent),
            "BuffEventAttrRefresh" => Some(Self::BuffEventAttrRefresh),
            "BuffEventMonitorTeamKillActor" => Some(Self::BuffEventMonitorTeamKillActor),
            "BuffEventSpecialEffects" => Some(Self::BuffEventSpecialEffects),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ESkillCdType {
    ESkillCdNormal = 0,
    ESkillCdCharge = 1,
}
impl ESkillCdType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ESkillCdNormal => "ESkillCDNormal",
            Self::ESkillCdCharge => "ESkillCDCharge",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ESkillCDNormal" => Some(Self::ESkillCdNormal),
            "ESkillCDCharge" => Some(Self::ESkillCdCharge),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EBodySize {
    BodySizeNull = 0,
    BodySizeS = 1,
    BodySizeM = 2,
    BodySizeL = 3,
}
impl EBodySize {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BodySizeNull => "BodySizeNull",
            Self::BodySizeS => "BodySizeS",
            Self::BodySizeM => "BodySizeM",
            Self::BodySizeL => "BodySizeL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BodySizeNull" => Some(Self::BodySizeNull),
            "BodySizeS" => Some(Self::BodySizeS),
            "BodySizeM" => Some(Self::BodySizeM),
            "BodySizeL" => Some(Self::BodySizeL),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EMoveType {
    MoveIdle = 0,
    MoveWalk = 1,
    MoveRun = 2,
    MoveDash = 3,
    MoveDashEnd = 4,
    MoveAlert = 5,
    MoveFly = 6,
    MovePatrol = 7,
    MovePatrolRun = 8,
    MoveFlyDash = 9,
    MoveCustom = 10,
    MoveParkourRun = 11,
    MoveSelfPhoto = 12,
    MoveRotate = 13,
    MoveDashTurn = 14,
    MoveWalkEnd = 15,
    MoveRunEnd = 16,
    MoveWalkEndToIdle = 17,
    MoveRunEndToIdle = 18,
    MoveEightDir = 19,
    MoveByForce = 20,
    MoveSitRotate = 21,
    MoveJumpEndToIdle = 22,
}
impl EMoveType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MoveIdle => "MoveIdle",
            Self::MoveWalk => "MoveWalk",
            Self::MoveRun => "MoveRun",
            Self::MoveDash => "MoveDash",
            Self::MoveDashEnd => "MoveDashEnd",
            Self::MoveAlert => "MoveAlert",
            Self::MoveFly => "MoveFly",
            Self::MovePatrol => "MovePatrol",
            Self::MovePatrolRun => "MovePatrolRun",
            Self::MoveFlyDash => "MoveFlyDash",
            Self::MoveCustom => "MoveCustom",
            Self::MoveParkourRun => "MoveParkourRun",
            Self::MoveSelfPhoto => "MoveSelfPhoto",
            Self::MoveRotate => "MoveRotate",
            Self::MoveDashTurn => "MoveDashTurn",
            Self::MoveWalkEnd => "MoveWalkEnd",
            Self::MoveRunEnd => "MoveRunEnd",
            Self::MoveWalkEndToIdle => "MoveWalkEndToIdle",
            Self::MoveRunEndToIdle => "MoveRunEndToIdle",
            Self::MoveEightDir => "MoveEightDir",
            Self::MoveByForce => "MoveByForce",
            Self::MoveSitRotate => "MoveSitRotate",
            Self::MoveJumpEndToIdle => "MoveJumpEndToIdle",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MoveIdle" => Some(Self::MoveIdle),
            "MoveWalk" => Some(Self::MoveWalk),
            "MoveRun" => Some(Self::MoveRun),
            "MoveDash" => Some(Self::MoveDash),
            "MoveDashEnd" => Some(Self::MoveDashEnd),
            "MoveAlert" => Some(Self::MoveAlert),
            "MoveFly" => Some(Self::MoveFly),
            "MovePatrol" => Some(Self::MovePatrol),
            "MovePatrolRun" => Some(Self::MovePatrolRun),
            "MoveFlyDash" => Some(Self::MoveFlyDash),
            "MoveCustom" => Some(Self::MoveCustom),
            "MoveParkourRun" => Some(Self::MoveParkourRun),
            "MoveSelfPhoto" => Some(Self::MoveSelfPhoto),
            "MoveRotate" => Some(Self::MoveRotate),
            "MoveDashTurn" => Some(Self::MoveDashTurn),
            "MoveWalkEnd" => Some(Self::MoveWalkEnd),
            "MoveRunEnd" => Some(Self::MoveRunEnd),
            "MoveWalkEndToIdle" => Some(Self::MoveWalkEndToIdle),
            "MoveRunEndToIdle" => Some(Self::MoveRunEndToIdle),
            "MoveEightDir" => Some(Self::MoveEightDir),
            "MoveByForce" => Some(Self::MoveByForce),
            "MoveSitRotate" => Some(Self::MoveSitRotate),
            "MoveJumpEndToIdle" => Some(Self::MoveJumpEndToIdle),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CameraPatternType {
    Default = 0,
    SelfPhoto = 1,
    Ar = 2,
}
impl CameraPatternType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "Default",
            Self::SelfPhoto => "SelfPhoto",
            Self::Ar => "AR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Default" => Some(Self::Default),
            "SelfPhoto" => Some(Self::SelfPhoto),
            "AR" => Some(Self::Ar),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CameraSchemeType {
    DefaultScheme = 0,
    CustomScheme = 1,
}
impl CameraSchemeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DefaultScheme => "DefaultScheme",
            Self::CustomScheme => "CustomScheme",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DefaultScheme" => Some(Self::DefaultScheme),
            "CustomScheme" => Some(Self::CustomScheme),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EGender {
    GenderNull = 0,
    GenderMale = 1,
    GenderFemale = 2,
}
impl EGender {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GenderNull => "GenderNull",
            Self::GenderMale => "GenderMale",
            Self::GenderFemale => "GenderFemale",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GenderNull" => Some(Self::GenderNull),
            "GenderMale" => Some(Self::GenderMale),
            "GenderFemale" => Some(Self::GenderFemale),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EErrorCode {
    ErrSuccess = 0,
    ErrNoRecord = 101,
    ErrExceptionCancel = 102,
    ErrDbException = 103,
    ErrDbSeqException = 104,
    ErrDbSceneException = 105,
    ErrDbTokenException = 106,
    ErrCancelled = 201,
    ErrUnknownRpc = 202,
    ErrInvalidArgument = 203,
    ErrDeadlineExceeded = 204,
    ErrNotFound = 205,
    ErrAlreadyExists = 206,
    ErrPermissionDenied = 207,
    ErrResourceExhausted = 208,
    ErrFailedPrecondition = 209,
    ErrAborted = 210,
    ErrOutOfRange = 211,
    ErrUnimplemented = 212,
    ErrInternal = 213,
    ErrUnavailable = 214,
    ErrDataLoss = 215,
    ErrUnauthenticated = 216,
    ErrSystemMax = 999,
    ErrDbError = 1000,
    ErrCreateOpenInfo = 1001,
    ErrCreateAccountInfo = 1002,
    ErrCreateCharInfo = 1003,
    ErrCreateAccountToken = 1004,
    ErrGetOpenInfo = 1005,
    ErrGetAccountInfo = 1006,
    ErrGetCharInfo = 1007,
    ErrGetAccountToken = 1008,
    ErrLoginInQueue = 1009,
    ErrOtherLogin = 1010,
    ErrServerError = 1011,
    ErrNoAccountInfo = 1012,
    ErrNoCharInfo = 1013,
    ErrTokenExpired = 1014,
    ErrUpdateTokenFail = 1015,
    ErrRegIntoSceneError = 1016,
    ErrLoginTypeErr = 1017,
    ErrChangeMapErr = 1018,
    ErrLoginPlatformErr = 1019,
    ErrVersionErr = 1020,
    ErrDelayOffLineKickOff = 1021,
    ErrServiceLanguageError = 1022,
    NoEnterScene = 1023,
    ModIdNotOpen = 1024,
    ErrFaceData = 1025,
    ErrInitProfession = 1026,
    ErrSceneCloseKickoff = 1027,
    ErrLoginReconnectKick = 1028,
    ErrLoginErrorResume = 1029,
    ErrRepeatedLogin = 1030,
    ErrRestrictLogin = 1031,
    ErrRestrictBlack = 1032,
    ErrSdkVerifyFail = 1033,
    ErrSdkTokenExpired = 1034,
    ErrServerNotOpen = 1035,
    ErrServerEndOpen = 1036,
    ErrNormalKick = 1037,
    ErrServerBusy = 1038,
    ErrServerClose = 1039,
    ErrExitGame = 1040,
    ErrHopeKick = 1041,
    ErrClientVersionError = 1042,
    ErrInvalidDeviceId = 1043,
    ErrInvalidSystemType = 1044,
    ErrDeleteChar = 1045,
    ErrCancelDeleteChar = 1046,
    ErrCancelDeleteCharIsDelete = 1047,
    ErrIntoSceneOwnerFail = 1048,
    ErrSceneQueueUp = 1050,
    ErrProtocolVersionErr = 1051,
    ErrConfigVersionErr = 1052,
    ErrStateEventFailed = 1053,
    ErrSelectCharDoing = 1054,
    ErrSelectCharDeleted = 1055,
    ErrLoginChannelMax = 1056,
    ErrDeleteAccountKick = 1057,
    ErrIsDeleteAccount = 1058,
    ErrIsVersionKick = 1059,
    ErrNotQqChnnel = 1060,
    ErrIncorrectLaunchPlatform = 1061,
    ErrConditionWrong = 1062,
    ErrNotSupportLoginType = 1063,
    ErrSceneNotExist = 2001,
    ErrUserNotExist = 2002,
    ErrComponentNotExist = 2003,
    ErrSceneConfigNotExist = 2004,
    ErrServiceNotExist = 2005,
    ErrDataContainerNotExist = 2006,
    ErrAsynchronousReturn = 2007,
    ErrConfigNotExist = 2008,
    ErrNotUser = 2009,
    ErrConfigError = 2010,
    ErrActorNotExist = 2011,
    ErrCutSceneAlreadyPlayed = 2012,
    ErrFunctionUnlock = 2020,
    ErrFunctionClosed = 2021,
    ErrUserPlayerNotFurniturePackage = 2022,
    ErrSysInnerError = 2200,
    ErrSysWebClientNull = 2201,
    ErrSysWebRequestTimeOut = 2202,
    ErrSysWebReturnError = 2203,
    ErrRequestTooFrequently = 2204,
    ErrArgStringTooLong = 2251,
    ErrArgStringEmpty = 2252,
    ErrArgArrayTooBig = 2253,
    ErrArgArrayEmpty = 2254,
    ErrArgMapTooBig = 2255,
    ErrArgMapEmpty = 2256,
    ErrItemNotExist = 2300,
    ErrPackageNotExist = 2301,
    ErrPackageFull = 2302,
    ErrItemExpireTime = 2303,
    ErrItemPackageGridNotEnough = 2304,
    ErrItemUuidError = 2305,
    ErrItemNotEnough = 2306,
    ErrOptTypeError = 2307,
    ErrItemInCoolDown = 2308,
    ErrItemNotUse = 2309,
    ErrItemEffectTypeError = 2310,
    ErrItemParamError = 2311,
    ErrItemAddBuffError = 2312,
    ErrItemAdd = 2313,
    ErrUseItemState = 2314,
    ErrBatchUse = 2315,
    ErrFullSendMail = 2316,
    ErrItemNumZero = 2317,
    ErrItemSelectAwardIllegalNum = 2318,
    ErrItemSelectAwardIllegalPos = 2319,
    ErrItemSelectLimit = 2320,
    ErrItemPeriodGainExceeded = 2321,
    ErrItemNoRecycle = 2322,
    ErrItemRecycleBeyondMaxGrid = 2323,
    ErrItemRecycleBeyondMaxNum = 2324,
    ErrItemRecycleIdNoMatchItemId = 2325,
    ErrItemRecycleIllegalId = 2326,
    ErrItemLimitCount = 2327,
    ErrItemFriendPontExceeded = 2328,
    ErrItemToySingleEntUseExceeded = 2329,
    ErrItemToySceneUseExceeded = 2330,
    ErrItemToyUseInDisableArea = 2331,
    ErrItemToySingleCellUseExceeded = 2332,
    ErrMonthlyCardNotExists = 2380,
    ErrMonthlyCardDataError = 2381,
    ErrMonthlyCardDayAwardReceived = 2382,
    ErrMonthlyCardLimitCount = 2383,
    ErrCommunityNoHome = 2400,
    ErrNotHouseOwner = 2401,
    ErrHomeLandExisted = 2402,
    ErrHomeLandContentWrongful = 2403,
    ErrHouseLivetogetherCd = 2404,
    ErrHomeLandNotExisted = 2405,
    ErrHomeLandNotInScene = 2406,
    ErrHomeLandIsInvitation = 2407,
    ErrHomeLandInsufficientAuthority = 2408,
    ErrHomeLandTransferRequestPending = 2409,
    ErrHomeLandTransferRequestTimeout = 2410,
    ErrHomeLandTransferCd = 2411,
    ErrHomelandTargetIsHasHome = 2412,
    ErrHomelandTargetIsOwner = 2413,
    ErrHomelandNotOwnerCannotOperate = 2414,
    ErrHomeLandHasHouse = 2415,
    ErrHomeLandContentTooLong = 2416,
    ErrHomeLandClutterNotExist = 2417,
    ErrHouseNameOrStatementCd = 2418,
    ErrHouseIntroductionStatementCd = 2419,
    ErrCommunityBuildInvalidRecipeId = 2420,
    ErrCommunityBuildRecipeIsUnlock = 2421,
    ErrCommunityBuildMax = 2422,
    ErrCommunityBuildNoAuthority = 2423,
    ErrCommunityNotBuildCannotCancel = 2424,
    ErrCommunityBuildNotSelfCannotCancel = 2425,
    ErrCommunityNotBuildCannotAccelerate = 2426,
    ErrCommunityBuildNotSelfCannotAccelerate = 2427,
    ErrCommunityBuildCannotAccelerate = 2428,
    ErrCommunityBuildAlreadyAccelerate = 2429,
    ErrCommunityBuildInDungeon = 2430,
    ErrCommunityBuildRecipeIsLock = 2431,
    ErrCommunityBuildRecipeNotItemUnlock = 2432,
    ErrCommunityBuildInvalidCount = 2433,
    ErrCommunityNotBuildCannotReceive = 2434,
    ErrCommunityCanNotBuild = 2435,
    ErrHomeLandCohabitantLimit = 2436,
    ErrHomeLandRootNotQuitCohabitant = 2437,
    ErrHomeLandNotOwnerCannotQuitCohabitant = 2438,
    ErrHomeLandCohabitantIsExiting = 2439,
    ErrHomeLandCohabitantNotExists = 2440,
    ErrHomeLandCohabitantExitRequestExists = 2441,
    ErrHomeLandCohabitantDismiss = 2442,
    ErrHomeLandNotInvitation = 2443,
    ErrHomeLandCohabitantInvitationTimeout = 2444,
    ErrHomeLandCohabitantNotFriend = 2445,
    ErrHomeLandCohabitantFriendLevel = 2446,
    ErrHomeLandCohabitantLevel = 2447,
    ErrHomeLandInviteCohabitantNotOwner = 2448,
    ErrCommunityWarehouseGridFull = 2451,
    ErrCommunityWarehouseNoAuthority = 2452,
    ErrCommunityWarehouseGridPosItemNoEnough = 2453,
    ErrHomeLandInsufficientFurniture = 2454,
    ErrCommunityWarehouseTakeOutCountLimit = 2455,
    ErrHomeLandTaskNotExist = 2456,
    ErrHomeLandTaskTimeNotEnough = 2457,
    ErrHomeLandTaskAlreadyFinished = 2458,
    ErrHomeLandTaskItemNotEnough = 2459,
    ErrHomeLandCurLevelError = 2461,
    ErrHomeLandExpNotEnough = 2462,
    ErrHomeLandAlreadyMaxLevel = 2463,
    ErrHomeLandLevelLocked = 2464,
    ErrHomeLandLevelConfigError = 2465,
    ErrCommunityEditorNotEditable = 2466,
    ErrCommunityEditorNotFurniture = 2467,
    ErrCommunityEditorNotOutdoor = 2468,
    ErrCommunityEditorNotIndoor = 2469,
    ErrCommunityEditorOverMax = 2470,
    ErrCommunityEditorOverTypeMax = 2471,
    ErrCommunityEditorFurnitureNotEnough = 2472,
    ErrCommunityEditorFurnitureNotExist = 2473,
    ErrCommunityEditorOverMaxGroup = 2474,
    ErrCommunityEditorNoStructure = 2475,
    ErrCommunityEditorGroupMaxStructure = 2476,
    ErrCommunityEditorStructureInGroup = 2477,
    ErrCommunityEditorGroupNotExist = 2478,
    ErrCommunityEditorAlreadyExist = 2479,
    ErrHomeLandSellItemNotExist = 2481,
    ErrHomeLandLeftNumNotEnough = 2482,
    ErrHomeLandSellShopLocked = 2483,
    ErrHomeLandSeedExist = 2486,
    ErrHomeLandItemNotOwner = 2487,
    ErrHomeLandSeedStateError = 2488,
    ErrHomeLandNoSeed = 2489,
    ErrHomeLandNoWater = 2490,
    ErrHomeLandFertilizerMaxNumLimit = 2491,
    ErrHomeLandNotFertilize = 2492,
    ErrHomeLandNotPollen = 2493,
    ErrHomeLandAlreadyPollen = 2494,
    ErrHomeLandNotHarvest = 2495,
    ErrHomeLandPickUpSinglePlayerLimit = 2496,
    ErrHomeLandPickUpTotalLimit = 2497,
    ErrHomeLandPickUpFlowerNotFinished = 2498,
    ErrHomeLandPickUpOwner = 2499,
    ErrHomeLandGainNotOwner = 2500,
    ErrHomeLandItemFullGrid = 2501,
    ErrHomeLandFurnitureFull = 2502,
    ErrComposeItemNotEnough = 2571,
    ErrComposeFailed = 2572,
    ErrRedemptionItemNotExist = 2573,
    ErrRedemptionItemMaxCount = 2574,
    ErrRedemptionItemNotEnough = 2575,
    ErrRedemptionItemGender = 2576,
    ErrAwardConfigNotFound = 2600,
    ErrAwardConfigWeightError = 2601,
    ErrAwardConfigLimitAndContentNotMatch = 2602,
    ErrAwardConfigContentSizeError = 2603,
    ErrAwardConfigContentRatesSizeError = 2604,
    ErrAwardConfigContentWeightSizeError = 2605,
    ErrAwardConfigGroupContentEmpty = 2606,
    ErrAwardConfigGroupNumEmpty = 2607,
    ErrAwardConfigGroupContentNoMatchGroupNum = 2608,
    ErrAwardConfigNoRandomDrop = 2609,
    ErrAwardConfigNoSelectAward = 2610,
    ErrAwardConfigSelfSelectContentNoItem = 2611,
    ErrAwardConfigWeightRateMustOne = 2612,
    ErrAwardConfigGroupContentRandomNoMatch = 2613,
    ErrAwardConfigGroupContentError = 2614,
    ErrAwardConfigPackageContentRandomNoMatch = 2615,
    ErrAwardConfigLevelUpPackConfigPackageNoMatch = 2616,
    ErrAwardConfigProItemRuleNoMatch = 2617,
    ErrAwardConfigPackageContentEmpty = 2618,
    ErrAwardConfigDropContentSize = 2619,
    ErrAwardConfigDropContentNum = 2620,
    ErrAwardConfigGroupRateEmpty = 2621,
    ErrAwardConfigGroupWeightEmpty = 2622,
    ErrAwardInnerError = 2623,
    ErrAwardIllegalRandomType = 2624,
    ErrAwardConditionNoMeet = 2625,
    ErrAwardRandomTypeNone = 2626,
    ErrAwardRandomTypeNoMatch = 2627,
    ErrAwardActorIsNull = 2628,
    ErrEquipWashAttrNotExist = 2700,
    ErrNotEquipInCombat = 2701,
    ErrEquipPart = 2702,
    ErrComposeItemNotExist = 2750,
    ErrPickupDropItemDistance = 2800,
    ErrPickupDropItemPackageFull = 2801,
    ErrPickupDropItemNoAuthority = 2802,
    ErrLayerActorExist = 2851,
    ErrTeamCreateHas = 2900,
    ErrTeamIllTarget = 2901,
    ErrTeamCreateTryLater = 2902,
    ErrTeamGetNo = 2903,
    ErrTeamListEmpty = 2904,
    ErrTeamInner = 2905,
    ErrTeamNoLeader = 2906,
    ErrTeamInMatch = 2907,
    ErrTeamCustomizeTarget = 2908,
    ErrTeamNoOwn = 2909,
    ErrTeamTickSelf = 2910,
    ErrTeamNoMem = 2911,
    ErrTeamApplyingLeader = 2912,
    ErrTeamHasBeLeader = 2913,
    ErrTeamNoTransferSelf = 2914,
    ErrTeamNoLeaderTransfer = 2915,
    ErrTeamHasOwnTeam = 2916,
    ErrTeamNoExist = 2917,
    ErrTeamApplyInCd = 2918,
    ErrTeamApplyExpire = 2919,
    ErrTeamJoinOther = 2920,
    ErrTeamMemMax = 2921,
    ErrTeamNoInvited = 2924,
    ErrTeamIsMatching = 2925,
    ErrTeamIllegalTag = 2926,
    ErrTeamNoMatching = 2927,
    ErrTeamIllegalActivity = 2928,
    ErrTeamInActivity = 2929,
    ErrTeamNoMeetCondition = 2930,
    ErrTeamWaitVoting = 2931,
    ErrTeamDoingActivity = 2932,
    ErrTeamNoInVoting = 2933,
    ErrTeamVoteEnd = 2934,
    ErrTeamHasVoted = 2935,
    ErrTeamInviteCd = 2936,
    ErrTeamApplyLeadCd = 2937,
    ErrTeamMoreMaxWorlds = 2938,
    ErrTeamValidApplyInfo = 2939,
    ErrTeamInMatchCancelCd = 2940,
    ErrTeamMatchFinished = 2941,
    ErrTeamMatchWaitSec = 2942,
    ErrTeamMemWorldFull = 2943,
    ErrTeamMemNotLeader = 2944,
    ErrTeamLeaderNotStaticScene = 2945,
    ErrTeamLeaderCallDoing = 2946,
    ErrTeamIllegalCallOperator = 2947,
    ErrTeamLeaderIllegalCallOperator = 2948,
    ErrTeamNoMemCall = 2949,
    ErrTeamLeaderCallEnd = 2950,
    ErrTeamSameScene = 2951,
    ErrTeamNotSameScene = 2952,
    ErrTeamMemTooMore = 2953,
    ErrTeamMemInDungeon = 2954,
    ErrTeamMemTooLess = 2955,
    ErrTeamIllegalInviteType = 2956,
    ErrTeamMemberNotInScene = 2957,
    ErrTeamLeaderReadyCheckTimeNotReady = 2958,
    ErrTeamExistDungeonCheck = 2959,
    ErrTeamTargetMatchTalentLimit = 2960,
    ErrTeamEditGroupNotAllowed = 2961,
    ErrTeamGroupNotExist = 2962,
    ErrTeamTargetNoMatchMemberType = 2963,
    ErrDecomposeItemNotExist = 3000,
    ErrDecomposeItemNotEnough = 3001,
    ErrRefineEnergyNotEnough = 3002,
    ErrRefineItemMaxCount = 3003,
    ErrRefineItemNotExist = 3004,
    ErrRefineItemColumnNotUnlock = 3005,
    ErrRefineItemColumnUnlock = 3006,
    ErrRefineItemExist = 3007,
    ErrEnergyLimitMax = 3008,
    ErrRefineItemColumnNotEmpty = 3009,
    ErrProfessionNotExist = 3056,
    ErrModSlotNotUnlock = 3058,
    ErrChangeProfessionStateFail = 3065,
    ErrChangeProfessionCdFail = 3066,
    ErrProfessionSkinNotActive = 3071,
    ErrProfessionSkinActive = 3072,
    ErrProfessionNotUseSkin = 3073,
    ErrProfessionSkillSkinActive = 3074,
    ErrProfessionSkillSkinNotActive = 3075,
    ErrProfessionSkillNotActive = 3076,
    ErrCharOffline = 3101,
    ErrUserDataBaseError = 3102,
    ErrCharGetFail = 3103,
    ErrAlreadyAlive = 3200,
    ErrReviveParam = 3201,
    ErrStateIllegal = 3202,
    ErrStateNoChange = 3203,
    ErrReviveConsumeNotEnough = 3204,
    ErrReviveByOtherForbid = 3205,
    ErrReviveTimeNotArrived = 3206,
    ErrReviveBossBattle = 3207,
    ErrReviveCountLimit = 3208,
    ErrReviveInDeadTp = 3209,
    ErrDungeonPlayTypeError = 3301,
    ErrDungeonNotExist = 3302,
    ErrDungeonCreateError = 3303,
    ErrCantChangeDungeon = 3304,
    ErrDungeonLock = 3305,
    ErrPioneerFail = 3306,
    ErrAwardFail = 3307,
    ErrGsNotEnough = 3308,
    ErrQuestNotCompleted = 3309,
    ErrDungeonNotClear = 3310,
    ErrConditionNotExist = 3311,
    ErrAwardReceived = 3312,
    ErrCantRepeatedPlay = 3313,
    ErrNeedPassPreRoom = 3314,
    ErrDungeonEnterCountLimit = 3315,
    ErrDungeonScoreError = 3316,
    ErrDungeonRepeatedVote = 3317,
    ErrDungeonChallengeAwardState = 3318,
    ErrDungeonChallengeAffixNotFound = 3319,
    ErrDungeonStateNotActive = 3320,
    ErrDungeonCantVoteSelf = 3321,
    ErrDungeonPlayerNotEnough = 3322,
    ErrDungeonPlayerFull = 3323,
    ErrDungeonCantHeroKey = 3324,
    ErrDungeonNotSettlement = 3325,
    ErrDungeonNotFindRollItem = 3326,
    ErrDungeonCantRoll = 3327,
    ErrDungeonRollFinish = 3328,
    ErrDungeonSelectError = 3329,
    ErrDungeonAiModeError = 3330,
    ErrDungeonTargetNotFinish = 3331,
    ErrDungeonTargetBeAward = 3332,
    ErrDungeonSinglePlayerMore = 3333,
    ErrDungeonAiGroupNotEnough = 3334,
    ErrDungeonNoPass = 3335,
    ErrDungeonCloseSceneId = 3336,
    ErrDungeonEnterTypeError = 3337,
    ErrDungeonActorCount = 3338,
    ErrDungeonDiffLocked = 3339,
    ErrDungeonPreBattleVoteCd = 3340,
    ErrDungeonBossInvalid = 3341,
    ErrDungeonNoUser = 3342,
    ErrDungeonUserInvalid = 3343,
    ErrDungeonAwardualification = 3344,
    ErrDungeonAwardTriesLimit = 3345,
    ErrFashionIsLimit = 3401,
    ErrFashionNotFound = 3402,
    ErrFashionSlotEmpty = 3403,
    ErrFashionIdNotFound = 3404,
    ErrFashionLock = 3405,
    ErrFashCollectionAwardAlread = 3406,
    ErrFashCollectionScoreNotEnough = 3407,
    ErrFashCollectionAwardAlreadMonth = 3408,
    ErrFashionAlreadUnlock = 3409,
    ErrFashionAdvanceNotExist = 3410,
    ErrFashionBaseNotUnlock = 3411,
    ErrFashionAdvanceAlreadyUnlock = 3412,
    ErrCameraNoExistAlbum = 3501,
    ErrCameraBeyondPhotoNum = 3502,
    ErrCameraBeyondAlumNum = 3503,
    ErrCameraNoAccessRight = 3504,
    ErrCameraNoExistPhoto = 3505,
    ErrCameraBeyondWordNum = 3506,
    ErrCameraPhotoNoInAlbum = 3507,
    ErrCameraInnerError = 3508,
    ErrCameraIllegalRight = 3509,
    ErrCameraNoExistChar = 3510,
    ErrCameraNoDelCloudAlbum = 3511,
    ErrCameraBeyondMaxURlLen = 3512,
    ErrCameraBeyondMaxXmlLen = 3513,
    ErrCameraBeyondMaxNameLen = 3514,
    ErrCameraIllegalUrl = 3515,
    ErrCameraRenderInfoEmpty = 3516,
    ErrCameraBeyondPhotoMaxSize = 3517,
    ErrCameraIllegalPictureType = 3518,
    ErrCameraTypeRepeated = 3519,
    ErrCameraWithoutOriginal = 3520,
    ErrCameraWithoutThumbnailOrRender = 3521,
    ErrCameraPhotoNameEmpty = 3522,
    ErrCameraPhotoNameOutMaxLen = 3523,
    ErrCameraAlbumNameEmpty = 3524,
    ErrCameraPhotoHasDel = 3525,
    ErrCameraSysInnerError = 3526,
    ErrCameraIllegalPictureId = 3527,
    ErrCameraBeyondMaxExtraLen = 3528,
    ErrCameraNoIncludeOriginal = 3529,
    ErrCameraNoDealingPhoto = 3530,
    ErrCameraNoDealingPhotoType = 3531,
    ErrCameraNoAnyAlbum = 3532,
    ErrCameraNoPassReview = 3533,
    ErrCameraPhotoMissImage = 3534,
    ErrCameraWithoutThumbnail = 3535,
    ErrCameraBeyondMaxUploadTimes = 3536,
    ErrInvalidLifeProfessionId = 3601,
    ErrLifeProfessionIsUnlock = 3602,
    ErrLifeProfessionMaxLevel = 3603,
    ErrLifeProfessionLevelNotEnough = 3604,
    ErrLifeProfessionLevelRewardGot = 3605,
    ErrInvalidLifeProfessionSpecializationId = 3606,
    ErrLifeProfessionSpecializationNotEnough = 3607,
    ErrLifeProfessionSpecializationUpgradeError = 3608,
    ErrLifeProfessionPointNotEnough = 3609,
    ErrInvalidLifeProfessionTargetId = 3610,
    ErrLifeProfessionTargetNotEnough = 3611,
    ErrLifeProfessionRewardCanNotGet = 3612,
    ErrLifeProfessionEnergyChange = 3613,
    ErrLifeProfessionRecipeIsUnlock = 3614,
    ErrLifeProfessionRecipeNotExist = 3615,
    ErrLifeProfessionRecipeNotUnlock = 3616,
    ErrLifeProfessionMaxRdRecipeCount = 3617,
    ErrLifeProfessionWorkingNotEnd = 3618,
    ErrLifeProfessionAlreadyWorking = 3619,
    ErrLifeProfessionNotWorking = 3620,
    ErrLifeProfessionWorkingIsEnd = 3621,
    ErrLifeProfessionUnActiveSpecialization = 3622,
    ErrCurLevelConfigNotExist = 4001,
    ErrNeedBreakthrough = 4002,
    ErrExperienceConfigNotExist = 4003,
    ErrExperienceMismatch = 4004,
    ErrNotNeedToBreakthrough = 4005,
    ErrConsumeConfigError = 4006,
    ErrSkillNotExist = 4007,
    ErrSkillLevelMax = 4008,
    ErrSkillLevelNotExist = 4009,
    ErrSkillConfigError = 4010,
    ErrStarNotExist = 4011,
    ErrMaxStar = 4012,
    ErrMaxLevel = 4013,
    ErrSkillLevelNotEnough = 4014,
    ErrCanNotChangeActionState = 4051,
    ErrActionNotExist = 4052,
    ErrIsInteracting = 4053,
    ErrState = 4054,
    ErrRequestExpired = 4055,
    ErrStateSetFailed = 4071,
    ErrCollectIdError = 4072,
    ErrCollectStateFailed = 4073,
    ErrCollectActorErr = 4074,
    ErrCollectOutRange = 4075,
    ErrCollectConditionEquip = 4076,
    ErrCollectConditionQuest = 4077,
    ErrAlreadyCollected = 4078,
    ErrMailGetFailed = 4101,
    ErrMailIllegality = 4102,
    ErrMailIsGet = 4103,
    ErrMailIsDel = 4104,
    ErrMailAcceptorEmpty = 4105,
    ErrMailTokenInvalid = 4106,
    ErrUnRegisterType = 4201,
    ErrIndexNotFound = 4202,
    ErrCantOpenTreasureBox = 4203,
    ErrPersonalStateEnd = 4204,
    ErrPersonalObjectStatus = 4205,
    ErrExp = 4301,
    ErrLevel = 4302,
    ErrAward = 4303,
    ErrReceivedLevelAward = 4304,
    ErrLevelNotEnough = 4305,
    ErrRoleLevelNoRewards = 4306,
    ErrUnionNotHaveLimit = 4401,
    ErrUnionIsNotMember = 4402,
    ErrUnionOfficialNotExits = 4403,
    ErrUnionOfficialTooMany = 4404,
    ErrUnionHas = 4405,
    ErrUnionReqCd = 4406,
    ErrUnionReqHas = 4407,
    ErrUnionFull = 4408,
    ErrUnionFailed = 4409,
    ErrUnionNameWrongful = 4410,
    ErrUnionNameUsed = 4411,
    ErrUnionNameOccupied = 4412,
    ErrApplyMax = 4415,
    ErrUnionChangeNameCd = 4416,
    ErrUnionNameSizeError = 4417,
    ErrDeclarationSize = 4418,
    ErrDeclarationError = 4419,
    ErrOfficialNameRepeat = 4420,
    ErrDeclarationCd = 4421,
    ErrUnionInfoCd = 4422,
    ErrUnionNotExist = 4423,
    ErrUnionIllegalConditionType = 4424,
    ErrUnionRecruitSloganTooLong = 4425,
    ErrUnionRecruitDescriptionTooLong = 4426,
    ErrUnionCreateTooOften = 4427,
    ErrUnionTagNoExist = 4428,
    ErrUnionIconTooMuch = 4429,
    ErrUnionGetListCd = 4430,
    ErrUnionBatchSearchUnionIdsTooMuch = 4431,
    ErrUnionBatchSearchCd = 4432,
    ErrUnionGetCollectedIdsCd = 4433,
    ErrUnionBeyondMaxCollectedNum = 4434,
    ErrUnionIdHasCollected = 4435,
    ErrUnionIdNoCollected = 4436,
    ErrUnionActiveValueNotEnough = 4437,
    ErrUnionIllegalActiveId = 4438,
    ErrUnionTooShortForAwards = 4439,
    ErrUnionHasActiveAwards = 4440,
    ErrUnionNoJoin = 4441,
    ErrUnionOnlyEnterSelf = 4442,
    ErrUnionNoUnlockScene = 4443,
    ErrUnionBuildingMaxLevel = 4444,
    ErrUnionBuildingUpgrading = 4445,
    ErrUnionBuildingUpgradeNoFinish = 4446,
    ErrUnionPrefixBuildNoMeet = 4447,
    ErrUnionExperienceNoEnough = 4448,
    ErrUnionMoneyNoEnough = 4449,
    ErrUnionBuildingNoUpgrading = 4450,
    ErrUnionSpeedUpItemNoEnough = 4451,
    ErrUnionSpeedUpTimesOut = 4452,
    ErrUnionTryLater = 4453,
    ErrUnionSpeedUpLevelError = 4454,
    ErrUnionUpgradeHasCompleted = 4455,
    ErrUnionIllegalBuildIdLv = 4456,
    ErrUnionBeyMaxCount = 4457,
    ErrUnionUserNoApply = 4458,
    ErrUnionNoOneKeyNoMuch = 4459,
    ErrUnionActivityNotStart = 4460,
    ErrUnionActivityNotProgress = 4461,
    ErrUnionActivityAwardGet = 4462,
    ErrUnionActivityNotEnjoy = 4463,
    ErrUnionCreateTimeTooShort = 4464,
    ErrUnionFunctionLock = 4465,
    ErrUnionEScreenLock = 4466,
    ErrUnionEScreenPositionLock = 4467,
    ErrUnionEScreenNoSet = 4468,
    ErrUnionEScreenPositionNoSet = 4469,
    ErrUnionEffectGridLock = 4470,
    ErrUnionEffectIdLock = 4471,
    ErrUnionEffectPosNoSet = 4472,
    ErrUnionEffectPosHasEnd = 4473,
    ErrUnionCrowFuncHasEnd = 4474,
    ErrUnionCrowFuncPosHasUsed = 4475,
    ErrUnionCrowFuncHasJoined = 4476,
    ErrUnionCrowFuncNoBegin = 4477,
    ErrUnionNoFinishBaseBuilding = 4478,
    ErrUnionCrowFuncIllegalFuncPos = 4479,
    ErrUnionEScreenBeyondMaxTimes = 4480,
    ErrUnionTargetFunctionLock = 4481,
    ErrUnionNoMeet = 4482,
    ErrUnionActivityAwardCd = 4483,
    ErrUnionManagerNoKicked = 4484,
    ErrUnionDanceNoBegin = 4485,
    ErrUnionDanceEnd = 4486,
    ErrUnionDanceDrawnBox = 4487,
    ErrUnionDanceBoxDrawn = 4488,
    ErrUnionDanceNoDanceId = 4489,
    ErrUnionNoJoinDance = 4490,
    ErrUnionDanceNoDancing = 4491,
    ErrUnionRejectInvite = 4492,
    ErrUnionActivityHuntEnd = 4493,
    ErrUnionApplyListFull = 4494,
    ErrUionApplyListExist = 4495,
    ErrUnionGroupIvalid = 4496,
    ErrRepeatedRequest = 4501,
    ErrHasBeenBlackened = 4502,
    ErrNotFoundCharInfo = 4503,
    ErrInner = 4504,
    ErrParam = 4505,
    ErrSetShowPicture = 4506,
    ErrSetSignature = 4507,
    ErrSetHobbyMark = 4508,
    ErrSetTimeMark = 4509,
    ErrSetRemind = 4510,
    ErrSetTop = 4511,
    ErrAddFriend = 4512,
    ErrSetProcessed = 4513,
    ErrSetRemark = 4514,
    ErrDeleteFriend = 4515,
    ErrNotFoundGroup = 4516,
    ErrNotExistInGroup = 4517,
    ErrChangeGroup = 4518,
    ErrPersonalState = 4519,
    ErrOtherFriendMax = 4520,
    ErrCurFriendMax = 4521,
    ErrConfig = 4522,
    ErrAlreadyFriend = 4523,
    ErrSearchSelf = 4524,
    ErrSuggestionCd = 4525,
    ErrGroupMax = 4526,
    ErrGroupNotExist = 4527,
    ErrGroupNameEmpty = 4528,
    ErrIllegalCharacter = 4529,
    ErrStringMax = 4530,
    ErrOtherApplicationMax = 4531,
    ErrFriendlinessAwardHasRecord = 4532,
    ErrFriendlinessLevelLowAwardLevel = 4533,
    ErrFriendBeyondAllFriendNum = 4534,
    ErrFriendIsNoUserFriend = 4535,
    ErrFriendlinessIllegalAwardLevel = 4536,
    ErrFriendlinessLevelAwardIsEmpty = 4537,
    ErrFriendBeBlackenedByTarget = 4538,
    ErrFriendApplyEachOther = 4539,
    ErrFriendCallBySmallerCharId = 4540,
    ErrFriendCallByBiggerCharId = 4541,
    ErrFriendBeBlackenedBySmaller = 4542,
    ErrFriendBeBlackenedByBigger = 4543,
    ErrFriendNoApply = 4544,
    ErrFriendApplySelf = 4545,
    ErrUserNameFormat = 4546,
    ErrFriendGetBaseTooOften = 4547,
    ErrFriendOnlyGetSelfBaseInfo = 4548,
    ErrActorGetFailed = 4601,
    ErrPivotIsActive = 4602,
    ErrPivotIsNotActive = 4603,
    ErrBreakPointIsGet = 4604,
    ErrActorIsNotPivot = 4605,
    ErrActorIsNotBreakPoint = 4606,
    ErrActorIsBreakPointNotFull = 4607,
    ErrPivotRewardIsGiven = 4608,
    ErrNotInsight = 4609,
    ErrLearnSkillFail = 4651,
    ErrRemoveSkillFail = 4652,
    ErrUpdateSkillFail = 4653,
    ErrSkillOperatorType = 4654,
    ErrContainerOperator = 4655,
    ErrExchangeFail = 4656,
    ErrExchangeFailInCombat = 4657,
    ErrAvatarBeyondMaxPictureSize = 4671,
    ErrGetTokenFailed = 4672,
    ErrPictureVerifyFailed = 4673,
    ErrPictureIllegalType = 4674,
    ErrPictureErrorInfo = 4675,
    ErrPictureSizeInconsistent = 4676,
    ErrPictureFuncTypeIllegal = 4677,
    ErrPictureCallBackJudgeIllegal = 4678,
    ErrPictureVerifyNoPass = 4679,
    ErrPictureVerifyBackParamIllegal = 4680,
    ErrPictureCallBackParamIllegal = 4681,
    ErrPictureIllegalId = 4682,
    ErrPictureCosErrors = 4683,
    ErrPictureInnerSysErr = 4684,
    ErrPictureNoSetEnvCosSecretId = 4685,
    ErrPictureNoSetEnvCosSecretKey = 4686,
    ErrPictureCheckInMachineLocked = 4687,
    ErrPictureNoTryOutItem = 4688,
    ErrPictureNoUploadItem = 4689,
    ErrPictureNoUnion = 4690,
    ErrNameSizeError = 4701,
    ErrSensitiveContent = 4702,
    ErrChangeNameFail = 4703,
    ErrChangeNameCardNotEnough = 4704,
    ErrChangeSameName = 4705,
    ErrCheckMuteWordsFailed = 4706,
    ErrCheckMuteWordsEmpty = 4708,
    ErrChangeShowIdFail = 4711,
    ErrChangeShowIdDuplicated = 4712,
    ErrChangeShowIdCardNotEnough = 4713,
    ErrFaceItemLock = 4721,
    ErrFaceItemGender = 4722,
    ErrFaceNoUploading = 4723,
    ErrFaceNoSupportFileSuffix = 4724,
    ErrFaceFileSuffixEmpty = 4725,
    ErrFaceIllegalCosKey = 4726,
    ErrFaceParseSuffixFailed = 4727,
    ErrFaceParseShortGuidFailed = 4728,
    ErrProficiencyNeedUnlock = 4751,
    ErrProficiencyUnlock = 4752,
    ErrUnlockItemNotEnough = 4753,
    ErrTaskNotFinish = 4771,
    ErrStickerAwardIsGet = 4772,
    ErrBookAwardIsGet = 4773,
    ErrInCd = 4791,
    ErrMoneyNotEnough = 4801,
    ErrShopItemCantBuy = 4802,
    ErrShopBuyBusy = 4803,
    ErrPaymentConfigNotFound = 4804,
    ErrRefreshShopCountExceed = 4806,
    ErrShopCouponNotEnough = 4807,
    ErrShopCouponLimitNum = 4808,
    ErrShopCantBuyNoPrice = 4809,
    ErrNotFoundMonster = 4901,
    ErrNotMonster = 4902,
    ErrMonsterUnlockExist = 4903,
    ErrMonsterAwardIsGet = 4904,
    ErrMonsterTargetNotFinish = 4905,
    ErrDropTypeNotSupport = 4906,
    ErrCounterNotEnough = 4907,
    ErrDropItemAlreadyPicked = 4908,
    ErrInteractionDoing = 4941,
    ErrInteractionCondition = 4942,
    ErrInteractionNotMore = 4943,
    ErrInteractionExistPos = 4944,
    ErrInteractionNotExist = 4945,
    ErrInteractionEntityNotExist = 4946,
    ErrInteractionHandleNotExist = 4947,
    ErrInteractionType = 4948,
    ErrInteractionBan = 4949,
    ErrInteractionConfig = 4950,
    ErrInteractionNotOneself = 4951,
    ErrInteractionDistance = 4952,
    ErrShowPieceIllegalPieceType = 4961,
    ErrShowPieceIllegalPieceId = 4962,
    ErrShowPieceNoInOftenUseList = 4963,
    ErrShowPieceNoUnlockList = 4964,
    ErrShowPieceRoulettePositionNoSet = 4965,
    ErrShowPieceBeyondOftenUseMaxLen = 4966,
    ErrShowPieceBeyondOftenRoulettePositionNum = 4967,
    ErrShowPieceNoCommonPiece = 4968,
    ErrShowPieceNoTakeOn = 4969,
    ErrProfessionActivated = 5001,
    ErrProfessionNotHas = 5002,
    ErrProfessionSlotErr = 5003,
    ErrProfessionRemoveErr = 5004,
    ErrProfessionChangePlanFail = 5005,
    ErrProfessionStarConfigNotExist = 5006,
    ErrProfessionStarNodeUnlock = 5007,
    ErrProfessionStarNodeNotUnlock = 5008,
    ErrProfessionReplaceSkillNotExist = 5009,
    ErrProfessionUpgradeNotGreaterCurLevel = 5010,
    ErrProfessionProfessionBeForged = 5011,
    ErrProfessionSlotTwoNotUnlock = 5012,
    ErrProfessionSkillAlreadyActive = 5013,
    ErrProfessionSkillRemodelLevelWrong = 5014,
    ErrAoyiSkillAlreadyActive = 5015,
    ErrAoyiSkillRemodelConfigNotExist = 5016,
    ErrAoyiSkillRemodelLevelWrong = 5017,
    ErrProfessionEquipInCombat = 5018,
    ErrProfessionSwitchInCombat = 5019,
    ErrProfessionDungeonNotAllowSwitch = 5020,
    ErrTalentIllegalTalentPoolId = 5101,
    ErrTalentBeyondCurTalentMaxPlanNum = 5102,
    ErrTalentPoolNoActive = 5108,
    ErrTalentPlanNoActive = 5109,
    ErrTalentIllegalTalentId = 5110,
    ErrTalentTalentHasUnlocked = 5111,
    ErrTalentTalentNoUnlocked = 5112,
    ErrTalentChangeLvPassiveTalentMoreThanInPool = 5113,
    ErrTalentRepeatedTalentId = 5114,
    ErrTalentNoPoolPassiveTalent = 5115,
    ErrTalentTalentPointsNoEnough = 5116,
    ErrTalentPassiveTalentListNoEmpty = 5118,
    ErrTalentIllegalTalentLevel = 5119,
    ErrTalentNoMeetUpgradeCondition = 5120,
    ErrTalentNoSupportDownLevelNow = 5121,
    ErrTalentNoMeetPrevTalentLv = 5122,
    ErrTalentNoMeetPrevTalentPoint = 5123,
    ErrTalentTreeNodeBdExclusive = 5124,
    ErrTalentTotalTalentPointNotEnough = 5125,
    ErrTalentPreTalentNodeNotActivated = 5126,
    ErrTalentResetTalentInCombat = 5127,
    ErrCookBookNotExist = 5151,
    ErrCookFoodNotEnough = 5152,
    ErrCookTypeMore = 5153,
    ErrCookCountMore = 5154,
    ErrCookHasBook = 5155,
    ErrCookMaterialNotMatch = 5156,
    ErrChatIllegalPrivateChatTarget = 5201,
    ErrChatInTargetBlockList = 5202,
    ErrChatSendMsgBeyondMaxWords = 5203,
    ErrChatWorldChannelIdIsZero = 5204,
    ErrChatWorldChannelIdBeyondMaxId = 5205,
    ErrChatIllegalChannelType = 5206,
    ErrChatIllegalMsgType = 5207,
    ErrChatNoInGoalChannel = 5208,
    ErrChatNeedConfigIdNotZero = 5209,
    ErrChatNeedMsgTextNotEmpty = 5210,
    ErrChatSendCdNoEnd = 5211,
    ErrChatRecordListIsEmpty = 5212,
    ErrChatTargetNotInPrivateList = 5213,
    ErrChatMsgIdMoreThanMaxReadMsgId = 5214,
    ErrChatBeyondBlockListLimit = 5215,
    ErrChatWorldChannelIdBeyondMaxNum = 5216,
    ErrChatBeyondMaxRecordId = 5217,
    ErrChatNoCreatePrivateSession = 5218,
    ErrChatPrivateSessionHasExit = 5219,
    ErrChatBeBan = 5220,
    ErrChatFileIdTooLong = 5221,
    ErrChatFileIdEmpty = 5222,
    ErrChatMsgInfoEmpty = 5223,
    ErrChatNoShareChannel = 5224,
    ErrChatIllegalShareType = 5225,
    ErrChatIllegalHolderType = 5226,
    ErrChatNoSupportShareType = 5227,
    ErrChatShareTpeNoChatId = 5228,
    ErrChatShareNoFishRank = 5229,
    ErrChatLevelLimit = 5230,
    ErrChatNoFoundBlockListLimit = 5231,
    ErrTalentModTalentTagNotExist = 5301,
    ErrTextCheckForbidden = 5351,
    ErrTextCheckNoSceneType = 5352,
    ErrTextCheckIllegal = 5353,
    ErrTextCheckHttpError = 5354,
    ErrTextCheckTooManyItems = 5355,
    ErrConditionTimerOpen = 5401,
    ErrConditionOpenServer = 5402,
    ErrSkillDisable = 5700,
    ErrSkillIsCd = 5701,
    ErrSkillMaxPassiveCount = 5702,
    ErrSkillInit = 5703,
    ErrSkillInfo = 5704,
    ErrUseSkillFightResInsufficient = 5705,
    ErrUseSkillBuffNotEnough = 5706,
    ErrUseSkillItemInsufficient = 5707,
    ErrUseSkillAttrInsufficient = 5708,
    ErrUseSkillEnduranceInsufficient = 5709,
    ErrUseSkillStateChange = 5710,
    ErrUseSkillClientSkillUuid = 5711,
    ErrFightLogicConditionBlockInvalid = 5730,
    ErrFightLogicActionGroupInvalid = 5731,
    ErrFightLogicConditionNotMatch = 5732,
    ErrFightLogicRunDataInvalid = 5733,
    ErrSkillStageNotFind = 5734,
    ErrConditionCfgSize = 6000,
    ErrConditionDissatisfy = 6001,
    ErrConditionObjectIsNull = 6002,
    ErrConditionTypeNotFound = 6003,
    ErrConditionEntityDeath = 6004,
    ErrConditionUnionLevel = 6005,
    ErrConditionUnionMoney = 6006,
    ErrConditionNotMeet = 6007,
    ErrConditionNotInShapeShift = 6008,
    ErrSeasonAchievementNoExist = 6101,
    ErrSeasonAchievementNoFinish = 6102,
    ErrSeasonAchievementHasReceived = 6103,
    ErrSeasonAchievementPrevIdNoReceived = 6104,
    ErrSeasonAchievementPrevIdNoExist = 6105,
    ErrSeasonAchievementTargetConfigError = 6106,
    ErrSeasonRankHasMax = 6151,
    ErrSeasonRankHasReceived = 6152,
    ErrSeasonRankNoAchieve = 6153,
    ErrSeasonRankCurSeasonIdZero = 6154,
    ErrSeasonRankNoMeetCondition = 6155,
    ErrSeasonRankSeasonNoSame = 6156,
    ErrBattlePassBuyLevel = 6201,
    ErrBattlePassBuyMaterial = 6202,
    ErrBattlePassAwardGet = 6203,
    ErrBattlePassAwardNotUnlock = 6204,
    ErrBattlePassBuyWeekExpLimit = 6205,
    ErrBattlePassLevelError = 6206,
    ErrNoRefreshTimes = 6207,
    ErrTargetNotCompleted = 6208,
    ErrOnlinePeriodTooMore = 6251,
    ErrPersonalTagTooMore = 6252,
    ErrPersonalTagNotFound = 6253,
    ErrPersonalAvatarUnearned = 6254,
    ErrPersonalAvatarFrameUnearned = 6255,
    ErrPersonalCardStyleUnearned = 6256,
    ErrPersonalPhotoTooMore = 6257,
    ErrPersonalMedalUnearned = 6258,
    ErrPersonalTargetUnlock = 6259,
    ErrPersonalTargetAlreadyGet = 6260,
    ErrPersonalMedalInvalidSlot = 6261,
    ErrPersonalMedalDuplicateValue = 6262,
    ErrOnlinePeriodDuplicate = 6263,
    ErrPersonalTagDuplicate = 6264,
    ErrPersonalPhotoInvalidSlot = 6265,
    ErrPersonalPhotoDuplicateValue = 6266,
    ErrSeasonMedalNoMeetActiveCondition = 6301,
    ErrSeasonMedalNoMeetUpgradeCondition = 6302,
    ErrSeasonMedalActiveMeetNoEnough = 6303,
    ErrSeasonMedalUpgradeMeetNoEnough = 6304,
    ErrSeasonMedalIllegalNodeId = 6305,
    ErrSeasonMedalChooseNodeIdBeyondMax = 6306,
    ErrSeasonMedalHoleNoExist = 6307,
    ErrSeasonMedalHoleLock = 6308,
    ErrSeasonMedalNodeNoExist = 6309,
    ErrSeasonMedalHoleNoGet = 6310,
    ErrSeasonMedalMaxHoleLevel = 6311,
    ErrSeasonMedalCoreHoleLock = 6312,
    ErrSeasonMedalUpgradeMoneyNoEnough = 6313,
    ErrSeasonNoCoreHole = 6314,
    ErrSeasonNoNormalHole = 6315,
    ErrSeasonMedalNoUpgradeNormalHoleItem = 6316,
    ErrSceneLineNotExists = 6351,
    ErrSceneLineRefreshCd = 6352,
    ErrSceneLineNotSameScene = 6353,
    ErrSceneLineSameLine = 6354,
    ErrSceneLineInteracting = 6355,
    ErrSceneLineUserDead = 6356,
    ErrSceneLineFull = 6357,
    ErrSceneLineChangeCd = 6358,
    ErrSceneVersionRecycle = 6359,
    ErrSceneLineKick = 6360,
    ErrInstallSlotFailed = 6401,
    ErrUseSlotFailed = 6402,
    ErrUseSlotInCd = 6403,
    ErrInstatallSlotFailedInCombat = 6404,
    ErrSlotSkillUnLoad = 6405,
    ErrUseCfgSkillFailed = 6406,
    ErrResonanceNotExists = 6407,
    ErrResonanceUnLoad = 6408,
    ErrUseDodgeFailed = 6409,
    ErrUseFixedSkillFailed = 6410,
    ErrUseBlockedSkill = 6411,
    ErrInstallBlockedSkill = 6412,
    ErrExchangeNotFound = 6451,
    ErrExchangeNotEnough = 6452,
    ErrExchangeItemLimit = 6453,
    ErrExchangeStepRange = 6454,
    ErrExchangeItemFull = 6455,
    ErrExchangePackageFull = 6456,
    ErrExchangePriceItemNotFind = 6457,
    ErrExchangeBuyNumNotEnough = 6458,
    ErrExchangeBuyItemNotFound = 6459,
    ErrExchangeTakeFailDelayTime = 6460,
    ErrExchangeTakeFailSellNum = 6461,
    ErrExchangeTakeItemNotFound = 6462,
    ErrExchangeWithdrawNoMoney = 6463,
    ErrExchangeDepositNotEnough = 6464,
    ErrExchangeItemNotBindOrCooldownNotExpire = 6465,
    ErrExchangeInCd = 6466,
    ErrExchangeBuyCurrencyNoEnough = 6467,
    ErrExchangeItemDelayTimeOver = 6468,
    ErrExchangeItemIsNotWithdraw = 6469,
    ErrExchangeBuyItemLimit = 6470,
    ErrExchangeItemIsNotNoticeShopItem = 6471,
    ErrExchangeItemIsPreBuyAlready = 6472,
    ErrExchangeItemNotPublic = 6473,
    ErrExchangeSaleRankExist = 6474,
    ErrExchangeSaleItemFull = 6475,
    ErrExchangeSaleDiamondNotEnough = 6476,
    ErrExchangeSaleItemNotExists = 6477,
    ErrExchangeBuySaleCurrencyNoEnough = 6478,
    ErrExchangeDiamondNotEnough = 6479,
    ErrExchangeSaleTakeOffCd = 6480,
    ErrExchangeSaleRateInvalid = 6481,
    ErrExchangePreItemFull = 6482,
    ErrExchangeSaleNumInvalid = 6483,
    ErrExchangeCareItemAlready = 6484,
    ErrExchangePriceRange = 6485,
    ErrExchangeRequestLimit = 6486,
    ErrExchangeItemBanned = 6487,
    ErrExchangePriceNotLow = 6488,
    ErrExchangeItemNotFind = 6489,
    ErrExchangeItemExistMinPrice = 6490,
    ErrExchangeNoticeItemMin = 6491,
    ErrExchangePreBuyUserFull = 6492,
    ErrModHoleNotUnlock = 6501,
    ErrModNotExist = 6502,
    ErrModSimilarRepeated = 6503,
    ErrModTypeLimitExceeded = 6504,
    ErrModPartNotExist = 6505,
    ErrModPartEnhanceLimit = 6506,
    ErrModInUse = 6507,
    ErrModAlreadyInstalled = 6508,
    ErrModInitConfigNotExist = 6509,
    ErrModPartOverflow = 6510,
    ErrModCanNotLink = 6511,
    ErrFishingNotUseBait = 6551,
    ErrFishingRandomFailed = 6552,
    ErrFishingAlreadyGetFishItem = 6553,
    ErrFishingGetFishIdWrong = 6554,
    ErrFishingNotGet = 6555,
    ErrFishingNotResearchYet = 6556,
    ErrFishingNotUseRod = 6557,
    ErrFishingNoSeat = 6558,
    ErrFishingCantResearch = 6559,
    ErrFishDrawnLevelAward = 6560,
    ErrFishCannotDrawLevelAward = 6561,
    ErrFishDrawnNoLevelAward = 6562,
    ErrFreightNoRefreshGoods = 6601,
    ErrFreightBeyondMaxValue = 6602,
    ErrFreightDownMinValue = 6603,
    ErrFreightHasSetOff = 6604,
    ErrFreightNoSetOff = 6605,
    ErrFreightHasReward = 6606,
    ErrFreightIllegalGoodsId = 6607,
    ErrFreightItemNoEnough = 6608,
    ErrFreightNoUpSetOffTime = 6609,
    ErrFreightNoUpRewardTime = 6610,
    ErrFreightAutoSetOff = 6611,
    ErrTrialRoadAwardNotFinished = 6651,
    ErrTrialRoadAwardRoomGet = 6652,
    ErrNotCanRide = 6701,
    ErrCombatStateNotRide = 6702,
    ErrAlreadyRide = 6703,
    ErrRideNotEnough = 6704,
    ErrCreateVehicleActorFailed = 6705,
    ErrNotVehicleOwner = 6706,
    ErrVehicleHasController = 6707,
    ErrVehicleNoSeat = 6708,
    ErrVehicleHasSeat = 6709,
    ErrNotRideVehicle = 6710,
    ErrVehicleNotExits = 6711,
    ErrInvalidRidePropertyType = 6712,
    ErrRideApplyTargetUserNotExist = 6713,
    ErrRideConfigNotFind = 6714,
    ErrRideNotUnlock = 6715,
    ErrRideNotFind = 6716,
    ErrInvalidRideType = 6717,
    ErrRideApplyAlreadyExist = 6718,
    ErrRideApplyNotRideVehicle = 6719,
    ErrRideApplyVehicleNotSeat = 6720,
    ErrRideAlReadyRide = 6721,
    ErrRideApplyTargetTooFar = 6722,
    ErrRideNotTake = 6723,
    ErrRideInteracting = 6724,
    ErrShapeshiftNotRide = 6725,
    ErrFishingNotRide = 6726,
    ErrRideStateReject = 6727,
    ErrRideTypeNotSupport = 6728,
    ErrRideNotControl = 6729,
    ErrRideNotFunction = 6730,
    ErrRideSkinNotSupport = 6731,
    ErrRideSkinNotUnlock = 6732,
    ErrRideSkinDataAddFailed = 6733,
    ErrRideSkinNotSkin = 6734,
    ErrRideSkinAlreadyActivate = 6735,
    ErrWarehouseHas = 7000,
    ErrWarehouseNoHas = 7001,
    ErrWarehouseNoMem = 7002,
    ErrWarehouseNoPresident = 7003,
    ErrWarehouseNoHasItem = 7004,
    ErrWarehouseItemNoDeposit = 7005,
    ErrWarehouseGridPosNoExist = 7006,
    ErrWarehouseGridPosItemNoEnough = 7007,
    ErrWarehouseNoInviteSelf = 7008,
    ErrWarehouseInviteesHas = 7009,
    ErrWarehouseMemBeyondMax = 7010,
    ErrWarehouseGridBeyondMax = 7011,
    ErrWarehouseNoSelf = 7012,
    ErrWarehouseIsMem = 7013,
    ErrWarehouseNoExist = 7014,
    ErrWarehouseDepositBeyondMax = 7015,
    ErrWarehouseTakeOutBeyondMax = 7016,
    ErrWarehouseItemIdNotSame = 7017,
    ErrWarehouseParams = 7018,
    ErrWarehouseNoKickSelf = 7019,
    ErrWarehousePresidentNoExit = 7020,
    ErrGashaDrawCount = 7021,
    ErrGashaDrawLimit = 7022,
    ErrGashaInvalidWishId = 7023,
    EErGashaWishRepeated = 7026,
    EErGashaWishCountNoEnough = 7027,
    ErrWarehouseAuthority = 7028,
    ErrEquipCantDecompose = 7051,
    ErrEquipNotRecastRecord = 7052,
    ErrEquipOnCantUsedRecastConsume = 7053,
    ErrEquipWeaponNotEqualProfession = 7054,
    ErrEquipSlotRefineBlessNotFit = 7055,
    ErrEquipNotRecast = 7056,
    ErrEquipEnchantItemMismatch = 7057,
    ErrEquipEnchantAlreadyEnchanted = 7058,
    ErrEquipAnyItemMismatch = 7059,
    ErrEquipSlotRefineBlessNumTooMuch = 7060,
    ErrEquipNameGroupNoMatch = 7061,
    ErrEquipPerfectionNoMatch = 7062,
    ErrEquipNotBreak = 7063,
    ErrEquipPutOnIng = 7064,
    ErrUserIsMatching = 7101,
    ErrUserNotInMatching = 7102,
    ErrUseNotWaitReady = 7103,
    ErrDungeonCantMatch = 7104,
    ErrMatchQueueFull = 7105,
    ErrCommonAwardCantReceive = 7151,
    ErrCommonAwardHasReceived = 7152,
    ErrCraftEnergyNotEnough = 7201,
    ErrCraftEnergyFull = 7202,
    ErrRecommendPlayNotOpen = 7250,
    ErrWeeklyTowerNoStart = 7251,
    ErrWeeklyTowerHasEnd = 7252,
    ErrWeeklyNoMeetProcessAward = 7253,
    ErrWeeklyHasRewardProcessAward = 7254,
    ErrWeeklyNoLayerStageAward = 7255,
    ErrWeekOnlyCurSeasonAward = 7256,
    ErrWeeklyTowerCannotEnterLayer = 7257,
    ErrWeeklyTowerBoxHasOpen = 7258,
    ErrWeeklyTowerNoBox = 7259,
    ErrWeeklyTowerNoStageAward = 7260,
    ErrWeeklyTowerNoTowerDungeon = 7261,
    ErrFunctionNoAward = 7271,
    ErrFunctionHasDrawn = 7272,
    ErrTLogIllegalExportArea = 7281,
    ErrPayOrderFail = 7300,
    ErrPayCostNotEnough = 7301,
    ErrPayCantBuy = 7302,
    ErrPayCantExplore = 7303,
    ErrActivityNotFind = 7350,
    ErrActivityOffline = 7351,
    ErrActivityNotOpen = 7352,
    ErrActivityRewardNotFound = 7353,
    ErrActivityConditionNotFinish = 7354,
    ErrActivityAlreadyObtain = 7355,
    ErrActivityNotUnlock = 7356,
    ErrEmojiConfigError = 7401,
    ErrEmojiAlreadyUnlock = 7402,
    ErrEmojiUnlockItemError = 7403,
    ErrEmojiUnlockItemErrorItemNotEnough = 7404,
    ErrEmojiUnlock = 7405,
    ErrGlobalConditionNotFound = 7406,
    ErrGlobalConditionNotLuckyValue = 7407,
    ErrPathFindingCant = 7412,
    ErrPathFindingDataError = 7413,
    ErrPathFindingEndPosError = 7414,
    ErrPathFindingStartPosError = 7415,
    ErrPathFindingNoPath = 7416,
    ErrSignNotOpen = 7421,
    ErrSignNotSigned = 7422,
    ErrSignAlreadySigned = 7423,
    ErrSignTimeError = 7424,
    ErrTokenBucketLimit = 9998,
    ErrUnknown = 9999,
}
impl EErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ErrSuccess => "ErrSuccess",
            Self::ErrNoRecord => "ErrNoRecord",
            Self::ErrExceptionCancel => "ErrExceptionCancel",
            Self::ErrDbException => "ErrDBException",
            Self::ErrDbSeqException => "ErrDBSeqException",
            Self::ErrDbSceneException => "ErrDBSceneException",
            Self::ErrDbTokenException => "ErrDBTokenException",
            Self::ErrCancelled => "ErrCancelled",
            Self::ErrUnknownRpc => "ErrUnknownRpc",
            Self::ErrInvalidArgument => "ErrInvalidArgument",
            Self::ErrDeadlineExceeded => "ErrDeadlineExceeded",
            Self::ErrNotFound => "ErrNotFound",
            Self::ErrAlreadyExists => "ErrAlreadyExists",
            Self::ErrPermissionDenied => "ErrPermissionDenied",
            Self::ErrResourceExhausted => "ErrResourceExhausted",
            Self::ErrFailedPrecondition => "ErrFailedPrecondition",
            Self::ErrAborted => "ErrAborted",
            Self::ErrOutOfRange => "ErrOutOfRange",
            Self::ErrUnimplemented => "ErrUnimplemented",
            Self::ErrInternal => "ErrInternal",
            Self::ErrUnavailable => "ErrUnavailable",
            Self::ErrDataLoss => "ErrDataLoss",
            Self::ErrUnauthenticated => "ErrUnauthenticated",
            Self::ErrSystemMax => "ErrSystemMax",
            Self::ErrDbError => "ErrDBError",
            Self::ErrCreateOpenInfo => "ErrCreateOpenInfo",
            Self::ErrCreateAccountInfo => "ErrCreateAccountInfo",
            Self::ErrCreateCharInfo => "ErrCreateCharInfo",
            Self::ErrCreateAccountToken => "ErrCreateAccountToken",
            Self::ErrGetOpenInfo => "ErrGetOpenInfo",
            Self::ErrGetAccountInfo => "ErrGetAccountInfo",
            Self::ErrGetCharInfo => "ErrGetCharInfo",
            Self::ErrGetAccountToken => "ErrGetAccountToken",
            Self::ErrLoginInQueue => "ErrLoginInQueue",
            Self::ErrOtherLogin => "ErrOtherLogin",
            Self::ErrServerError => "ErrServerError",
            Self::ErrNoAccountInfo => "ErrNoAccountInfo",
            Self::ErrNoCharInfo => "ErrNoCharInfo",
            Self::ErrTokenExpired => "ErrTokenExpired",
            Self::ErrUpdateTokenFail => "ErrUpdateTokenFail",
            Self::ErrRegIntoSceneError => "ErrRegIntoSceneError",
            Self::ErrLoginTypeErr => "ErrLoginTypeErr",
            Self::ErrChangeMapErr => "ErrChangeMapErr",
            Self::ErrLoginPlatformErr => "ErrLoginPlatformErr",
            Self::ErrVersionErr => "ErrVersionErr",
            Self::ErrDelayOffLineKickOff => "ErrDelayOffLineKickOff",
            Self::ErrServiceLanguageError => "ErrServiceLanguageError",
            Self::NoEnterScene => "NoEnterScene",
            Self::ModIdNotOpen => "ModIDNotOpen",
            Self::ErrFaceData => "ErrFaceData",
            Self::ErrInitProfession => "ErrInitProfession",
            Self::ErrSceneCloseKickoff => "ErrSceneCloseKickoff",
            Self::ErrLoginReconnectKick => "ErrLoginReconnectKick",
            Self::ErrLoginErrorResume => "ErrLoginErrorResume",
            Self::ErrRepeatedLogin => "ErrRepeatedLogin",
            Self::ErrRestrictLogin => "ErrRestrictLogin",
            Self::ErrRestrictBlack => "ErrRestrictBlack",
            Self::ErrSdkVerifyFail => "ErrSdkVerifyFail",
            Self::ErrSdkTokenExpired => "ErrSdkTokenExpired",
            Self::ErrServerNotOpen => "ErrServerNotOpen",
            Self::ErrServerEndOpen => "ErrServerEndOpen",
            Self::ErrNormalKick => "ErrNormalKick",
            Self::ErrServerBusy => "ErrServerBusy",
            Self::ErrServerClose => "ErrServerClose",
            Self::ErrExitGame => "ErrExitGame",
            Self::ErrHopeKick => "ErrHopeKick",
            Self::ErrClientVersionError => "ErrClientVersionError",
            Self::ErrInvalidDeviceId => "ErrInvalidDeviceId",
            Self::ErrInvalidSystemType => "ErrInvalidSystemType",
            Self::ErrDeleteChar => "ErrDeleteChar",
            Self::ErrCancelDeleteChar => "ErrCancelDeleteChar",
            Self::ErrCancelDeleteCharIsDelete => "ErrCancelDeleteCharIsDelete",
            Self::ErrIntoSceneOwnerFail => "ErrIntoSceneOwnerFail",
            Self::ErrSceneQueueUp => "ErrSceneQueueUp",
            Self::ErrProtocolVersionErr => "ErrProtocolVersionErr",
            Self::ErrConfigVersionErr => "ErrConfigVersionErr",
            Self::ErrStateEventFailed => "ErrStateEventFailed",
            Self::ErrSelectCharDoing => "ErrSelectCharDoing",
            Self::ErrSelectCharDeleted => "ErrSelectCharDeleted",
            Self::ErrLoginChannelMax => "ErrLoginChannelMax",
            Self::ErrDeleteAccountKick => "ErrDeleteAccountKick",
            Self::ErrIsDeleteAccount => "ErrIsDeleteAccount",
            Self::ErrIsVersionKick => "ErrIsVersionKick",
            Self::ErrNotQqChnnel => "ErrNotQQChnnel",
            Self::ErrIncorrectLaunchPlatform => "ErrIncorrectLaunchPlatform",
            Self::ErrConditionWrong => "ErrConditionWrong",
            Self::ErrNotSupportLoginType => "ErrNotSupportLoginType",
            Self::ErrSceneNotExist => "ErrSceneNotExist",
            Self::ErrUserNotExist => "ErrUserNotExist",
            Self::ErrComponentNotExist => "ErrComponentNotExist",
            Self::ErrSceneConfigNotExist => "ErrSceneConfigNotExist",
            Self::ErrServiceNotExist => "ErrServiceNotExist",
            Self::ErrDataContainerNotExist => "ErrDataContainerNotExist",
            Self::ErrAsynchronousReturn => "ErrAsynchronousReturn",
            Self::ErrConfigNotExist => "ErrConfigNotExist",
            Self::ErrNotUser => "ErrNotUser",
            Self::ErrConfigError => "ErrConfigError",
            Self::ErrActorNotExist => "ErrActorNotExist",
            Self::ErrCutSceneAlreadyPlayed => "ErrCutSceneAlreadyPlayed",
            Self::ErrFunctionUnlock => "ErrFunctionUnlock",
            Self::ErrFunctionClosed => "ErrFunctionClosed",
            Self::ErrUserPlayerNotFurniturePackage => "ErrUserPlayerNotFurniturePackage",
            Self::ErrSysInnerError => "ErrSysInnerError",
            Self::ErrSysWebClientNull => "ErrSysWebClientNull",
            Self::ErrSysWebRequestTimeOut => "ErrSysWebRequestTimeOut",
            Self::ErrSysWebReturnError => "ErrSysWebReturnError",
            Self::ErrRequestTooFrequently => "ErrRequestTooFrequently",
            Self::ErrArgStringTooLong => "ErrArgStringTooLong",
            Self::ErrArgStringEmpty => "ErrArgStringEmpty",
            Self::ErrArgArrayTooBig => "ErrArgArrayTooBig",
            Self::ErrArgArrayEmpty => "ErrArgArrayEmpty",
            Self::ErrArgMapTooBig => "ErrArgMapTooBig",
            Self::ErrArgMapEmpty => "ErrArgMapEmpty",
            Self::ErrItemNotExist => "ErrItemNotExist",
            Self::ErrPackageNotExist => "ErrPackageNotExist",
            Self::ErrPackageFull => "ErrPackageFull",
            Self::ErrItemExpireTime => "ErrItemExpireTime",
            Self::ErrItemPackageGridNotEnough => "ErrItemPackageGridNotEnough",
            Self::ErrItemUuidError => "ErrItemUUIDError",
            Self::ErrItemNotEnough => "ErrItemNotEnough",
            Self::ErrOptTypeError => "ErrOptTypeError",
            Self::ErrItemInCoolDown => "ErrItemInCoolDown",
            Self::ErrItemNotUse => "ErrItemNotUse",
            Self::ErrItemEffectTypeError => "ErrItemEffectTypeError",
            Self::ErrItemParamError => "ErrItemParamError",
            Self::ErrItemAddBuffError => "ErrItemAddBuffError",
            Self::ErrItemAdd => "ErrItemAdd",
            Self::ErrUseItemState => "ErrUseItemState",
            Self::ErrBatchUse => "ErrBatchUse",
            Self::ErrFullSendMail => "ErrFullSendMail",
            Self::ErrItemNumZero => "ErrItemNumZero",
            Self::ErrItemSelectAwardIllegalNum => "ErrItemSelectAwardIllegalNum",
            Self::ErrItemSelectAwardIllegalPos => "ErrItemSelectAwardIllegalPos",
            Self::ErrItemSelectLimit => "ErrItemSelectLimit",
            Self::ErrItemPeriodGainExceeded => "ErrItemPeriodGainExceeded",
            Self::ErrItemNoRecycle => "ErrItemNoRecycle",
            Self::ErrItemRecycleBeyondMaxGrid => "ErrItemRecycleBeyondMaxGrid",
            Self::ErrItemRecycleBeyondMaxNum => "ErrItemRecycleBeyondMaxNum",
            Self::ErrItemRecycleIdNoMatchItemId => "ErrItemRecycleIdNoMatchItemId",
            Self::ErrItemRecycleIllegalId => "ErrItemRecycleIllegalId",
            Self::ErrItemLimitCount => "ErrItemLimitCount",
            Self::ErrItemFriendPontExceeded => "ErrItemFriendPontExceeded",
            Self::ErrItemToySingleEntUseExceeded => "ErrItemToySingleEntUseExceeded",
            Self::ErrItemToySceneUseExceeded => "ErrItemToySceneUseExceeded",
            Self::ErrItemToyUseInDisableArea => "ErrItemToyUseInDisableArea",
            Self::ErrItemToySingleCellUseExceeded => "ErrItemToySingleCellUseExceeded",
            Self::ErrMonthlyCardNotExists => "ErrMonthlyCardNotExists",
            Self::ErrMonthlyCardDataError => "ErrMonthlyCardDataError",
            Self::ErrMonthlyCardDayAwardReceived => "ErrMonthlyCardDayAwardReceived",
            Self::ErrMonthlyCardLimitCount => "ErrMonthlyCardLimitCount",
            Self::ErrCommunityNoHome => "ErrCommunityNoHome",
            Self::ErrNotHouseOwner => "ErrNotHouseOwner",
            Self::ErrHomeLandExisted => "ErrHomeLandExisted",
            Self::ErrHomeLandContentWrongful => "ErrHomeLandContentWrongful",
            Self::ErrHouseLivetogetherCd => "ErrHouseLivetogetherCD",
            Self::ErrHomeLandNotExisted => "ErrHomeLandNotExisted",
            Self::ErrHomeLandNotInScene => "ErrHomeLandNotInScene",
            Self::ErrHomeLandIsInvitation => "ErrHomeLandIsInvitation",
            Self::ErrHomeLandInsufficientAuthority => "ErrHomeLandInsufficientAuthority",
            Self::ErrHomeLandTransferRequestPending => {
                "ErrHomeLandTransferRequestPending"
            }
            Self::ErrHomeLandTransferRequestTimeout => {
                "ErrHomeLandTransferRequestTimeout"
            }
            Self::ErrHomeLandTransferCd => "ErrHomeLandTransferCD",
            Self::ErrHomelandTargetIsHasHome => "ErrHomelandTargetIsHasHome",
            Self::ErrHomelandTargetIsOwner => "ErrHomelandTargetIsOwner",
            Self::ErrHomelandNotOwnerCannotOperate => "ErrHomelandNotOwnerCannotOperate",
            Self::ErrHomeLandHasHouse => "ErrHomeLandHasHouse",
            Self::ErrHomeLandContentTooLong => "ErrHomeLandContentTooLong",
            Self::ErrHomeLandClutterNotExist => "ErrHomeLandClutterNotExist",
            Self::ErrHouseNameOrStatementCd => "ErrHouseNameOrStatementCD",
            Self::ErrHouseIntroductionStatementCd => "ErrHouseIntroductionStatementCD",
            Self::ErrCommunityBuildInvalidRecipeId => "ErrCommunityBuildInvalidRecipeId",
            Self::ErrCommunityBuildRecipeIsUnlock => "ErrCommunityBuildRecipeIsUnlock",
            Self::ErrCommunityBuildMax => "ErrCommunityBuildMax",
            Self::ErrCommunityBuildNoAuthority => "ErrCommunityBuildNoAuthority",
            Self::ErrCommunityNotBuildCannotCancel => "ErrCommunityNotBuildCannotCancel",
            Self::ErrCommunityBuildNotSelfCannotCancel => {
                "ErrCommunityBuildNotSelfCannotCancel"
            }
            Self::ErrCommunityNotBuildCannotAccelerate => {
                "ErrCommunityNotBuildCannotAccelerate"
            }
            Self::ErrCommunityBuildNotSelfCannotAccelerate => {
                "ErrCommunityBuildNotSelfCannotAccelerate"
            }
            Self::ErrCommunityBuildCannotAccelerate => {
                "ErrCommunityBuildCannotAccelerate"
            }
            Self::ErrCommunityBuildAlreadyAccelerate => {
                "ErrCommunityBuildAlreadyAccelerate"
            }
            Self::ErrCommunityBuildInDungeon => "ErrCommunityBuildInDungeon",
            Self::ErrCommunityBuildRecipeIsLock => "ErrCommunityBuildRecipeIsLock",
            Self::ErrCommunityBuildRecipeNotItemUnlock => {
                "ErrCommunityBuildRecipeNotItemUnlock"
            }
            Self::ErrCommunityBuildInvalidCount => "ErrCommunityBuildInvalidCount",
            Self::ErrCommunityNotBuildCannotReceive => {
                "ErrCommunityNotBuildCannotReceive"
            }
            Self::ErrCommunityCanNotBuild => "ErrCommunityCanNotBuild",
            Self::ErrHomeLandCohabitantLimit => "ErrHomeLandCohabitantLimit",
            Self::ErrHomeLandRootNotQuitCohabitant => "ErrHomeLandRootNotQuitCohabitant",
            Self::ErrHomeLandNotOwnerCannotQuitCohabitant => {
                "ErrHomeLandNotOwnerCannotQuitCohabitant"
            }
            Self::ErrHomeLandCohabitantIsExiting => "ErrHomeLandCohabitantIsExiting",
            Self::ErrHomeLandCohabitantNotExists => "ErrHomeLandCohabitantNotExists",
            Self::ErrHomeLandCohabitantExitRequestExists => {
                "ErrHomeLandCohabitantExitRequestExists"
            }
            Self::ErrHomeLandCohabitantDismiss => "ErrHomeLandCohabitantDismiss",
            Self::ErrHomeLandNotInvitation => "ErrHomeLandNotInvitation",
            Self::ErrHomeLandCohabitantInvitationTimeout => {
                "ErrHomeLandCohabitantInvitationTimeout"
            }
            Self::ErrHomeLandCohabitantNotFriend => "ErrHomeLandCohabitantNotFriend",
            Self::ErrHomeLandCohabitantFriendLevel => "ErrHomeLandCohabitantFriendLevel",
            Self::ErrHomeLandCohabitantLevel => "ErrHomeLandCohabitantLevel",
            Self::ErrHomeLandInviteCohabitantNotOwner => {
                "ErrHomeLandInviteCohabitantNotOwner"
            }
            Self::ErrCommunityWarehouseGridFull => "ErrCommunityWarehouseGridFull",
            Self::ErrCommunityWarehouseNoAuthority => "ErrCommunityWarehouseNoAuthority",
            Self::ErrCommunityWarehouseGridPosItemNoEnough => {
                "ErrCommunityWarehouseGridPosItemNoEnough"
            }
            Self::ErrHomeLandInsufficientFurniture => "ErrHomeLandInsufficientFurniture",
            Self::ErrCommunityWarehouseTakeOutCountLimit => {
                "ErrCommunityWarehouseTakeOutCountLimit"
            }
            Self::ErrHomeLandTaskNotExist => "ErrHomeLandTaskNotExist",
            Self::ErrHomeLandTaskTimeNotEnough => "ErrHomeLandTaskTimeNotEnough",
            Self::ErrHomeLandTaskAlreadyFinished => "ErrHomeLandTaskAlreadyFinished",
            Self::ErrHomeLandTaskItemNotEnough => "ErrHomeLandTaskItemNotEnough",
            Self::ErrHomeLandCurLevelError => "ErrHomeLandCurLevelError",
            Self::ErrHomeLandExpNotEnough => "ErrHomeLandExpNotEnough",
            Self::ErrHomeLandAlreadyMaxLevel => "ErrHomeLandAlreadyMaxLevel",
            Self::ErrHomeLandLevelLocked => "ErrHomeLandLevelLocked",
            Self::ErrHomeLandLevelConfigError => "ErrHomeLandLevelConfigError",
            Self::ErrCommunityEditorNotEditable => "ErrCommunityEditorNotEditable",
            Self::ErrCommunityEditorNotFurniture => "ErrCommunityEditorNotFurniture",
            Self::ErrCommunityEditorNotOutdoor => "ErrCommunityEditorNotOutdoor",
            Self::ErrCommunityEditorNotIndoor => "ErrCommunityEditorNotIndoor",
            Self::ErrCommunityEditorOverMax => "ErrCommunityEditorOverMax",
            Self::ErrCommunityEditorOverTypeMax => "ErrCommunityEditorOverTypeMax",
            Self::ErrCommunityEditorFurnitureNotEnough => {
                "ErrCommunityEditorFurnitureNotEnough"
            }
            Self::ErrCommunityEditorFurnitureNotExist => {
                "ErrCommunityEditorFurnitureNotExist"
            }
            Self::ErrCommunityEditorOverMaxGroup => "ErrCommunityEditorOverMaxGroup",
            Self::ErrCommunityEditorNoStructure => "ErrCommunityEditorNoStructure",
            Self::ErrCommunityEditorGroupMaxStructure => {
                "ErrCommunityEditorGroupMaxStructure"
            }
            Self::ErrCommunityEditorStructureInGroup => {
                "ErrCommunityEditorStructureInGroup"
            }
            Self::ErrCommunityEditorGroupNotExist => "ErrCommunityEditorGroupNotExist",
            Self::ErrCommunityEditorAlreadyExist => "ErrCommunityEditorAlreadyExist",
            Self::ErrHomeLandSellItemNotExist => "ErrHomeLandSellItemNotExist",
            Self::ErrHomeLandLeftNumNotEnough => "ErrHomeLandLeftNumNotEnough",
            Self::ErrHomeLandSellShopLocked => "ErrHomeLandSellShopLocked",
            Self::ErrHomeLandSeedExist => "ErrHomeLandSeedExist",
            Self::ErrHomeLandItemNotOwner => "ErrHomeLandItemNotOwner",
            Self::ErrHomeLandSeedStateError => "ErrHomeLandSeedStateError",
            Self::ErrHomeLandNoSeed => "ErrHomeLandNoSeed",
            Self::ErrHomeLandNoWater => "ErrHomeLandNoWater",
            Self::ErrHomeLandFertilizerMaxNumLimit => "ErrHomeLandFertilizerMaxNumLimit",
            Self::ErrHomeLandNotFertilize => "ErrHomeLandNotFertilize",
            Self::ErrHomeLandNotPollen => "ErrHomeLandNotPollen",
            Self::ErrHomeLandAlreadyPollen => "ErrHomeLandAlreadyPollen",
            Self::ErrHomeLandNotHarvest => "ErrHomeLandNotHarvest",
            Self::ErrHomeLandPickUpSinglePlayerLimit => {
                "ErrHomeLandPickUpSinglePlayerLimit"
            }
            Self::ErrHomeLandPickUpTotalLimit => "ErrHomeLandPickUpTotalLimit",
            Self::ErrHomeLandPickUpFlowerNotFinished => {
                "ErrHomeLandPickUpFlowerNotFinished"
            }
            Self::ErrHomeLandPickUpOwner => "ErrHomeLandPickUpOwner",
            Self::ErrHomeLandGainNotOwner => "ErrHomeLandGainNotOwner",
            Self::ErrHomeLandItemFullGrid => "ErrHomeLandItemFullGrid",
            Self::ErrHomeLandFurnitureFull => "ErrHomeLandFurnitureFull",
            Self::ErrComposeItemNotEnough => "ErrComposeItemNotEnough",
            Self::ErrComposeFailed => "ErrComposeFailed",
            Self::ErrRedemptionItemNotExist => "ErrRedemptionItemNotExist",
            Self::ErrRedemptionItemMaxCount => "ErrRedemptionItemMaxCount",
            Self::ErrRedemptionItemNotEnough => "ErrRedemptionItemNotEnough",
            Self::ErrRedemptionItemGender => "ErrRedemptionItemGender",
            Self::ErrAwardConfigNotFound => "ErrAwardConfigNotFound",
            Self::ErrAwardConfigWeightError => "ErrAwardConfigWeightError",
            Self::ErrAwardConfigLimitAndContentNotMatch => {
                "ErrAwardConfigLimitAndContentNotMatch"
            }
            Self::ErrAwardConfigContentSizeError => "ErrAwardConfigContentSizeError",
            Self::ErrAwardConfigContentRatesSizeError => {
                "ErrAwardConfigContentRatesSizeError"
            }
            Self::ErrAwardConfigContentWeightSizeError => {
                "ErrAwardConfigContentWeightSizeError"
            }
            Self::ErrAwardConfigGroupContentEmpty => "ErrAwardConfigGroupContentEmpty",
            Self::ErrAwardConfigGroupNumEmpty => "ErrAwardConfigGroupNumEmpty",
            Self::ErrAwardConfigGroupContentNoMatchGroupNum => {
                "ErrAwardConfigGroupContentNoMatchGroupNum"
            }
            Self::ErrAwardConfigNoRandomDrop => "ErrAwardConfigNoRandomDrop",
            Self::ErrAwardConfigNoSelectAward => "ErrAwardConfigNoSelectAward",
            Self::ErrAwardConfigSelfSelectContentNoItem => {
                "ErrAwardConfigSelfSelectContentNoItem"
            }
            Self::ErrAwardConfigWeightRateMustOne => "ErrAwardConfigWeightRateMustOne",
            Self::ErrAwardConfigGroupContentRandomNoMatch => {
                "ErrAwardConfigGroupContentRandomNoMatch"
            }
            Self::ErrAwardConfigGroupContentError => "ErrAwardConfigGroupContentError",
            Self::ErrAwardConfigPackageContentRandomNoMatch => {
                "ErrAwardConfigPackageContentRandomNoMatch"
            }
            Self::ErrAwardConfigLevelUpPackConfigPackageNoMatch => {
                "ErrAwardConfigLevelUpPackConfigPackageNoMatch"
            }
            Self::ErrAwardConfigProItemRuleNoMatch => "ErrAwardConfigProItemRuleNoMatch",
            Self::ErrAwardConfigPackageContentEmpty => {
                "ErrAwardConfigPackageContentEmpty"
            }
            Self::ErrAwardConfigDropContentSize => "ErrAwardConfigDropContentSize",
            Self::ErrAwardConfigDropContentNum => "ErrAwardConfigDropContentNum",
            Self::ErrAwardConfigGroupRateEmpty => "ErrAwardConfigGroupRateEmpty",
            Self::ErrAwardConfigGroupWeightEmpty => "ErrAwardConfigGroupWeightEmpty",
            Self::ErrAwardInnerError => "ErrAwardInnerError",
            Self::ErrAwardIllegalRandomType => "ErrAwardIllegalRandomType",
            Self::ErrAwardConditionNoMeet => "ErrAwardConditionNoMeet",
            Self::ErrAwardRandomTypeNone => "ErrAwardRandomTypeNone",
            Self::ErrAwardRandomTypeNoMatch => "ErrAwardRandomTypeNoMatch",
            Self::ErrAwardActorIsNull => "ErrAwardActorIsNull",
            Self::ErrEquipWashAttrNotExist => "ErrEquipWashAttrNotExist",
            Self::ErrNotEquipInCombat => "ErrNotEquipInCombat",
            Self::ErrEquipPart => "ErrEquipPart",
            Self::ErrComposeItemNotExist => "ErrComposeItemNotExist",
            Self::ErrPickupDropItemDistance => "ErrPickupDropItemDistance",
            Self::ErrPickupDropItemPackageFull => "ErrPickupDropItemPackageFull",
            Self::ErrPickupDropItemNoAuthority => "ErrPickupDropItemNoAuthority",
            Self::ErrLayerActorExist => "ErrLayerActorExist",
            Self::ErrTeamCreateHas => "ErrTeamCreateHas",
            Self::ErrTeamIllTarget => "ErrTeamIllTarget",
            Self::ErrTeamCreateTryLater => "ErrTeamCreateTryLater",
            Self::ErrTeamGetNo => "ErrTeamGetNo",
            Self::ErrTeamListEmpty => "ErrTeamListEmpty",
            Self::ErrTeamInner => "ErrTeamInner",
            Self::ErrTeamNoLeader => "ErrTeamNoLeader",
            Self::ErrTeamInMatch => "ErrTeamInMatch",
            Self::ErrTeamCustomizeTarget => "ErrTeamCustomizeTarget",
            Self::ErrTeamNoOwn => "ErrTeamNoOwn",
            Self::ErrTeamTickSelf => "ErrTeamTickSelf",
            Self::ErrTeamNoMem => "ErrTeamNoMem",
            Self::ErrTeamApplyingLeader => "ErrTeamApplyingLeader",
            Self::ErrTeamHasBeLeader => "ErrTeamHasBeLeader",
            Self::ErrTeamNoTransferSelf => "ErrTeamNoTransferSelf",
            Self::ErrTeamNoLeaderTransfer => "ErrTeamNoLeaderTransfer",
            Self::ErrTeamHasOwnTeam => "ErrTeamHasOwnTeam",
            Self::ErrTeamNoExist => "ErrTeamNoExist",
            Self::ErrTeamApplyInCd => "ErrTeamApplyInCD",
            Self::ErrTeamApplyExpire => "ErrTeamApplyExpire",
            Self::ErrTeamJoinOther => "ErrTeamJoinOther",
            Self::ErrTeamMemMax => "ErrTeamMemMax",
            Self::ErrTeamNoInvited => "ErrTeamNoInvited",
            Self::ErrTeamIsMatching => "ErrTeamIsMatching",
            Self::ErrTeamIllegalTag => "ErrTeamIllegalTag",
            Self::ErrTeamNoMatching => "ErrTeamNoMatching",
            Self::ErrTeamIllegalActivity => "ErrTeamIllegalActivity",
            Self::ErrTeamInActivity => "ErrTeamInActivity",
            Self::ErrTeamNoMeetCondition => "ErrTeamNoMeetCondition",
            Self::ErrTeamWaitVoting => "ErrTeamWaitVoting",
            Self::ErrTeamDoingActivity => "ErrTeamDoingActivity",
            Self::ErrTeamNoInVoting => "ErrTeamNoInVoting",
            Self::ErrTeamVoteEnd => "ErrTeamVoteEnd",
            Self::ErrTeamHasVoted => "ErrTeamHasVoted",
            Self::ErrTeamInviteCd => "ErrTeamInviteCD",
            Self::ErrTeamApplyLeadCd => "ErrTeamApplyLeadCD",
            Self::ErrTeamMoreMaxWorlds => "ErrTeamMoreMaxWorlds",
            Self::ErrTeamValidApplyInfo => "ErrTeamValidApplyInfo",
            Self::ErrTeamInMatchCancelCd => "ErrTeamInMatchCancelCD",
            Self::ErrTeamMatchFinished => "ErrTeamMatchFinished",
            Self::ErrTeamMatchWaitSec => "ErrTeamMatchWaitSec",
            Self::ErrTeamMemWorldFull => "ErrTeamMemWorldFull",
            Self::ErrTeamMemNotLeader => "ErrTeamMemNotLeader",
            Self::ErrTeamLeaderNotStaticScene => "ErrTeamLeaderNotStaticScene",
            Self::ErrTeamLeaderCallDoing => "ErrTeamLeaderCallDoing",
            Self::ErrTeamIllegalCallOperator => "ErrTeamIllegalCallOperator",
            Self::ErrTeamLeaderIllegalCallOperator => "ErrTeamLeaderIllegalCallOperator",
            Self::ErrTeamNoMemCall => "ErrTeamNoMemCall",
            Self::ErrTeamLeaderCallEnd => "ErrTeamLeaderCallEnd",
            Self::ErrTeamSameScene => "ErrTeamSameScene",
            Self::ErrTeamNotSameScene => "ErrTeamNotSameScene",
            Self::ErrTeamMemTooMore => "ErrTeamMemTooMore",
            Self::ErrTeamMemInDungeon => "ErrTeamMemInDungeon",
            Self::ErrTeamMemTooLess => "ErrTeamMemTooLess",
            Self::ErrTeamIllegalInviteType => "ErrTeamIllegalInviteType",
            Self::ErrTeamMemberNotInScene => "ErrTeamMemberNotInScene",
            Self::ErrTeamLeaderReadyCheckTimeNotReady => {
                "ErrTeamLeaderReadyCheckTimeNotReady"
            }
            Self::ErrTeamExistDungeonCheck => "ErrTeamExistDungeonCheck",
            Self::ErrTeamTargetMatchTalentLimit => "ErrTeamTargetMatchTalentLimit",
            Self::ErrTeamEditGroupNotAllowed => "ErrTeamEditGroupNotAllowed",
            Self::ErrTeamGroupNotExist => "ErrTeamGroupNotExist",
            Self::ErrTeamTargetNoMatchMemberType => "ErrTeamTargetNoMatchMemberType",
            Self::ErrDecomposeItemNotExist => "ErrDecomposeItemNotExist",
            Self::ErrDecomposeItemNotEnough => "ErrDecomposeItemNotEnough",
            Self::ErrRefineEnergyNotEnough => "ErrRefineEnergyNotEnough",
            Self::ErrRefineItemMaxCount => "ErrRefineItemMaxCount",
            Self::ErrRefineItemNotExist => "ErrRefineItemNotExist",
            Self::ErrRefineItemColumnNotUnlock => "ErrRefineItemColumnNotUnlock",
            Self::ErrRefineItemColumnUnlock => "ErrRefineItemColumnUnlock",
            Self::ErrRefineItemExist => "ErrRefineItemExist",
            Self::ErrEnergyLimitMax => "ErrEnergyLimitMax",
            Self::ErrRefineItemColumnNotEmpty => "ErrRefineItemColumnNotEmpty",
            Self::ErrProfessionNotExist => "ErrProfessionNotExist",
            Self::ErrModSlotNotUnlock => "ErrModSlotNotUnlock",
            Self::ErrChangeProfessionStateFail => "ErrChangeProfessionStateFail",
            Self::ErrChangeProfessionCdFail => "ErrChangeProfessionCDFail",
            Self::ErrProfessionSkinNotActive => "ErrProfessionSkinNotActive",
            Self::ErrProfessionSkinActive => "ErrProfessionSkinActive",
            Self::ErrProfessionNotUseSkin => "ErrProfessionNotUseSkin",
            Self::ErrProfessionSkillSkinActive => "ErrProfessionSkillSkinActive",
            Self::ErrProfessionSkillSkinNotActive => "ErrProfessionSkillSkinNotActive",
            Self::ErrProfessionSkillNotActive => "ErrProfessionSkillNotActive",
            Self::ErrCharOffline => "ErrCharOffline",
            Self::ErrUserDataBaseError => "ErrUserDataBaseError",
            Self::ErrCharGetFail => "ErrCharGetFail",
            Self::ErrAlreadyAlive => "ErrAlreadyAlive",
            Self::ErrReviveParam => "ErrReviveParam",
            Self::ErrStateIllegal => "ErrStateIllegal",
            Self::ErrStateNoChange => "ErrStateNoChange",
            Self::ErrReviveConsumeNotEnough => "ErrReviveConsumeNotEnough",
            Self::ErrReviveByOtherForbid => "ErrReviveByOtherForbid",
            Self::ErrReviveTimeNotArrived => "ErrReviveTimeNotArrived",
            Self::ErrReviveBossBattle => "ErrReviveBossBattle",
            Self::ErrReviveCountLimit => "ErrReviveCountLimit",
            Self::ErrReviveInDeadTp => "ErrReviveInDeadTp",
            Self::ErrDungeonPlayTypeError => "ErrDungeonPlayTypeError",
            Self::ErrDungeonNotExist => "ErrDungeonNotExist",
            Self::ErrDungeonCreateError => "ErrDungeonCreateError",
            Self::ErrCantChangeDungeon => "ErrCantChangeDungeon",
            Self::ErrDungeonLock => "ErrDungeonLock",
            Self::ErrPioneerFail => "ErrPioneerFail",
            Self::ErrAwardFail => "ErrAwardFail",
            Self::ErrGsNotEnough => "ErrGsNotEnough",
            Self::ErrQuestNotCompleted => "ErrQuestNotCompleted",
            Self::ErrDungeonNotClear => "ErrDungeonNotClear",
            Self::ErrConditionNotExist => "ErrConditionNotExist",
            Self::ErrAwardReceived => "ErrAwardReceived",
            Self::ErrCantRepeatedPlay => "ErrCantRepeatedPlay",
            Self::ErrNeedPassPreRoom => "ErrNeedPassPreRoom",
            Self::ErrDungeonEnterCountLimit => "ErrDungeonEnterCountLimit",
            Self::ErrDungeonScoreError => "ErrDungeonScoreError",
            Self::ErrDungeonRepeatedVote => "ErrDungeonRepeatedVote",
            Self::ErrDungeonChallengeAwardState => "ErrDungeonChallengeAwardState",
            Self::ErrDungeonChallengeAffixNotFound => "ErrDungeonChallengeAffixNotFound",
            Self::ErrDungeonStateNotActive => "ErrDungeonStateNotActive",
            Self::ErrDungeonCantVoteSelf => "ErrDungeonCantVoteSelf",
            Self::ErrDungeonPlayerNotEnough => "ErrDungeonPlayerNotEnough",
            Self::ErrDungeonPlayerFull => "ErrDungeonPlayerFull",
            Self::ErrDungeonCantHeroKey => "ErrDungeonCantHeroKey",
            Self::ErrDungeonNotSettlement => "ErrDungeonNotSettlement",
            Self::ErrDungeonNotFindRollItem => "ErrDungeonNotFindRollItem",
            Self::ErrDungeonCantRoll => "ErrDungeonCantRoll",
            Self::ErrDungeonRollFinish => "ErrDungeonRollFinish",
            Self::ErrDungeonSelectError => "ErrDungeonSelectError",
            Self::ErrDungeonAiModeError => "ErrDungeonAiModeError",
            Self::ErrDungeonTargetNotFinish => "ErrDungeonTargetNotFinish",
            Self::ErrDungeonTargetBeAward => "ErrDungeonTargetBeAward",
            Self::ErrDungeonSinglePlayerMore => "ErrDungeonSinglePlayerMore",
            Self::ErrDungeonAiGroupNotEnough => "ErrDungeonAiGroupNotEnough",
            Self::ErrDungeonNoPass => "ErrDungeonNoPass",
            Self::ErrDungeonCloseSceneId => "ErrDungeonCloseSceneId",
            Self::ErrDungeonEnterTypeError => "ErrDungeonEnterTypeError",
            Self::ErrDungeonActorCount => "ErrDungeonActorCount",
            Self::ErrDungeonDiffLocked => "ErrDungeonDiffLocked",
            Self::ErrDungeonPreBattleVoteCd => "ErrDungeonPreBattleVoteCd",
            Self::ErrDungeonBossInvalid => "ErrDungeonBossInvalid",
            Self::ErrDungeonNoUser => "ErrDungeonNoUser",
            Self::ErrDungeonUserInvalid => "ErrDungeonUserInvalid",
            Self::ErrDungeonAwardualification => "ErrDungeonAwardualification",
            Self::ErrDungeonAwardTriesLimit => "ErrDungeonAwardTriesLimit",
            Self::ErrFashionIsLimit => "ErrFashionIsLimit",
            Self::ErrFashionNotFound => "ErrFashionNotFound",
            Self::ErrFashionSlotEmpty => "ErrFashionSlotEmpty",
            Self::ErrFashionIdNotFound => "ErrFashionIDNotFound",
            Self::ErrFashionLock => "ErrFashionLock",
            Self::ErrFashCollectionAwardAlread => "ErrFashCollectionAwardAlread",
            Self::ErrFashCollectionScoreNotEnough => "ErrFashCollectionScoreNotEnough",
            Self::ErrFashCollectionAwardAlreadMonth => {
                "ErrFashCollectionAwardAlreadMonth"
            }
            Self::ErrFashionAlreadUnlock => "ErrFashionAlreadUnlock",
            Self::ErrFashionAdvanceNotExist => "ErrFashionAdvanceNotExist",
            Self::ErrFashionBaseNotUnlock => "ErrFashionBaseNotUnlock",
            Self::ErrFashionAdvanceAlreadyUnlock => "ErrFashionAdvanceAlreadyUnlock",
            Self::ErrCameraNoExistAlbum => "ErrCameraNoExistAlbum",
            Self::ErrCameraBeyondPhotoNum => "ErrCameraBeyondPhotoNum",
            Self::ErrCameraBeyondAlumNum => "ErrCameraBeyondAlumNum",
            Self::ErrCameraNoAccessRight => "ErrCameraNoAccessRight",
            Self::ErrCameraNoExistPhoto => "ErrCameraNoExistPhoto",
            Self::ErrCameraBeyondWordNum => "ErrCameraBeyondWordNum",
            Self::ErrCameraPhotoNoInAlbum => "ErrCameraPhotoNoInAlbum",
            Self::ErrCameraInnerError => "ErrCameraInnerError",
            Self::ErrCameraIllegalRight => "ErrCameraIllegalRight",
            Self::ErrCameraNoExistChar => "ErrCameraNoExistChar",
            Self::ErrCameraNoDelCloudAlbum => "ErrCameraNoDelCloudAlbum",
            Self::ErrCameraBeyondMaxURlLen => "ErrCameraBeyondMaxURlLen",
            Self::ErrCameraBeyondMaxXmlLen => "ErrCameraBeyondMaxXMLLen",
            Self::ErrCameraBeyondMaxNameLen => "ErrCameraBeyondMaxNameLen",
            Self::ErrCameraIllegalUrl => "ErrCameraIllegalUrl",
            Self::ErrCameraRenderInfoEmpty => "ErrCameraRenderInfoEmpty",
            Self::ErrCameraBeyondPhotoMaxSize => "ErrCameraBeyondPhotoMaxSize",
            Self::ErrCameraIllegalPictureType => "ErrCameraIllegalPictureType",
            Self::ErrCameraTypeRepeated => "ErrCameraTypeRepeated",
            Self::ErrCameraWithoutOriginal => "ErrCameraWithoutOriginal",
            Self::ErrCameraWithoutThumbnailOrRender => {
                "ErrCameraWithoutThumbnailOrRender"
            }
            Self::ErrCameraPhotoNameEmpty => "ErrCameraPhotoNameEmpty",
            Self::ErrCameraPhotoNameOutMaxLen => "ErrCameraPhotoNameOutMaxLen",
            Self::ErrCameraAlbumNameEmpty => "ErrCameraAlbumNameEmpty",
            Self::ErrCameraPhotoHasDel => "ErrCameraPhotoHasDel",
            Self::ErrCameraSysInnerError => "ErrCameraSysInnerError",
            Self::ErrCameraIllegalPictureId => "ErrCameraIllegalPictureId",
            Self::ErrCameraBeyondMaxExtraLen => "ErrCameraBeyondMaxExtraLen",
            Self::ErrCameraNoIncludeOriginal => "ErrCameraNoIncludeOriginal",
            Self::ErrCameraNoDealingPhoto => "ErrCameraNoDealingPhoto",
            Self::ErrCameraNoDealingPhotoType => "ErrCameraNoDealingPhotoType",
            Self::ErrCameraNoAnyAlbum => "ErrCameraNoAnyAlbum",
            Self::ErrCameraNoPassReview => "ErrCameraNoPassReview",
            Self::ErrCameraPhotoMissImage => "ErrCameraPhotoMissImage",
            Self::ErrCameraWithoutThumbnail => "ErrCameraWithoutThumbnail",
            Self::ErrCameraBeyondMaxUploadTimes => "ErrCameraBeyondMaxUploadTimes",
            Self::ErrInvalidLifeProfessionId => "ErrInvalidLifeProfessionId",
            Self::ErrLifeProfessionIsUnlock => "ErrLifeProfessionIsUnlock",
            Self::ErrLifeProfessionMaxLevel => "ErrLifeProfessionMaxLevel",
            Self::ErrLifeProfessionLevelNotEnough => "ErrLifeProfessionLevelNotEnough",
            Self::ErrLifeProfessionLevelRewardGot => "ErrLifeProfessionLevelRewardGot",
            Self::ErrInvalidLifeProfessionSpecializationId => {
                "ErrInvalidLifeProfessionSpecializationId"
            }
            Self::ErrLifeProfessionSpecializationNotEnough => {
                "ErrLifeProfessionSpecializationNotEnough"
            }
            Self::ErrLifeProfessionSpecializationUpgradeError => {
                "ErrLifeProfessionSpecializationUpgradeError"
            }
            Self::ErrLifeProfessionPointNotEnough => "ErrLifeProfessionPointNotEnough",
            Self::ErrInvalidLifeProfessionTargetId => "ErrInvalidLifeProfessionTargetId",
            Self::ErrLifeProfessionTargetNotEnough => "ErrLifeProfessionTargetNotEnough",
            Self::ErrLifeProfessionRewardCanNotGet => "ErrLifeProfessionRewardCanNotGet",
            Self::ErrLifeProfessionEnergyChange => "ErrLifeProfessionEnergyChange",
            Self::ErrLifeProfessionRecipeIsUnlock => "ErrLifeProfessionRecipeIsUnlock",
            Self::ErrLifeProfessionRecipeNotExist => "ErrLifeProfessionRecipeNotExist",
            Self::ErrLifeProfessionRecipeNotUnlock => "ErrLifeProfessionRecipeNotUnlock",
            Self::ErrLifeProfessionMaxRdRecipeCount => {
                "ErrLifeProfessionMaxRDRecipeCount"
            }
            Self::ErrLifeProfessionWorkingNotEnd => "ErrLifeProfessionWorkingNotEnd",
            Self::ErrLifeProfessionAlreadyWorking => "ErrLifeProfessionAlreadyWorking",
            Self::ErrLifeProfessionNotWorking => "ErrLifeProfessionNotWorking",
            Self::ErrLifeProfessionWorkingIsEnd => "ErrLifeProfessionWorkingIsEnd",
            Self::ErrLifeProfessionUnActiveSpecialization => {
                "ErrLifeProfessionUnActiveSpecialization"
            }
            Self::ErrCurLevelConfigNotExist => "ErrCurLevelConfigNotExist",
            Self::ErrNeedBreakthrough => "ErrNeedBreakthrough",
            Self::ErrExperienceConfigNotExist => "ErrExperienceConfigNotExist",
            Self::ErrExperienceMismatch => "ErrExperienceMismatch",
            Self::ErrNotNeedToBreakthrough => "ErrNotNeedToBreakthrough",
            Self::ErrConsumeConfigError => "ErrConsumeConfigError",
            Self::ErrSkillNotExist => "ErrSkillNotExist",
            Self::ErrSkillLevelMax => "ErrSkillLevelMax",
            Self::ErrSkillLevelNotExist => "ErrSkillLevelNotExist",
            Self::ErrSkillConfigError => "ErrSkillConfigError",
            Self::ErrStarNotExist => "ErrStarNotExist",
            Self::ErrMaxStar => "ErrMaxStar",
            Self::ErrMaxLevel => "ErrMaxLevel",
            Self::ErrSkillLevelNotEnough => "ErrSkillLevelNotEnough",
            Self::ErrCanNotChangeActionState => "ErrCanNotChangeActionState",
            Self::ErrActionNotExist => "ErrActionNotExist",
            Self::ErrIsInteracting => "ErrIsInteracting",
            Self::ErrState => "ErrState",
            Self::ErrRequestExpired => "ErrRequestExpired",
            Self::ErrStateSetFailed => "ErrStateSetFailed",
            Self::ErrCollectIdError => "ErrCollectIdError",
            Self::ErrCollectStateFailed => "ErrCollectStateFailed",
            Self::ErrCollectActorErr => "ErrCollectActorErr",
            Self::ErrCollectOutRange => "ErrCollectOutRange",
            Self::ErrCollectConditionEquip => "ErrCollectConditionEquip",
            Self::ErrCollectConditionQuest => "ErrCollectConditionQuest",
            Self::ErrAlreadyCollected => "ErrAlreadyCollected",
            Self::ErrMailGetFailed => "ErrMailGetFailed",
            Self::ErrMailIllegality => "ErrMailIllegality",
            Self::ErrMailIsGet => "ErrMailIsGet",
            Self::ErrMailIsDel => "ErrMailIsDel",
            Self::ErrMailAcceptorEmpty => "ErrMailAcceptorEmpty",
            Self::ErrMailTokenInvalid => "ErrMailTokenInvalid",
            Self::ErrUnRegisterType => "ErrUnRegisterType",
            Self::ErrIndexNotFound => "ErrIndexNotFound",
            Self::ErrCantOpenTreasureBox => "ErrCantOpenTreasureBox",
            Self::ErrPersonalStateEnd => "ErrPersonalStateEnd",
            Self::ErrPersonalObjectStatus => "ErrPersonalObjectStatus",
            Self::ErrExp => "ErrExp",
            Self::ErrLevel => "ErrLevel",
            Self::ErrAward => "ErrAward",
            Self::ErrReceivedLevelAward => "ErrReceivedLevelAward",
            Self::ErrLevelNotEnough => "ErrLevelNotEnough",
            Self::ErrRoleLevelNoRewards => "ErrRoleLevelNoRewards",
            Self::ErrUnionNotHaveLimit => "ErrUnionNotHaveLimit",
            Self::ErrUnionIsNotMember => "ErrUnionIsNotMember",
            Self::ErrUnionOfficialNotExits => "ErrUnionOfficialNotExits",
            Self::ErrUnionOfficialTooMany => "ErrUnionOfficialTooMany",
            Self::ErrUnionHas => "ErrUnionHas",
            Self::ErrUnionReqCd => "ErrUnionReqCd",
            Self::ErrUnionReqHas => "ErrUnionReqHas",
            Self::ErrUnionFull => "ErrUnionFull",
            Self::ErrUnionFailed => "ErrUnionFailed",
            Self::ErrUnionNameWrongful => "ErrUnionNameWrongful",
            Self::ErrUnionNameUsed => "ErrUnionNameUsed",
            Self::ErrUnionNameOccupied => "ErrUnionNameOccupied",
            Self::ErrApplyMax => "ErrApplyMax",
            Self::ErrUnionChangeNameCd => "ErrUnionChangeNameCD",
            Self::ErrUnionNameSizeError => "ErrUnionNameSizeError",
            Self::ErrDeclarationSize => "ErrDeclarationSize",
            Self::ErrDeclarationError => "ErrDeclarationError",
            Self::ErrOfficialNameRepeat => "ErrOfficialNameRepeat",
            Self::ErrDeclarationCd => "ErrDeclarationCd",
            Self::ErrUnionInfoCd => "ErrUnionInfoCd",
            Self::ErrUnionNotExist => "ErrUnionNotExist",
            Self::ErrUnionIllegalConditionType => "ErrUnionIllegalConditionType",
            Self::ErrUnionRecruitSloganTooLong => "ErrUnionRecruitSloganTooLong",
            Self::ErrUnionRecruitDescriptionTooLong => {
                "ErrUnionRecruitDescriptionTooLong"
            }
            Self::ErrUnionCreateTooOften => "ErrUnionCreateTooOften",
            Self::ErrUnionTagNoExist => "ErrUnionTagNoExist",
            Self::ErrUnionIconTooMuch => "ErrUnionIconTooMuch",
            Self::ErrUnionGetListCd => "ErrUnionGetListCd",
            Self::ErrUnionBatchSearchUnionIdsTooMuch => {
                "ErrUnionBatchSearchUnionIdsTooMuch"
            }
            Self::ErrUnionBatchSearchCd => "ErrUnionBatchSearchCd",
            Self::ErrUnionGetCollectedIdsCd => "ErrUnionGetCollectedIdsCd",
            Self::ErrUnionBeyondMaxCollectedNum => "ErrUnionBeyondMaxCollectedNum",
            Self::ErrUnionIdHasCollected => "ErrUnionIdHasCollected",
            Self::ErrUnionIdNoCollected => "ErrUnionIdNoCollected",
            Self::ErrUnionActiveValueNotEnough => "ErrUnionActiveValueNotEnough",
            Self::ErrUnionIllegalActiveId => "ErrUnionIllegalActiveId",
            Self::ErrUnionTooShortForAwards => "ErrUnionTooShortForAwards",
            Self::ErrUnionHasActiveAwards => "ErrUnionHasActiveAwards",
            Self::ErrUnionNoJoin => "ErrUnionNoJoin",
            Self::ErrUnionOnlyEnterSelf => "ErrUnionOnlyEnterSelf",
            Self::ErrUnionNoUnlockScene => "ErrUnionNoUnlockScene",
            Self::ErrUnionBuildingMaxLevel => "ErrUnionBuildingMaxLevel",
            Self::ErrUnionBuildingUpgrading => "ErrUnionBuildingUpgrading",
            Self::ErrUnionBuildingUpgradeNoFinish => "ErrUnionBuildingUpgradeNoFinish",
            Self::ErrUnionPrefixBuildNoMeet => "ErrUnionPrefixBuildNoMeet",
            Self::ErrUnionExperienceNoEnough => "ErrUnionExperienceNoEnough",
            Self::ErrUnionMoneyNoEnough => "ErrUnionMoneyNoEnough",
            Self::ErrUnionBuildingNoUpgrading => "ErrUnionBuildingNoUpgrading",
            Self::ErrUnionSpeedUpItemNoEnough => "ErrUnionSpeedUpItemNoEnough",
            Self::ErrUnionSpeedUpTimesOut => "ErrUnionSpeedUpTimesOut",
            Self::ErrUnionTryLater => "ErrUnionTryLater",
            Self::ErrUnionSpeedUpLevelError => "ErrUnionSpeedUpLevelError",
            Self::ErrUnionUpgradeHasCompleted => "ErrUnionUpgradeHasCompleted",
            Self::ErrUnionIllegalBuildIdLv => "ErrUnionIllegalBuildIdLv",
            Self::ErrUnionBeyMaxCount => "ErrUnionBeyMaxCount",
            Self::ErrUnionUserNoApply => "ErrUnionUserNoApply",
            Self::ErrUnionNoOneKeyNoMuch => "ErrUnionNoOneKeyNoMuch",
            Self::ErrUnionActivityNotStart => "ErrUnionActivityNotStart",
            Self::ErrUnionActivityNotProgress => "ErrUnionActivityNotProgress",
            Self::ErrUnionActivityAwardGet => "ErrUnionActivityAwardGet",
            Self::ErrUnionActivityNotEnjoy => "ErrUnionActivityNotEnjoy",
            Self::ErrUnionCreateTimeTooShort => "ErrUnionCreateTimeTooShort",
            Self::ErrUnionFunctionLock => "ErrUnionFunctionLock",
            Self::ErrUnionEScreenLock => "ErrUnionEScreenLock",
            Self::ErrUnionEScreenPositionLock => "ErrUnionEScreenPositionLock",
            Self::ErrUnionEScreenNoSet => "ErrUnionEScreenNoSet",
            Self::ErrUnionEScreenPositionNoSet => "ErrUnionEScreenPositionNoSet",
            Self::ErrUnionEffectGridLock => "ErrUnionEffectGridLock",
            Self::ErrUnionEffectIdLock => "ErrUnionEffectIdLock",
            Self::ErrUnionEffectPosNoSet => "ErrUnionEffectPosNoSet",
            Self::ErrUnionEffectPosHasEnd => "ErrUnionEffectPosHasEnd",
            Self::ErrUnionCrowFuncHasEnd => "ErrUnionCrowFuncHasEnd",
            Self::ErrUnionCrowFuncPosHasUsed => "ErrUnionCrowFuncPosHasUsed",
            Self::ErrUnionCrowFuncHasJoined => "ErrUnionCrowFuncHasJoined",
            Self::ErrUnionCrowFuncNoBegin => "ErrUnionCrowFuncNoBegin",
            Self::ErrUnionNoFinishBaseBuilding => "ErrUnionNoFinishBaseBuilding",
            Self::ErrUnionCrowFuncIllegalFuncPos => "ErrUnionCrowFuncIllegalFuncPos",
            Self::ErrUnionEScreenBeyondMaxTimes => "ErrUnionEScreenBeyondMaxTimes",
            Self::ErrUnionTargetFunctionLock => "ErrUnionTargetFunctionLock",
            Self::ErrUnionNoMeet => "ErrUnionNoMeet",
            Self::ErrUnionActivityAwardCd => "ErrUnionActivityAwardCd",
            Self::ErrUnionManagerNoKicked => "ErrUnionManagerNoKicked",
            Self::ErrUnionDanceNoBegin => "ErrUnionDanceNoBegin",
            Self::ErrUnionDanceEnd => "ErrUnionDanceEnd",
            Self::ErrUnionDanceDrawnBox => "ErrUnionDanceDrawnBox",
            Self::ErrUnionDanceBoxDrawn => "ErrUnionDanceBoxDrawn",
            Self::ErrUnionDanceNoDanceId => "ErrUnionDanceNoDanceId",
            Self::ErrUnionNoJoinDance => "ErrUnionNoJoinDance",
            Self::ErrUnionDanceNoDancing => "ErrUnionDanceNoDancing",
            Self::ErrUnionRejectInvite => "ErrUnionRejectInvite",
            Self::ErrUnionActivityHuntEnd => "ErrUnionActivityHuntEnd",
            Self::ErrUnionApplyListFull => "ErrUnionApplyListFull",
            Self::ErrUionApplyListExist => "ErrUionApplyListExist",
            Self::ErrUnionGroupIvalid => "ErrUnionGroupIvalid",
            Self::ErrRepeatedRequest => "ErrRepeatedRequest",
            Self::ErrHasBeenBlackened => "ErrHasBeenBlackened",
            Self::ErrNotFoundCharInfo => "ErrNotFoundCharInfo",
            Self::ErrInner => "ErrInner",
            Self::ErrParam => "ErrParam",
            Self::ErrSetShowPicture => "ErrSetShowPicture",
            Self::ErrSetSignature => "ErrSetSignature",
            Self::ErrSetHobbyMark => "ErrSetHobbyMark",
            Self::ErrSetTimeMark => "ErrSetTimeMark",
            Self::ErrSetRemind => "ErrSetRemind",
            Self::ErrSetTop => "ErrSetTop",
            Self::ErrAddFriend => "ErrAddFriend",
            Self::ErrSetProcessed => "ErrSetProcessed",
            Self::ErrSetRemark => "ErrSetRemark",
            Self::ErrDeleteFriend => "ErrDeleteFriend",
            Self::ErrNotFoundGroup => "ErrNotFoundGroup",
            Self::ErrNotExistInGroup => "ErrNotExistInGroup",
            Self::ErrChangeGroup => "ErrChangeGroup",
            Self::ErrPersonalState => "ErrPersonalState",
            Self::ErrOtherFriendMax => "ErrOtherFriendMax",
            Self::ErrCurFriendMax => "ErrCurFriendMax",
            Self::ErrConfig => "ErrConfig",
            Self::ErrAlreadyFriend => "ErrAlreadyFriend",
            Self::ErrSearchSelf => "ErrSearchSelf",
            Self::ErrSuggestionCd => "ErrSuggestionCd",
            Self::ErrGroupMax => "ErrGroupMax",
            Self::ErrGroupNotExist => "ErrGroupNotExist",
            Self::ErrGroupNameEmpty => "ErrGroupNameEmpty",
            Self::ErrIllegalCharacter => "ErrIllegalCharacter",
            Self::ErrStringMax => "ErrStringMax",
            Self::ErrOtherApplicationMax => "ErrOtherApplicationMax",
            Self::ErrFriendlinessAwardHasRecord => "ErrFriendlinessAwardHasRecord",
            Self::ErrFriendlinessLevelLowAwardLevel => {
                "ErrFriendlinessLevelLowAwardLevel"
            }
            Self::ErrFriendBeyondAllFriendNum => "ErrFriendBeyondAllFriendNum",
            Self::ErrFriendIsNoUserFriend => "ErrFriendIsNoUserFriend",
            Self::ErrFriendlinessIllegalAwardLevel => "ErrFriendlinessIllegalAwardLevel",
            Self::ErrFriendlinessLevelAwardIsEmpty => "ErrFriendlinessLevelAwardIsEmpty",
            Self::ErrFriendBeBlackenedByTarget => "ErrFriendBeBlackenedByTarget",
            Self::ErrFriendApplyEachOther => "ErrFriendApplyEachOther",
            Self::ErrFriendCallBySmallerCharId => "ErrFriendCallBySmallerCharId",
            Self::ErrFriendCallByBiggerCharId => "ErrFriendCallByBiggerCharId",
            Self::ErrFriendBeBlackenedBySmaller => "ErrFriendBeBlackenedBySmaller",
            Self::ErrFriendBeBlackenedByBigger => "ErrFriendBeBlackenedByBigger",
            Self::ErrFriendNoApply => "ErrFriendNoApply",
            Self::ErrFriendApplySelf => "ErrFriendApplySelf",
            Self::ErrUserNameFormat => "ErrUserNameFormat",
            Self::ErrFriendGetBaseTooOften => "ErrFriendGetBaseTooOften",
            Self::ErrFriendOnlyGetSelfBaseInfo => "ErrFriendOnlyGetSelfBaseInfo",
            Self::ErrActorGetFailed => "ErrActorGetFailed",
            Self::ErrPivotIsActive => "ErrPivotIsActive",
            Self::ErrPivotIsNotActive => "ErrPivotIsNotActive",
            Self::ErrBreakPointIsGet => "ErrBreakPointIsGet",
            Self::ErrActorIsNotPivot => "ErrActorIsNotPivot",
            Self::ErrActorIsNotBreakPoint => "ErrActorIsNotBreakPoint",
            Self::ErrActorIsBreakPointNotFull => "ErrActorIsBreakPointNotFull",
            Self::ErrPivotRewardIsGiven => "ErrPivotRewardIsGiven",
            Self::ErrNotInsight => "ErrNotInsight",
            Self::ErrLearnSkillFail => "ErrLearnSkillFail",
            Self::ErrRemoveSkillFail => "ErrRemoveSkillFail",
            Self::ErrUpdateSkillFail => "ErrUpdateSkillFail",
            Self::ErrSkillOperatorType => "ErrSkillOperatorType",
            Self::ErrContainerOperator => "ErrContainerOperator",
            Self::ErrExchangeFail => "ErrExchangeFail",
            Self::ErrExchangeFailInCombat => "ErrExchangeFailInCombat",
            Self::ErrAvatarBeyondMaxPictureSize => "ErrAvatarBeyondMaxPictureSize",
            Self::ErrGetTokenFailed => "ErrGetTokenFailed",
            Self::ErrPictureVerifyFailed => "ErrPictureVerifyFailed",
            Self::ErrPictureIllegalType => "ErrPictureIllegalType",
            Self::ErrPictureErrorInfo => "ErrPictureErrorInfo",
            Self::ErrPictureSizeInconsistent => "ErrPictureSizeInconsistent",
            Self::ErrPictureFuncTypeIllegal => "ErrPictureFuncTypeIllegal",
            Self::ErrPictureCallBackJudgeIllegal => "ErrPictureCallBackJudgeIllegal",
            Self::ErrPictureVerifyNoPass => "ErrPictureVerifyNoPass",
            Self::ErrPictureVerifyBackParamIllegal => "ErrPictureVerifyBackParamIllegal",
            Self::ErrPictureCallBackParamIllegal => "ErrPictureCallBackParamIllegal",
            Self::ErrPictureIllegalId => "ErrPictureIllegalId",
            Self::ErrPictureCosErrors => "ErrPictureCosErrors",
            Self::ErrPictureInnerSysErr => "ErrPictureInnerSysErr",
            Self::ErrPictureNoSetEnvCosSecretId => "ErrPictureNoSetEnvCosSecretId",
            Self::ErrPictureNoSetEnvCosSecretKey => "ErrPictureNoSetEnvCosSecretKey",
            Self::ErrPictureCheckInMachineLocked => "ErrPictureCheckInMachineLocked",
            Self::ErrPictureNoTryOutItem => "ErrPictureNoTryOutItem",
            Self::ErrPictureNoUploadItem => "ErrPictureNoUploadItem",
            Self::ErrPictureNoUnion => "ErrPictureNoUnion",
            Self::ErrNameSizeError => "ErrNameSizeError",
            Self::ErrSensitiveContent => "ErrSensitiveContent",
            Self::ErrChangeNameFail => "ErrChangeNameFail",
            Self::ErrChangeNameCardNotEnough => "ErrChangeNameCardNotEnough",
            Self::ErrChangeSameName => "ErrChangeSameName",
            Self::ErrCheckMuteWordsFailed => "ErrCheckMuteWordsFailed",
            Self::ErrCheckMuteWordsEmpty => "ErrCheckMuteWordsEmpty",
            Self::ErrChangeShowIdFail => "ErrChangeShowIdFail",
            Self::ErrChangeShowIdDuplicated => "ErrChangeShowIdDuplicated",
            Self::ErrChangeShowIdCardNotEnough => "ErrChangeShowIdCardNotEnough",
            Self::ErrFaceItemLock => "ErrFaceItemLock",
            Self::ErrFaceItemGender => "ErrFaceItemGender",
            Self::ErrFaceNoUploading => "ErrFaceNoUploading",
            Self::ErrFaceNoSupportFileSuffix => "ErrFaceNoSupportFileSuffix",
            Self::ErrFaceFileSuffixEmpty => "ErrFaceFileSuffixEmpty",
            Self::ErrFaceIllegalCosKey => "ErrFaceIllegalCosKey",
            Self::ErrFaceParseSuffixFailed => "ErrFaceParseSuffixFailed",
            Self::ErrFaceParseShortGuidFailed => "ErrFaceParseShortGuidFailed",
            Self::ErrProficiencyNeedUnlock => "ErrProficiencyNeedUnlock",
            Self::ErrProficiencyUnlock => "ErrProficiencyUnlock",
            Self::ErrUnlockItemNotEnough => "ErrUnlockItemNotEnough",
            Self::ErrTaskNotFinish => "ErrTaskNotFinish",
            Self::ErrStickerAwardIsGet => "ErrStickerAwardIsGet",
            Self::ErrBookAwardIsGet => "ErrBookAwardIsGet",
            Self::ErrInCd => "ErrInCd",
            Self::ErrMoneyNotEnough => "ErrMoneyNotEnough",
            Self::ErrShopItemCantBuy => "ErrShopItemCantBuy",
            Self::ErrShopBuyBusy => "ErrShopBuyBusy",
            Self::ErrPaymentConfigNotFound => "ErrPaymentConfigNotFound",
            Self::ErrRefreshShopCountExceed => "ErrRefreshShopCountExceed",
            Self::ErrShopCouponNotEnough => "ErrShopCouponNotEnough",
            Self::ErrShopCouponLimitNum => "ErrShopCouponLimitNum",
            Self::ErrShopCantBuyNoPrice => "ErrShopCantBuyNoPrice",
            Self::ErrNotFoundMonster => "ErrNotFoundMonster",
            Self::ErrNotMonster => "ErrNotMonster",
            Self::ErrMonsterUnlockExist => "ErrMonsterUnlockExist",
            Self::ErrMonsterAwardIsGet => "ErrMonsterAwardIsGet",
            Self::ErrMonsterTargetNotFinish => "ErrMonsterTargetNotFinish",
            Self::ErrDropTypeNotSupport => "ErrDropTypeNotSupport",
            Self::ErrCounterNotEnough => "ErrCounterNotEnough",
            Self::ErrDropItemAlreadyPicked => "ErrDropItemAlreadyPicked",
            Self::ErrInteractionDoing => "ErrInteractionDoing",
            Self::ErrInteractionCondition => "ErrInteractionCondition",
            Self::ErrInteractionNotMore => "ErrInteractionNotMore",
            Self::ErrInteractionExistPos => "ErrInteractionExistPos",
            Self::ErrInteractionNotExist => "ErrInteractionNotExist",
            Self::ErrInteractionEntityNotExist => "ErrInteractionEntityNotExist",
            Self::ErrInteractionHandleNotExist => "ErrInteractionHandleNotExist",
            Self::ErrInteractionType => "ErrInteractionType",
            Self::ErrInteractionBan => "ErrInteractionBan",
            Self::ErrInteractionConfig => "ErrInteractionConfig",
            Self::ErrInteractionNotOneself => "ErrInteractionNotOneself",
            Self::ErrInteractionDistance => "ErrInteractionDistance",
            Self::ErrShowPieceIllegalPieceType => "ErrShowPieceIllegalPieceType",
            Self::ErrShowPieceIllegalPieceId => "ErrShowPieceIllegalPieceId",
            Self::ErrShowPieceNoInOftenUseList => "ErrShowPieceNoInOftenUseList",
            Self::ErrShowPieceNoUnlockList => "ErrShowPieceNoUnlockList",
            Self::ErrShowPieceRoulettePositionNoSet => {
                "ErrShowPieceRoulettePositionNoSet"
            }
            Self::ErrShowPieceBeyondOftenUseMaxLen => "ErrShowPieceBeyondOftenUseMaxLen",
            Self::ErrShowPieceBeyondOftenRoulettePositionNum => {
                "ErrShowPieceBeyondOftenRoulettePositionNum"
            }
            Self::ErrShowPieceNoCommonPiece => "ErrShowPieceNoCommonPiece",
            Self::ErrShowPieceNoTakeOn => "ErrShowPieceNoTakeOn",
            Self::ErrProfessionActivated => "ErrProfessionActivated",
            Self::ErrProfessionNotHas => "ErrProfessionNotHas",
            Self::ErrProfessionSlotErr => "ErrProfessionSlotErr",
            Self::ErrProfessionRemoveErr => "ErrProfessionRemoveErr",
            Self::ErrProfessionChangePlanFail => "ErrProfessionChangePlanFail",
            Self::ErrProfessionStarConfigNotExist => "ErrProfessionStarConfigNotExist",
            Self::ErrProfessionStarNodeUnlock => "ErrProfessionStarNodeUnlock",
            Self::ErrProfessionStarNodeNotUnlock => "ErrProfessionStarNodeNotUnlock",
            Self::ErrProfessionReplaceSkillNotExist => {
                "ErrProfessionReplaceSkillNotExist"
            }
            Self::ErrProfessionUpgradeNotGreaterCurLevel => {
                "ErrProfessionUpgradeNotGreaterCurLevel"
            }
            Self::ErrProfessionProfessionBeForged => "ErrProfessionProfessionBeForged",
            Self::ErrProfessionSlotTwoNotUnlock => "ErrProfessionSlotTwoNotUnlock",
            Self::ErrProfessionSkillAlreadyActive => "ErrProfessionSkillAlreadyActive",
            Self::ErrProfessionSkillRemodelLevelWrong => {
                "ErrProfessionSkillRemodelLevelWrong"
            }
            Self::ErrAoyiSkillAlreadyActive => "ErrAoyiSkillAlreadyActive",
            Self::ErrAoyiSkillRemodelConfigNotExist => {
                "ErrAoyiSkillRemodelConfigNotExist"
            }
            Self::ErrAoyiSkillRemodelLevelWrong => "ErrAoyiSkillRemodelLevelWrong",
            Self::ErrProfessionEquipInCombat => "ErrProfessionEquipInCombat",
            Self::ErrProfessionSwitchInCombat => "ErrProfessionSwitchInCombat",
            Self::ErrProfessionDungeonNotAllowSwitch => {
                "ErrProfessionDungeonNotAllowSwitch"
            }
            Self::ErrTalentIllegalTalentPoolId => "ErrTalentIllegalTalentPoolId",
            Self::ErrTalentBeyondCurTalentMaxPlanNum => {
                "ErrTalentBeyondCurTalentMaxPlanNum"
            }
            Self::ErrTalentPoolNoActive => "ErrTalentPoolNoActive",
            Self::ErrTalentPlanNoActive => "ErrTalentPlanNoActive",
            Self::ErrTalentIllegalTalentId => "ErrTalentIllegalTalentId",
            Self::ErrTalentTalentHasUnlocked => "ErrTalentTalentHasUnlocked",
            Self::ErrTalentTalentNoUnlocked => "ErrTalentTalentNoUnlocked",
            Self::ErrTalentChangeLvPassiveTalentMoreThanInPool => {
                "ErrTalentChangeLvPassiveTalentMoreThanInPool"
            }
            Self::ErrTalentRepeatedTalentId => "ErrTalentRepeatedTalentId",
            Self::ErrTalentNoPoolPassiveTalent => "ErrTalentNoPoolPassiveTalent",
            Self::ErrTalentTalentPointsNoEnough => "ErrTalentTalentPointsNoEnough",
            Self::ErrTalentPassiveTalentListNoEmpty => {
                "ErrTalentPassiveTalentListNoEmpty"
            }
            Self::ErrTalentIllegalTalentLevel => "ErrTalentIllegalTalentLevel",
            Self::ErrTalentNoMeetUpgradeCondition => "ErrTalentNoMeetUpgradeCondition",
            Self::ErrTalentNoSupportDownLevelNow => "ErrTalentNoSupportDownLevelNow",
            Self::ErrTalentNoMeetPrevTalentLv => "ErrTalentNoMeetPrevTalentLv",
            Self::ErrTalentNoMeetPrevTalentPoint => "ErrTalentNoMeetPrevTalentPoint",
            Self::ErrTalentTreeNodeBdExclusive => "ErrTalentTreeNodeBDExclusive",
            Self::ErrTalentTotalTalentPointNotEnough => {
                "ErrTalentTotalTalentPointNotEnough"
            }
            Self::ErrTalentPreTalentNodeNotActivated => {
                "ErrTalentPreTalentNodeNotActivated"
            }
            Self::ErrTalentResetTalentInCombat => "ErrTalentResetTalentInCombat",
            Self::ErrCookBookNotExist => "ErrCookBookNotExist",
            Self::ErrCookFoodNotEnough => "ErrCookFoodNotEnough",
            Self::ErrCookTypeMore => "ErrCookTypeMore",
            Self::ErrCookCountMore => "ErrCookCountMore",
            Self::ErrCookHasBook => "ErrCookHasBook",
            Self::ErrCookMaterialNotMatch => "ErrCookMaterialNotMatch",
            Self::ErrChatIllegalPrivateChatTarget => "ErrChatIllegalPrivateChatTarget",
            Self::ErrChatInTargetBlockList => "ErrChatInTargetBlockList",
            Self::ErrChatSendMsgBeyondMaxWords => "ErrChatSendMsgBeyondMaxWords",
            Self::ErrChatWorldChannelIdIsZero => "ErrChatWorldChannelIdIsZero",
            Self::ErrChatWorldChannelIdBeyondMaxId => "ErrChatWorldChannelIdBeyondMaxId",
            Self::ErrChatIllegalChannelType => "ErrChatIllegalChannelType",
            Self::ErrChatIllegalMsgType => "ErrChatIllegalMsgType",
            Self::ErrChatNoInGoalChannel => "ErrChatNoInGoalChannel",
            Self::ErrChatNeedConfigIdNotZero => "ErrChatNeedConfigIdNotZero",
            Self::ErrChatNeedMsgTextNotEmpty => "ErrChatNeedMsgTextNotEmpty",
            Self::ErrChatSendCdNoEnd => "ErrChatSendCdNoEnd",
            Self::ErrChatRecordListIsEmpty => "ErrChatRecordListIsEmpty",
            Self::ErrChatTargetNotInPrivateList => "ErrChatTargetNotInPrivateList",
            Self::ErrChatMsgIdMoreThanMaxReadMsgId => "ErrChatMsgIdMoreThanMaxReadMsgId",
            Self::ErrChatBeyondBlockListLimit => "ErrChatBeyondBlockListLimit",
            Self::ErrChatWorldChannelIdBeyondMaxNum => {
                "ErrChatWorldChannelIdBeyondMaxNum"
            }
            Self::ErrChatBeyondMaxRecordId => "ErrChatBeyondMaxRecordId",
            Self::ErrChatNoCreatePrivateSession => "ErrChatNoCreatePrivateSession",
            Self::ErrChatPrivateSessionHasExit => "ErrChatPrivateSessionHasExit",
            Self::ErrChatBeBan => "ErrChatBeBan",
            Self::ErrChatFileIdTooLong => "ErrChatFileIdTooLong",
            Self::ErrChatFileIdEmpty => "ErrChatFileIdEmpty",
            Self::ErrChatMsgInfoEmpty => "ErrChatMsgInfoEmpty",
            Self::ErrChatNoShareChannel => "ErrChatNoShareChannel",
            Self::ErrChatIllegalShareType => "ErrChatIllegalShareType",
            Self::ErrChatIllegalHolderType => "ErrChatIllegalHolderType",
            Self::ErrChatNoSupportShareType => "ErrChatNoSupportShareType",
            Self::ErrChatShareTpeNoChatId => "ErrChatShareTpeNoChatId",
            Self::ErrChatShareNoFishRank => "ErrChatShareNoFishRank",
            Self::ErrChatLevelLimit => "ErrChatLevelLimit",
            Self::ErrChatNoFoundBlockListLimit => "ErrChatNoFoundBlockListLimit",
            Self::ErrTalentModTalentTagNotExist => "ErrTalentModTalentTagNotExist",
            Self::ErrTextCheckForbidden => "ErrTextCheckForbidden",
            Self::ErrTextCheckNoSceneType => "ErrTextCheckNoSceneType",
            Self::ErrTextCheckIllegal => "ErrTextCheckIllegal",
            Self::ErrTextCheckHttpError => "ErrTextCheckHttpError",
            Self::ErrTextCheckTooManyItems => "ErrTextCheckTooManyItems",
            Self::ErrConditionTimerOpen => "ErrConditionTimerOpen",
            Self::ErrConditionOpenServer => "ErrConditionOpenServer",
            Self::ErrSkillDisable => "ErrSkillDisable",
            Self::ErrSkillIsCd => "ErrSkillIsCD",
            Self::ErrSkillMaxPassiveCount => "ErrSkillMaxPassiveCount",
            Self::ErrSkillInit => "ErrSkillInit",
            Self::ErrSkillInfo => "ErrSkillInfo",
            Self::ErrUseSkillFightResInsufficient => "ErrUseSkillFightResInsufficient",
            Self::ErrUseSkillBuffNotEnough => "ErrUseSkillBuffNotEnough",
            Self::ErrUseSkillItemInsufficient => "ErrUseSkillItemInsufficient",
            Self::ErrUseSkillAttrInsufficient => "ErrUseSkillAttrInsufficient",
            Self::ErrUseSkillEnduranceInsufficient => "ErrUseSkillEnduranceInsufficient",
            Self::ErrUseSkillStateChange => "ErrUseSkillStateChange",
            Self::ErrUseSkillClientSkillUuid => "ErrUseSkillClientSkillUuid",
            Self::ErrFightLogicConditionBlockInvalid => {
                "ErrFightLogicConditionBlockInvalid"
            }
            Self::ErrFightLogicActionGroupInvalid => "ErrFightLogicActionGroupInvalid",
            Self::ErrFightLogicConditionNotMatch => "ErrFightLogicConditionNotMatch",
            Self::ErrFightLogicRunDataInvalid => "ErrFightLogicRunDataInvalid",
            Self::ErrSkillStageNotFind => "ErrSkillStageNotFind",
            Self::ErrConditionCfgSize => "ErrConditionCfgSize",
            Self::ErrConditionDissatisfy => "ErrConditionDissatisfy",
            Self::ErrConditionObjectIsNull => "ErrConditionObjectIsNull",
            Self::ErrConditionTypeNotFound => "ErrConditionTypeNotFound",
            Self::ErrConditionEntityDeath => "ErrConditionEntityDeath",
            Self::ErrConditionUnionLevel => "ErrConditionUnionLevel",
            Self::ErrConditionUnionMoney => "ErrConditionUnionMoney",
            Self::ErrConditionNotMeet => "ErrConditionNotMeet",
            Self::ErrConditionNotInShapeShift => "ErrConditionNotInShapeShift",
            Self::ErrSeasonAchievementNoExist => "ErrSeasonAchievementNoExist",
            Self::ErrSeasonAchievementNoFinish => "ErrSeasonAchievementNoFinish",
            Self::ErrSeasonAchievementHasReceived => "ErrSeasonAchievementHasReceived",
            Self::ErrSeasonAchievementPrevIdNoReceived => {
                "ErrSeasonAchievementPrevIdNoReceived"
            }
            Self::ErrSeasonAchievementPrevIdNoExist => {
                "ErrSeasonAchievementPrevIdNoExist"
            }
            Self::ErrSeasonAchievementTargetConfigError => {
                "ErrSeasonAchievementTargetConfigError"
            }
            Self::ErrSeasonRankHasMax => "ErrSeasonRankHasMax",
            Self::ErrSeasonRankHasReceived => "ErrSeasonRankHasReceived",
            Self::ErrSeasonRankNoAchieve => "ErrSeasonRankNoAchieve",
            Self::ErrSeasonRankCurSeasonIdZero => "ErrSeasonRankCurSeasonIdZero",
            Self::ErrSeasonRankNoMeetCondition => "ErrSeasonRankNoMeetCondition",
            Self::ErrSeasonRankSeasonNoSame => "ErrSeasonRankSeasonNoSame",
            Self::ErrBattlePassBuyLevel => "ErrBattlePassBuyLevel",
            Self::ErrBattlePassBuyMaterial => "ErrBattlePassBuyMaterial",
            Self::ErrBattlePassAwardGet => "ErrBattlePassAwardGet",
            Self::ErrBattlePassAwardNotUnlock => "ErrBattlePassAwardNotUnlock",
            Self::ErrBattlePassBuyWeekExpLimit => "ErrBattlePassBuyWeekExpLimit",
            Self::ErrBattlePassLevelError => "ErrBattlePassLevelError",
            Self::ErrNoRefreshTimes => "ErrNoRefreshTimes",
            Self::ErrTargetNotCompleted => "ErrTargetNotCompleted",
            Self::ErrOnlinePeriodTooMore => "ErrOnlinePeriodTooMore",
            Self::ErrPersonalTagTooMore => "ErrPersonalTagTooMore",
            Self::ErrPersonalTagNotFound => "ErrPersonalTagNotFound",
            Self::ErrPersonalAvatarUnearned => "ErrPersonalAvatarUnearned",
            Self::ErrPersonalAvatarFrameUnearned => "ErrPersonalAvatarFrameUnearned",
            Self::ErrPersonalCardStyleUnearned => "ErrPersonalCardStyleUnearned",
            Self::ErrPersonalPhotoTooMore => "ErrPersonalPhotoTooMore",
            Self::ErrPersonalMedalUnearned => "ErrPersonalMedalUnearned",
            Self::ErrPersonalTargetUnlock => "ErrPersonalTargetUnlock",
            Self::ErrPersonalTargetAlreadyGet => "ErrPersonalTargetAlreadyGet",
            Self::ErrPersonalMedalInvalidSlot => "ErrPersonalMedalInvalidSlot",
            Self::ErrPersonalMedalDuplicateValue => "ErrPersonalMedalDuplicateValue",
            Self::ErrOnlinePeriodDuplicate => "ErrOnlinePeriodDuplicate",
            Self::ErrPersonalTagDuplicate => "ErrPersonalTagDuplicate",
            Self::ErrPersonalPhotoInvalidSlot => "ErrPersonalPhotoInvalidSlot",
            Self::ErrPersonalPhotoDuplicateValue => "ErrPersonalPhotoDuplicateValue",
            Self::ErrSeasonMedalNoMeetActiveCondition => {
                "ErrSeasonMedalNoMeetActiveCondition"
            }
            Self::ErrSeasonMedalNoMeetUpgradeCondition => {
                "ErrSeasonMedalNoMeetUpgradeCondition"
            }
            Self::ErrSeasonMedalActiveMeetNoEnough => "ErrSeasonMedalActiveMeetNoEnough",
            Self::ErrSeasonMedalUpgradeMeetNoEnough => {
                "ErrSeasonMedalUpgradeMeetNoEnough"
            }
            Self::ErrSeasonMedalIllegalNodeId => "ErrSeasonMedalIllegalNodeId",
            Self::ErrSeasonMedalChooseNodeIdBeyondMax => {
                "ErrSeasonMedalChooseNodeIdBeyondMax"
            }
            Self::ErrSeasonMedalHoleNoExist => "ErrSeasonMedalHoleNoExist",
            Self::ErrSeasonMedalHoleLock => "ErrSeasonMedalHoleLock",
            Self::ErrSeasonMedalNodeNoExist => "ErrSeasonMedalNodeNoExist",
            Self::ErrSeasonMedalHoleNoGet => "ErrSeasonMedalHoleNoGet",
            Self::ErrSeasonMedalMaxHoleLevel => "ErrSeasonMedalMaxHoleLevel",
            Self::ErrSeasonMedalCoreHoleLock => "ErrSeasonMedalCoreHoleLock",
            Self::ErrSeasonMedalUpgradeMoneyNoEnough => {
                "ErrSeasonMedalUpgradeMoneyNoEnough"
            }
            Self::ErrSeasonNoCoreHole => "ErrSeasonNoCoreHole",
            Self::ErrSeasonNoNormalHole => "ErrSeasonNoNormalHole",
            Self::ErrSeasonMedalNoUpgradeNormalHoleItem => {
                "ErrSeasonMedalNoUpgradeNormalHoleItem"
            }
            Self::ErrSceneLineNotExists => "ErrSceneLineNotExists",
            Self::ErrSceneLineRefreshCd => "ErrSceneLineRefreshCd",
            Self::ErrSceneLineNotSameScene => "ErrSceneLineNotSameScene",
            Self::ErrSceneLineSameLine => "ErrSceneLineSameLine",
            Self::ErrSceneLineInteracting => "ErrSceneLineInteracting",
            Self::ErrSceneLineUserDead => "ErrSceneLineUserDead",
            Self::ErrSceneLineFull => "ErrSceneLineFull",
            Self::ErrSceneLineChangeCd => "ErrSceneLineChangeCd",
            Self::ErrSceneVersionRecycle => "ErrSceneVersionRecycle",
            Self::ErrSceneLineKick => "ErrSceneLineKick",
            Self::ErrInstallSlotFailed => "ErrInstallSlotFailed",
            Self::ErrUseSlotFailed => "ErrUseSlotFailed",
            Self::ErrUseSlotInCd => "ErrUseSlotInCd",
            Self::ErrInstatallSlotFailedInCombat => "ErrInstatallSlotFailedInCombat",
            Self::ErrSlotSkillUnLoad => "ErrSlotSkillUnLoad",
            Self::ErrUseCfgSkillFailed => "ErrUseCfgSkillFailed",
            Self::ErrResonanceNotExists => "ErrResonanceNotExists",
            Self::ErrResonanceUnLoad => "ErrResonanceUnLoad",
            Self::ErrUseDodgeFailed => "ErrUseDodgeFailed",
            Self::ErrUseFixedSkillFailed => "ErrUseFixedSkillFailed",
            Self::ErrUseBlockedSkill => "ErrUseBlockedSkill",
            Self::ErrInstallBlockedSkill => "ErrInstallBlockedSkill",
            Self::ErrExchangeNotFound => "ErrExchangeNotFound",
            Self::ErrExchangeNotEnough => "ErrExchangeNotEnough",
            Self::ErrExchangeItemLimit => "ErrExchangeItemLimit",
            Self::ErrExchangeStepRange => "ErrExchangeStepRange",
            Self::ErrExchangeItemFull => "ErrExchangeItemFull",
            Self::ErrExchangePackageFull => "ErrExchangePackageFull",
            Self::ErrExchangePriceItemNotFind => "ErrExchangePriceItemNotFind",
            Self::ErrExchangeBuyNumNotEnough => "ErrExchangeBuyNumNotEnough",
            Self::ErrExchangeBuyItemNotFound => "ErrExchangeBuyItemNotFound",
            Self::ErrExchangeTakeFailDelayTime => "ErrExchangeTakeFailDelayTime",
            Self::ErrExchangeTakeFailSellNum => "ErrExchangeTakeFailSellNum",
            Self::ErrExchangeTakeItemNotFound => "ErrExchangeTakeItemNotFound",
            Self::ErrExchangeWithdrawNoMoney => "ErrExchangeWithdrawNoMoney",
            Self::ErrExchangeDepositNotEnough => "ErrExchangeDepositNotEnough",
            Self::ErrExchangeItemNotBindOrCooldownNotExpire => {
                "ErrExchangeItemNotBindOrCooldownNotExpire"
            }
            Self::ErrExchangeInCd => "ErrExchangeInCd",
            Self::ErrExchangeBuyCurrencyNoEnough => "ErrExchangeBuyCurrencyNoEnough",
            Self::ErrExchangeItemDelayTimeOver => "ErrExchangeItemDelayTimeOver",
            Self::ErrExchangeItemIsNotWithdraw => "ErrExchangeItemIsNotWithdraw",
            Self::ErrExchangeBuyItemLimit => "ErrExchangeBuyItemLimit",
            Self::ErrExchangeItemIsNotNoticeShopItem => {
                "ErrExchangeItemIsNotNoticeShopItem"
            }
            Self::ErrExchangeItemIsPreBuyAlready => "ErrExchangeItemIsPreBuyAlready",
            Self::ErrExchangeItemNotPublic => "ErrExchangeItemNotPublic",
            Self::ErrExchangeSaleRankExist => "ErrExchangeSaleRankExist",
            Self::ErrExchangeSaleItemFull => "ErrExchangeSaleItemFull",
            Self::ErrExchangeSaleDiamondNotEnough => "ErrExchangeSaleDiamondNotEnough",
            Self::ErrExchangeSaleItemNotExists => "ErrExchangeSaleItemNotExists",
            Self::ErrExchangeBuySaleCurrencyNoEnough => {
                "ErrExchangeBuySaleCurrencyNoEnough"
            }
            Self::ErrExchangeDiamondNotEnough => "ErrExchangeDiamondNotEnough",
            Self::ErrExchangeSaleTakeOffCd => "ErrExchangeSaleTakeOffCd",
            Self::ErrExchangeSaleRateInvalid => "ErrExchangeSaleRateInvalid",
            Self::ErrExchangePreItemFull => "ErrExchangePreItemFull",
            Self::ErrExchangeSaleNumInvalid => "ErrExchangeSaleNumInvalid",
            Self::ErrExchangeCareItemAlready => "ErrExchangeCareItemAlready",
            Self::ErrExchangePriceRange => "ErrExchangePriceRange",
            Self::ErrExchangeRequestLimit => "ErrExchangeRequestLimit",
            Self::ErrExchangeItemBanned => "ErrExchangeItemBanned",
            Self::ErrExchangePriceNotLow => "ErrExchangePriceNotLow",
            Self::ErrExchangeItemNotFind => "ErrExchangeItemNotFind",
            Self::ErrExchangeItemExistMinPrice => "ErrExchangeItemExistMinPrice",
            Self::ErrExchangeNoticeItemMin => "ErrExchangeNoticeItemMin",
            Self::ErrExchangePreBuyUserFull => "ErrExchangePreBuyUserFull",
            Self::ErrModHoleNotUnlock => "ErrModHoleNotUnlock",
            Self::ErrModNotExist => "ErrModNotExist",
            Self::ErrModSimilarRepeated => "ErrModSimilarRepeated",
            Self::ErrModTypeLimitExceeded => "ErrModTypeLimitExceeded",
            Self::ErrModPartNotExist => "ErrModPartNotExist",
            Self::ErrModPartEnhanceLimit => "ErrModPartEnhanceLimit",
            Self::ErrModInUse => "ErrModInUse",
            Self::ErrModAlreadyInstalled => "ErrModAlreadyInstalled",
            Self::ErrModInitConfigNotExist => "ErrModInitConfigNotExist",
            Self::ErrModPartOverflow => "ErrModPartOverflow",
            Self::ErrModCanNotLink => "ErrModCanNotLink",
            Self::ErrFishingNotUseBait => "ErrFishingNotUseBait",
            Self::ErrFishingRandomFailed => "ErrFishingRandomFailed",
            Self::ErrFishingAlreadyGetFishItem => "ErrFishingAlreadyGetFishItem",
            Self::ErrFishingGetFishIdWrong => "ErrFishingGetFishIdWrong",
            Self::ErrFishingNotGet => "ErrFishingNotGet",
            Self::ErrFishingNotResearchYet => "ErrFishingNotResearchYet",
            Self::ErrFishingNotUseRod => "ErrFishingNotUseRod",
            Self::ErrFishingNoSeat => "ErrFishingNoSeat",
            Self::ErrFishingCantResearch => "ErrFishingCantResearch",
            Self::ErrFishDrawnLevelAward => "ErrFishDrawnLevelAward",
            Self::ErrFishCannotDrawLevelAward => "ErrFishCannotDrawLevelAward",
            Self::ErrFishDrawnNoLevelAward => "ErrFishDrawnNoLevelAward",
            Self::ErrFreightNoRefreshGoods => "ErrFreightNoRefreshGoods",
            Self::ErrFreightBeyondMaxValue => "ErrFreightBeyondMaxValue",
            Self::ErrFreightDownMinValue => "ErrFreightDownMinValue",
            Self::ErrFreightHasSetOff => "ErrFreightHasSetOff",
            Self::ErrFreightNoSetOff => "ErrFreightNoSetOff",
            Self::ErrFreightHasReward => "ErrFreightHasReward",
            Self::ErrFreightIllegalGoodsId => "ErrFreightIllegalGoodsId",
            Self::ErrFreightItemNoEnough => "ErrFreightItemNoEnough",
            Self::ErrFreightNoUpSetOffTime => "ErrFreightNoUpSetOffTime",
            Self::ErrFreightNoUpRewardTime => "ErrFreightNoUpRewardTime",
            Self::ErrFreightAutoSetOff => "ErrFreightAutoSetOff",
            Self::ErrTrialRoadAwardNotFinished => "ErrTrialRoadAwardNotFinished",
            Self::ErrTrialRoadAwardRoomGet => "ErrTrialRoadAwardRoomGet",
            Self::ErrNotCanRide => "ErrNotCanRide",
            Self::ErrCombatStateNotRide => "ErrCombatStateNotRide",
            Self::ErrAlreadyRide => "ErrAlreadyRide",
            Self::ErrRideNotEnough => "ErrRideNotEnough",
            Self::ErrCreateVehicleActorFailed => "ErrCreateVehicleActorFailed",
            Self::ErrNotVehicleOwner => "ErrNotVehicleOwner",
            Self::ErrVehicleHasController => "ErrVehicleHasController",
            Self::ErrVehicleNoSeat => "ErrVehicleNoSeat",
            Self::ErrVehicleHasSeat => "ErrVehicleHasSeat",
            Self::ErrNotRideVehicle => "ErrNotRideVehicle",
            Self::ErrVehicleNotExits => "ErrVehicleNotExits",
            Self::ErrInvalidRidePropertyType => "ErrInvalidRidePropertyType",
            Self::ErrRideApplyTargetUserNotExist => "ErrRideApplyTargetUserNotExist",
            Self::ErrRideConfigNotFind => "ErrRideConfigNotFind",
            Self::ErrRideNotUnlock => "ErrRideNotUnlock",
            Self::ErrRideNotFind => "ErrRideNotFind",
            Self::ErrInvalidRideType => "ErrInvalidRideType",
            Self::ErrRideApplyAlreadyExist => "ErrRideApplyAlreadyExist",
            Self::ErrRideApplyNotRideVehicle => "ErrRideApplyNotRideVehicle",
            Self::ErrRideApplyVehicleNotSeat => "ErrRideApplyVehicleNotSeat",
            Self::ErrRideAlReadyRide => "ErrRideAlReadyRide",
            Self::ErrRideApplyTargetTooFar => "ErrRideApplyTargetTooFar",
            Self::ErrRideNotTake => "ErrRideNotTake",
            Self::ErrRideInteracting => "ErrRideInteracting",
            Self::ErrShapeshiftNotRide => "ErrShapeshiftNotRide",
            Self::ErrFishingNotRide => "ErrFishingNotRide",
            Self::ErrRideStateReject => "ErrRideStateReject",
            Self::ErrRideTypeNotSupport => "ErrRideTypeNotSupport",
            Self::ErrRideNotControl => "ErrRideNotControl",
            Self::ErrRideNotFunction => "ErrRideNotFunction",
            Self::ErrRideSkinNotSupport => "ErrRideSkinNotSupport",
            Self::ErrRideSkinNotUnlock => "ErrRideSkinNotUnlock",
            Self::ErrRideSkinDataAddFailed => "ErrRideSkinDataAddFailed",
            Self::ErrRideSkinNotSkin => "ErrRideSkinNotSkin",
            Self::ErrRideSkinAlreadyActivate => "ErrRideSkinAlreadyActivate",
            Self::ErrWarehouseHas => "ErrWarehouseHas",
            Self::ErrWarehouseNoHas => "ErrWarehouseNoHas",
            Self::ErrWarehouseNoMem => "ErrWarehouseNoMem",
            Self::ErrWarehouseNoPresident => "ErrWarehouseNoPresident",
            Self::ErrWarehouseNoHasItem => "ErrWarehouseNoHasItem",
            Self::ErrWarehouseItemNoDeposit => "ErrWarehouseItemNoDeposit",
            Self::ErrWarehouseGridPosNoExist => "ErrWarehouseGridPosNoExist",
            Self::ErrWarehouseGridPosItemNoEnough => "ErrWarehouseGridPosItemNoEnough",
            Self::ErrWarehouseNoInviteSelf => "ErrWarehouseNoInviteSelf",
            Self::ErrWarehouseInviteesHas => "ErrWarehouseInviteesHas",
            Self::ErrWarehouseMemBeyondMax => "ErrWarehouseMemBeyondMax",
            Self::ErrWarehouseGridBeyondMax => "ErrWarehouseGridBeyondMax",
            Self::ErrWarehouseNoSelf => "ErrWarehouseNoSelf",
            Self::ErrWarehouseIsMem => "ErrWarehouseIsMem",
            Self::ErrWarehouseNoExist => "ErrWarehouseNoExist",
            Self::ErrWarehouseDepositBeyondMax => "ErrWarehouseDepositBeyondMax",
            Self::ErrWarehouseTakeOutBeyondMax => "ErrWarehouseTakeOutBeyondMax",
            Self::ErrWarehouseItemIdNotSame => "ErrWarehouseItemIdNotSame",
            Self::ErrWarehouseParams => "ErrWarehouseParams",
            Self::ErrWarehouseNoKickSelf => "ErrWarehouseNoKickSelf",
            Self::ErrWarehousePresidentNoExit => "ErrWarehousePresidentNoExit",
            Self::ErrGashaDrawCount => "ErrGashaDrawCount",
            Self::ErrGashaDrawLimit => "ErrGashaDrawLimit",
            Self::ErrGashaInvalidWishId => "ErrGashaInvalidWishId",
            Self::EErGashaWishRepeated => "EErGashaWishRepeated",
            Self::EErGashaWishCountNoEnough => "EErGashaWishCountNoEnough",
            Self::ErrWarehouseAuthority => "ErrWarehouseAuthority",
            Self::ErrEquipCantDecompose => "ErrEquipCantDecompose",
            Self::ErrEquipNotRecastRecord => "ErrEquipNotRecastRecord",
            Self::ErrEquipOnCantUsedRecastConsume => "ErrEquipOnCantUsedRecastConsume",
            Self::ErrEquipWeaponNotEqualProfession => "ErrEquipWeaponNotEqualProfession",
            Self::ErrEquipSlotRefineBlessNotFit => "ErrEquipSlotRefineBlessNotFit",
            Self::ErrEquipNotRecast => "ErrEquipNotRecast",
            Self::ErrEquipEnchantItemMismatch => "ErrEquipEnchantItemMismatch",
            Self::ErrEquipEnchantAlreadyEnchanted => "ErrEquipEnchantAlreadyEnchanted",
            Self::ErrEquipAnyItemMismatch => "ErrEquipAnyItemMismatch",
            Self::ErrEquipSlotRefineBlessNumTooMuch => {
                "ErrEquipSlotRefineBlessNumTooMuch"
            }
            Self::ErrEquipNameGroupNoMatch => "ErrEquipNameGroupNoMatch",
            Self::ErrEquipPerfectionNoMatch => "ErrEquipPerfectionNoMatch",
            Self::ErrEquipNotBreak => "ErrEquipNotBreak",
            Self::ErrEquipPutOnIng => "ErrEquipPutOnIng",
            Self::ErrUserIsMatching => "ErrUserIsMatching",
            Self::ErrUserNotInMatching => "ErrUserNotInMatching",
            Self::ErrUseNotWaitReady => "ErrUseNotWaitReady",
            Self::ErrDungeonCantMatch => "ErrDungeonCantMatch",
            Self::ErrMatchQueueFull => "ErrMatchQueueFull",
            Self::ErrCommonAwardCantReceive => "ErrCommonAwardCantReceive",
            Self::ErrCommonAwardHasReceived => "ErrCommonAwardHasReceived",
            Self::ErrCraftEnergyNotEnough => "ErrCraftEnergyNotEnough",
            Self::ErrCraftEnergyFull => "ErrCraftEnergyFull",
            Self::ErrRecommendPlayNotOpen => "ErrRecommendPlayNotOpen",
            Self::ErrWeeklyTowerNoStart => "ErrWeeklyTowerNoStart",
            Self::ErrWeeklyTowerHasEnd => "ErrWeeklyTowerHasEnd",
            Self::ErrWeeklyNoMeetProcessAward => "ErrWeeklyNoMeetProcessAward",
            Self::ErrWeeklyHasRewardProcessAward => "ErrWeeklyHasRewardProcessAward",
            Self::ErrWeeklyNoLayerStageAward => "ErrWeeklyNoLayerStageAward",
            Self::ErrWeekOnlyCurSeasonAward => "ErrWeekOnlyCurSeasonAward",
            Self::ErrWeeklyTowerCannotEnterLayer => "ErrWeeklyTowerCannotEnterLayer",
            Self::ErrWeeklyTowerBoxHasOpen => "ErrWeeklyTowerBoxHasOpen",
            Self::ErrWeeklyTowerNoBox => "ErrWeeklyTowerNoBox",
            Self::ErrWeeklyTowerNoStageAward => "ErrWeeklyTowerNoStageAward",
            Self::ErrWeeklyTowerNoTowerDungeon => "ErrWeeklyTowerNoTowerDungeon",
            Self::ErrFunctionNoAward => "ErrFunctionNoAward",
            Self::ErrFunctionHasDrawn => "ErrFunctionHasDrawn",
            Self::ErrTLogIllegalExportArea => "ErrTLogIllegalExportArea",
            Self::ErrPayOrderFail => "ErrPayOrderFail",
            Self::ErrPayCostNotEnough => "ErrPayCostNotEnough",
            Self::ErrPayCantBuy => "ErrPayCantBuy",
            Self::ErrPayCantExplore => "ErrPayCantExplore",
            Self::ErrActivityNotFind => "ErrActivityNotFind",
            Self::ErrActivityOffline => "ErrActivityOffline",
            Self::ErrActivityNotOpen => "ErrActivityNotOpen",
            Self::ErrActivityRewardNotFound => "ErrActivityRewardNotFound",
            Self::ErrActivityConditionNotFinish => "ErrActivityConditionNotFinish",
            Self::ErrActivityAlreadyObtain => "ErrActivityAlreadyObtain",
            Self::ErrActivityNotUnlock => "ErrActivityNotUnlock",
            Self::ErrEmojiConfigError => "ErrEmojiConfigError",
            Self::ErrEmojiAlreadyUnlock => "ErrEmojiAlreadyUnlock",
            Self::ErrEmojiUnlockItemError => "ErrEmojiUnlockItemError",
            Self::ErrEmojiUnlockItemErrorItemNotEnough => {
                "ErrEmojiUnlockItemErrorItemNotEnough"
            }
            Self::ErrEmojiUnlock => "ErrEmojiUnlock",
            Self::ErrGlobalConditionNotFound => "ErrGlobalConditionNotFound",
            Self::ErrGlobalConditionNotLuckyValue => "ErrGlobalConditionNotLuckyValue",
            Self::ErrPathFindingCant => "ErrPathFindingCant",
            Self::ErrPathFindingDataError => "ErrPathFindingDataError",
            Self::ErrPathFindingEndPosError => "ErrPathFindingEndPosError",
            Self::ErrPathFindingStartPosError => "ErrPathFindingStartPosError",
            Self::ErrPathFindingNoPath => "ErrPathFindingNoPath",
            Self::ErrSignNotOpen => "ErrSignNotOpen",
            Self::ErrSignNotSigned => "ErrSignNotSigned",
            Self::ErrSignAlreadySigned => "ErrSignAlreadySigned",
            Self::ErrSignTimeError => "ErrSignTimeError",
            Self::ErrTokenBucketLimit => "ErrTokenBucketLimit",
            Self::ErrUnknown => "ErrUnknown",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ErrSuccess" => Some(Self::ErrSuccess),
            "ErrNoRecord" => Some(Self::ErrNoRecord),
            "ErrExceptionCancel" => Some(Self::ErrExceptionCancel),
            "ErrDBException" => Some(Self::ErrDbException),
            "ErrDBSeqException" => Some(Self::ErrDbSeqException),
            "ErrDBSceneException" => Some(Self::ErrDbSceneException),
            "ErrDBTokenException" => Some(Self::ErrDbTokenException),
            "ErrCancelled" => Some(Self::ErrCancelled),
            "ErrUnknownRpc" => Some(Self::ErrUnknownRpc),
            "ErrInvalidArgument" => Some(Self::ErrInvalidArgument),
            "ErrDeadlineExceeded" => Some(Self::ErrDeadlineExceeded),
            "ErrNotFound" => Some(Self::ErrNotFound),
            "ErrAlreadyExists" => Some(Self::ErrAlreadyExists),
            "ErrPermissionDenied" => Some(Self::ErrPermissionDenied),
            "ErrResourceExhausted" => Some(Self::ErrResourceExhausted),
            "ErrFailedPrecondition" => Some(Self::ErrFailedPrecondition),
            "ErrAborted" => Some(Self::ErrAborted),
            "ErrOutOfRange" => Some(Self::ErrOutOfRange),
            "ErrUnimplemented" => Some(Self::ErrUnimplemented),
            "ErrInternal" => Some(Self::ErrInternal),
            "ErrUnavailable" => Some(Self::ErrUnavailable),
            "ErrDataLoss" => Some(Self::ErrDataLoss),
            "ErrUnauthenticated" => Some(Self::ErrUnauthenticated),
            "ErrSystemMax" => Some(Self::ErrSystemMax),
            "ErrDBError" => Some(Self::ErrDbError),
            "ErrCreateOpenInfo" => Some(Self::ErrCreateOpenInfo),
            "ErrCreateAccountInfo" => Some(Self::ErrCreateAccountInfo),
            "ErrCreateCharInfo" => Some(Self::ErrCreateCharInfo),
            "ErrCreateAccountToken" => Some(Self::ErrCreateAccountToken),
            "ErrGetOpenInfo" => Some(Self::ErrGetOpenInfo),
            "ErrGetAccountInfo" => Some(Self::ErrGetAccountInfo),
            "ErrGetCharInfo" => Some(Self::ErrGetCharInfo),
            "ErrGetAccountToken" => Some(Self::ErrGetAccountToken),
            "ErrLoginInQueue" => Some(Self::ErrLoginInQueue),
            "ErrOtherLogin" => Some(Self::ErrOtherLogin),
            "ErrServerError" => Some(Self::ErrServerError),
            "ErrNoAccountInfo" => Some(Self::ErrNoAccountInfo),
            "ErrNoCharInfo" => Some(Self::ErrNoCharInfo),
            "ErrTokenExpired" => Some(Self::ErrTokenExpired),
            "ErrUpdateTokenFail" => Some(Self::ErrUpdateTokenFail),
            "ErrRegIntoSceneError" => Some(Self::ErrRegIntoSceneError),
            "ErrLoginTypeErr" => Some(Self::ErrLoginTypeErr),
            "ErrChangeMapErr" => Some(Self::ErrChangeMapErr),
            "ErrLoginPlatformErr" => Some(Self::ErrLoginPlatformErr),
            "ErrVersionErr" => Some(Self::ErrVersionErr),
            "ErrDelayOffLineKickOff" => Some(Self::ErrDelayOffLineKickOff),
            "ErrServiceLanguageError" => Some(Self::ErrServiceLanguageError),
            "NoEnterScene" => Some(Self::NoEnterScene),
            "ModIDNotOpen" => Some(Self::ModIdNotOpen),
            "ErrFaceData" => Some(Self::ErrFaceData),
            "ErrInitProfession" => Some(Self::ErrInitProfession),
            "ErrSceneCloseKickoff" => Some(Self::ErrSceneCloseKickoff),
            "ErrLoginReconnectKick" => Some(Self::ErrLoginReconnectKick),
            "ErrLoginErrorResume" => Some(Self::ErrLoginErrorResume),
            "ErrRepeatedLogin" => Some(Self::ErrRepeatedLogin),
            "ErrRestrictLogin" => Some(Self::ErrRestrictLogin),
            "ErrRestrictBlack" => Some(Self::ErrRestrictBlack),
            "ErrSdkVerifyFail" => Some(Self::ErrSdkVerifyFail),
            "ErrSdkTokenExpired" => Some(Self::ErrSdkTokenExpired),
            "ErrServerNotOpen" => Some(Self::ErrServerNotOpen),
            "ErrServerEndOpen" => Some(Self::ErrServerEndOpen),
            "ErrNormalKick" => Some(Self::ErrNormalKick),
            "ErrServerBusy" => Some(Self::ErrServerBusy),
            "ErrServerClose" => Some(Self::ErrServerClose),
            "ErrExitGame" => Some(Self::ErrExitGame),
            "ErrHopeKick" => Some(Self::ErrHopeKick),
            "ErrClientVersionError" => Some(Self::ErrClientVersionError),
            "ErrInvalidDeviceId" => Some(Self::ErrInvalidDeviceId),
            "ErrInvalidSystemType" => Some(Self::ErrInvalidSystemType),
            "ErrDeleteChar" => Some(Self::ErrDeleteChar),
            "ErrCancelDeleteChar" => Some(Self::ErrCancelDeleteChar),
            "ErrCancelDeleteCharIsDelete" => Some(Self::ErrCancelDeleteCharIsDelete),
            "ErrIntoSceneOwnerFail" => Some(Self::ErrIntoSceneOwnerFail),
            "ErrSceneQueueUp" => Some(Self::ErrSceneQueueUp),
            "ErrProtocolVersionErr" => Some(Self::ErrProtocolVersionErr),
            "ErrConfigVersionErr" => Some(Self::ErrConfigVersionErr),
            "ErrStateEventFailed" => Some(Self::ErrStateEventFailed),
            "ErrSelectCharDoing" => Some(Self::ErrSelectCharDoing),
            "ErrSelectCharDeleted" => Some(Self::ErrSelectCharDeleted),
            "ErrLoginChannelMax" => Some(Self::ErrLoginChannelMax),
            "ErrDeleteAccountKick" => Some(Self::ErrDeleteAccountKick),
            "ErrIsDeleteAccount" => Some(Self::ErrIsDeleteAccount),
            "ErrIsVersionKick" => Some(Self::ErrIsVersionKick),
            "ErrNotQQChnnel" => Some(Self::ErrNotQqChnnel),
            "ErrIncorrectLaunchPlatform" => Some(Self::ErrIncorrectLaunchPlatform),
            "ErrConditionWrong" => Some(Self::ErrConditionWrong),
            "ErrNotSupportLoginType" => Some(Self::ErrNotSupportLoginType),
            "ErrSceneNotExist" => Some(Self::ErrSceneNotExist),
            "ErrUserNotExist" => Some(Self::ErrUserNotExist),
            "ErrComponentNotExist" => Some(Self::ErrComponentNotExist),
            "ErrSceneConfigNotExist" => Some(Self::ErrSceneConfigNotExist),
            "ErrServiceNotExist" => Some(Self::ErrServiceNotExist),
            "ErrDataContainerNotExist" => Some(Self::ErrDataContainerNotExist),
            "ErrAsynchronousReturn" => Some(Self::ErrAsynchronousReturn),
            "ErrConfigNotExist" => Some(Self::ErrConfigNotExist),
            "ErrNotUser" => Some(Self::ErrNotUser),
            "ErrConfigError" => Some(Self::ErrConfigError),
            "ErrActorNotExist" => Some(Self::ErrActorNotExist),
            "ErrCutSceneAlreadyPlayed" => Some(Self::ErrCutSceneAlreadyPlayed),
            "ErrFunctionUnlock" => Some(Self::ErrFunctionUnlock),
            "ErrFunctionClosed" => Some(Self::ErrFunctionClosed),
            "ErrUserPlayerNotFurniturePackage" => {
                Some(Self::ErrUserPlayerNotFurniturePackage)
            }
            "ErrSysInnerError" => Some(Self::ErrSysInnerError),
            "ErrSysWebClientNull" => Some(Self::ErrSysWebClientNull),
            "ErrSysWebRequestTimeOut" => Some(Self::ErrSysWebRequestTimeOut),
            "ErrSysWebReturnError" => Some(Self::ErrSysWebReturnError),
            "ErrRequestTooFrequently" => Some(Self::ErrRequestTooFrequently),
            "ErrArgStringTooLong" => Some(Self::ErrArgStringTooLong),
            "ErrArgStringEmpty" => Some(Self::ErrArgStringEmpty),
            "ErrArgArrayTooBig" => Some(Self::ErrArgArrayTooBig),
            "ErrArgArrayEmpty" => Some(Self::ErrArgArrayEmpty),
            "ErrArgMapTooBig" => Some(Self::ErrArgMapTooBig),
            "ErrArgMapEmpty" => Some(Self::ErrArgMapEmpty),
            "ErrItemNotExist" => Some(Self::ErrItemNotExist),
            "ErrPackageNotExist" => Some(Self::ErrPackageNotExist),
            "ErrPackageFull" => Some(Self::ErrPackageFull),
            "ErrItemExpireTime" => Some(Self::ErrItemExpireTime),
            "ErrItemPackageGridNotEnough" => Some(Self::ErrItemPackageGridNotEnough),
            "ErrItemUUIDError" => Some(Self::ErrItemUuidError),
            "ErrItemNotEnough" => Some(Self::ErrItemNotEnough),
            "ErrOptTypeError" => Some(Self::ErrOptTypeError),
            "ErrItemInCoolDown" => Some(Self::ErrItemInCoolDown),
            "ErrItemNotUse" => Some(Self::ErrItemNotUse),
            "ErrItemEffectTypeError" => Some(Self::ErrItemEffectTypeError),
            "ErrItemParamError" => Some(Self::ErrItemParamError),
            "ErrItemAddBuffError" => Some(Self::ErrItemAddBuffError),
            "ErrItemAdd" => Some(Self::ErrItemAdd),
            "ErrUseItemState" => Some(Self::ErrUseItemState),
            "ErrBatchUse" => Some(Self::ErrBatchUse),
            "ErrFullSendMail" => Some(Self::ErrFullSendMail),
            "ErrItemNumZero" => Some(Self::ErrItemNumZero),
            "ErrItemSelectAwardIllegalNum" => Some(Self::ErrItemSelectAwardIllegalNum),
            "ErrItemSelectAwardIllegalPos" => Some(Self::ErrItemSelectAwardIllegalPos),
            "ErrItemSelectLimit" => Some(Self::ErrItemSelectLimit),
            "ErrItemPeriodGainExceeded" => Some(Self::ErrItemPeriodGainExceeded),
            "ErrItemNoRecycle" => Some(Self::ErrItemNoRecycle),
            "ErrItemRecycleBeyondMaxGrid" => Some(Self::ErrItemRecycleBeyondMaxGrid),
            "ErrItemRecycleBeyondMaxNum" => Some(Self::ErrItemRecycleBeyondMaxNum),
            "ErrItemRecycleIdNoMatchItemId" => Some(Self::ErrItemRecycleIdNoMatchItemId),
            "ErrItemRecycleIllegalId" => Some(Self::ErrItemRecycleIllegalId),
            "ErrItemLimitCount" => Some(Self::ErrItemLimitCount),
            "ErrItemFriendPontExceeded" => Some(Self::ErrItemFriendPontExceeded),
            "ErrItemToySingleEntUseExceeded" => {
                Some(Self::ErrItemToySingleEntUseExceeded)
            }
            "ErrItemToySceneUseExceeded" => Some(Self::ErrItemToySceneUseExceeded),
            "ErrItemToyUseInDisableArea" => Some(Self::ErrItemToyUseInDisableArea),
            "ErrItemToySingleCellUseExceeded" => {
                Some(Self::ErrItemToySingleCellUseExceeded)
            }
            "ErrMonthlyCardNotExists" => Some(Self::ErrMonthlyCardNotExists),
            "ErrMonthlyCardDataError" => Some(Self::ErrMonthlyCardDataError),
            "ErrMonthlyCardDayAwardReceived" => {
                Some(Self::ErrMonthlyCardDayAwardReceived)
            }
            "ErrMonthlyCardLimitCount" => Some(Self::ErrMonthlyCardLimitCount),
            "ErrCommunityNoHome" => Some(Self::ErrCommunityNoHome),
            "ErrNotHouseOwner" => Some(Self::ErrNotHouseOwner),
            "ErrHomeLandExisted" => Some(Self::ErrHomeLandExisted),
            "ErrHomeLandContentWrongful" => Some(Self::ErrHomeLandContentWrongful),
            "ErrHouseLivetogetherCD" => Some(Self::ErrHouseLivetogetherCd),
            "ErrHomeLandNotExisted" => Some(Self::ErrHomeLandNotExisted),
            "ErrHomeLandNotInScene" => Some(Self::ErrHomeLandNotInScene),
            "ErrHomeLandIsInvitation" => Some(Self::ErrHomeLandIsInvitation),
            "ErrHomeLandInsufficientAuthority" => {
                Some(Self::ErrHomeLandInsufficientAuthority)
            }
            "ErrHomeLandTransferRequestPending" => {
                Some(Self::ErrHomeLandTransferRequestPending)
            }
            "ErrHomeLandTransferRequestTimeout" => {
                Some(Self::ErrHomeLandTransferRequestTimeout)
            }
            "ErrHomeLandTransferCD" => Some(Self::ErrHomeLandTransferCd),
            "ErrHomelandTargetIsHasHome" => Some(Self::ErrHomelandTargetIsHasHome),
            "ErrHomelandTargetIsOwner" => Some(Self::ErrHomelandTargetIsOwner),
            "ErrHomelandNotOwnerCannotOperate" => {
                Some(Self::ErrHomelandNotOwnerCannotOperate)
            }
            "ErrHomeLandHasHouse" => Some(Self::ErrHomeLandHasHouse),
            "ErrHomeLandContentTooLong" => Some(Self::ErrHomeLandContentTooLong),
            "ErrHomeLandClutterNotExist" => Some(Self::ErrHomeLandClutterNotExist),
            "ErrHouseNameOrStatementCD" => Some(Self::ErrHouseNameOrStatementCd),
            "ErrHouseIntroductionStatementCD" => {
                Some(Self::ErrHouseIntroductionStatementCd)
            }
            "ErrCommunityBuildInvalidRecipeId" => {
                Some(Self::ErrCommunityBuildInvalidRecipeId)
            }
            "ErrCommunityBuildRecipeIsUnlock" => {
                Some(Self::ErrCommunityBuildRecipeIsUnlock)
            }
            "ErrCommunityBuildMax" => Some(Self::ErrCommunityBuildMax),
            "ErrCommunityBuildNoAuthority" => Some(Self::ErrCommunityBuildNoAuthority),
            "ErrCommunityNotBuildCannotCancel" => {
                Some(Self::ErrCommunityNotBuildCannotCancel)
            }
            "ErrCommunityBuildNotSelfCannotCancel" => {
                Some(Self::ErrCommunityBuildNotSelfCannotCancel)
            }
            "ErrCommunityNotBuildCannotAccelerate" => {
                Some(Self::ErrCommunityNotBuildCannotAccelerate)
            }
            "ErrCommunityBuildNotSelfCannotAccelerate" => {
                Some(Self::ErrCommunityBuildNotSelfCannotAccelerate)
            }
            "ErrCommunityBuildCannotAccelerate" => {
                Some(Self::ErrCommunityBuildCannotAccelerate)
            }
            "ErrCommunityBuildAlreadyAccelerate" => {
                Some(Self::ErrCommunityBuildAlreadyAccelerate)
            }
            "ErrCommunityBuildInDungeon" => Some(Self::ErrCommunityBuildInDungeon),
            "ErrCommunityBuildRecipeIsLock" => Some(Self::ErrCommunityBuildRecipeIsLock),
            "ErrCommunityBuildRecipeNotItemUnlock" => {
                Some(Self::ErrCommunityBuildRecipeNotItemUnlock)
            }
            "ErrCommunityBuildInvalidCount" => Some(Self::ErrCommunityBuildInvalidCount),
            "ErrCommunityNotBuildCannotReceive" => {
                Some(Self::ErrCommunityNotBuildCannotReceive)
            }
            "ErrCommunityCanNotBuild" => Some(Self::ErrCommunityCanNotBuild),
            "ErrHomeLandCohabitantLimit" => Some(Self::ErrHomeLandCohabitantLimit),
            "ErrHomeLandRootNotQuitCohabitant" => {
                Some(Self::ErrHomeLandRootNotQuitCohabitant)
            }
            "ErrHomeLandNotOwnerCannotQuitCohabitant" => {
                Some(Self::ErrHomeLandNotOwnerCannotQuitCohabitant)
            }
            "ErrHomeLandCohabitantIsExiting" => {
                Some(Self::ErrHomeLandCohabitantIsExiting)
            }
            "ErrHomeLandCohabitantNotExists" => {
                Some(Self::ErrHomeLandCohabitantNotExists)
            }
            "ErrHomeLandCohabitantExitRequestExists" => {
                Some(Self::ErrHomeLandCohabitantExitRequestExists)
            }
            "ErrHomeLandCohabitantDismiss" => Some(Self::ErrHomeLandCohabitantDismiss),
            "ErrHomeLandNotInvitation" => Some(Self::ErrHomeLandNotInvitation),
            "ErrHomeLandCohabitantInvitationTimeout" => {
                Some(Self::ErrHomeLandCohabitantInvitationTimeout)
            }
            "ErrHomeLandCohabitantNotFriend" => {
                Some(Self::ErrHomeLandCohabitantNotFriend)
            }
            "ErrHomeLandCohabitantFriendLevel" => {
                Some(Self::ErrHomeLandCohabitantFriendLevel)
            }
            "ErrHomeLandCohabitantLevel" => Some(Self::ErrHomeLandCohabitantLevel),
            "ErrHomeLandInviteCohabitantNotOwner" => {
                Some(Self::ErrHomeLandInviteCohabitantNotOwner)
            }
            "ErrCommunityWarehouseGridFull" => Some(Self::ErrCommunityWarehouseGridFull),
            "ErrCommunityWarehouseNoAuthority" => {
                Some(Self::ErrCommunityWarehouseNoAuthority)
            }
            "ErrCommunityWarehouseGridPosItemNoEnough" => {
                Some(Self::ErrCommunityWarehouseGridPosItemNoEnough)
            }
            "ErrHomeLandInsufficientFurniture" => {
                Some(Self::ErrHomeLandInsufficientFurniture)
            }
            "ErrCommunityWarehouseTakeOutCountLimit" => {
                Some(Self::ErrCommunityWarehouseTakeOutCountLimit)
            }
            "ErrHomeLandTaskNotExist" => Some(Self::ErrHomeLandTaskNotExist),
            "ErrHomeLandTaskTimeNotEnough" => Some(Self::ErrHomeLandTaskTimeNotEnough),
            "ErrHomeLandTaskAlreadyFinished" => {
                Some(Self::ErrHomeLandTaskAlreadyFinished)
            }
            "ErrHomeLandTaskItemNotEnough" => Some(Self::ErrHomeLandTaskItemNotEnough),
            "ErrHomeLandCurLevelError" => Some(Self::ErrHomeLandCurLevelError),
            "ErrHomeLandExpNotEnough" => Some(Self::ErrHomeLandExpNotEnough),
            "ErrHomeLandAlreadyMaxLevel" => Some(Self::ErrHomeLandAlreadyMaxLevel),
            "ErrHomeLandLevelLocked" => Some(Self::ErrHomeLandLevelLocked),
            "ErrHomeLandLevelConfigError" => Some(Self::ErrHomeLandLevelConfigError),
            "ErrCommunityEditorNotEditable" => Some(Self::ErrCommunityEditorNotEditable),
            "ErrCommunityEditorNotFurniture" => {
                Some(Self::ErrCommunityEditorNotFurniture)
            }
            "ErrCommunityEditorNotOutdoor" => Some(Self::ErrCommunityEditorNotOutdoor),
            "ErrCommunityEditorNotIndoor" => Some(Self::ErrCommunityEditorNotIndoor),
            "ErrCommunityEditorOverMax" => Some(Self::ErrCommunityEditorOverMax),
            "ErrCommunityEditorOverTypeMax" => Some(Self::ErrCommunityEditorOverTypeMax),
            "ErrCommunityEditorFurnitureNotEnough" => {
                Some(Self::ErrCommunityEditorFurnitureNotEnough)
            }
            "ErrCommunityEditorFurnitureNotExist" => {
                Some(Self::ErrCommunityEditorFurnitureNotExist)
            }
            "ErrCommunityEditorOverMaxGroup" => {
                Some(Self::ErrCommunityEditorOverMaxGroup)
            }
            "ErrCommunityEditorNoStructure" => Some(Self::ErrCommunityEditorNoStructure),
            "ErrCommunityEditorGroupMaxStructure" => {
                Some(Self::ErrCommunityEditorGroupMaxStructure)
            }
            "ErrCommunityEditorStructureInGroup" => {
                Some(Self::ErrCommunityEditorStructureInGroup)
            }
            "ErrCommunityEditorGroupNotExist" => {
                Some(Self::ErrCommunityEditorGroupNotExist)
            }
            "ErrCommunityEditorAlreadyExist" => {
                Some(Self::ErrCommunityEditorAlreadyExist)
            }
            "ErrHomeLandSellItemNotExist" => Some(Self::ErrHomeLandSellItemNotExist),
            "ErrHomeLandLeftNumNotEnough" => Some(Self::ErrHomeLandLeftNumNotEnough),
            "ErrHomeLandSellShopLocked" => Some(Self::ErrHomeLandSellShopLocked),
            "ErrHomeLandSeedExist" => Some(Self::ErrHomeLandSeedExist),
            "ErrHomeLandItemNotOwner" => Some(Self::ErrHomeLandItemNotOwner),
            "ErrHomeLandSeedStateError" => Some(Self::ErrHomeLandSeedStateError),
            "ErrHomeLandNoSeed" => Some(Self::ErrHomeLandNoSeed),
            "ErrHomeLandNoWater" => Some(Self::ErrHomeLandNoWater),
            "ErrHomeLandFertilizerMaxNumLimit" => {
                Some(Self::ErrHomeLandFertilizerMaxNumLimit)
            }
            "ErrHomeLandNotFertilize" => Some(Self::ErrHomeLandNotFertilize),
            "ErrHomeLandNotPollen" => Some(Self::ErrHomeLandNotPollen),
            "ErrHomeLandAlreadyPollen" => Some(Self::ErrHomeLandAlreadyPollen),
            "ErrHomeLandNotHarvest" => Some(Self::ErrHomeLandNotHarvest),
            "ErrHomeLandPickUpSinglePlayerLimit" => {
                Some(Self::ErrHomeLandPickUpSinglePlayerLimit)
            }
            "ErrHomeLandPickUpTotalLimit" => Some(Self::ErrHomeLandPickUpTotalLimit),
            "ErrHomeLandPickUpFlowerNotFinished" => {
                Some(Self::ErrHomeLandPickUpFlowerNotFinished)
            }
            "ErrHomeLandPickUpOwner" => Some(Self::ErrHomeLandPickUpOwner),
            "ErrHomeLandGainNotOwner" => Some(Self::ErrHomeLandGainNotOwner),
            "ErrHomeLandItemFullGrid" => Some(Self::ErrHomeLandItemFullGrid),
            "ErrHomeLandFurnitureFull" => Some(Self::ErrHomeLandFurnitureFull),
            "ErrComposeItemNotEnough" => Some(Self::ErrComposeItemNotEnough),
            "ErrComposeFailed" => Some(Self::ErrComposeFailed),
            "ErrRedemptionItemNotExist" => Some(Self::ErrRedemptionItemNotExist),
            "ErrRedemptionItemMaxCount" => Some(Self::ErrRedemptionItemMaxCount),
            "ErrRedemptionItemNotEnough" => Some(Self::ErrRedemptionItemNotEnough),
            "ErrRedemptionItemGender" => Some(Self::ErrRedemptionItemGender),
            "ErrAwardConfigNotFound" => Some(Self::ErrAwardConfigNotFound),
            "ErrAwardConfigWeightError" => Some(Self::ErrAwardConfigWeightError),
            "ErrAwardConfigLimitAndContentNotMatch" => {
                Some(Self::ErrAwardConfigLimitAndContentNotMatch)
            }
            "ErrAwardConfigContentSizeError" => {
                Some(Self::ErrAwardConfigContentSizeError)
            }
            "ErrAwardConfigContentRatesSizeError" => {
                Some(Self::ErrAwardConfigContentRatesSizeError)
            }
            "ErrAwardConfigContentWeightSizeError" => {
                Some(Self::ErrAwardConfigContentWeightSizeError)
            }
            "ErrAwardConfigGroupContentEmpty" => {
                Some(Self::ErrAwardConfigGroupContentEmpty)
            }
            "ErrAwardConfigGroupNumEmpty" => Some(Self::ErrAwardConfigGroupNumEmpty),
            "ErrAwardConfigGroupContentNoMatchGroupNum" => {
                Some(Self::ErrAwardConfigGroupContentNoMatchGroupNum)
            }
            "ErrAwardConfigNoRandomDrop" => Some(Self::ErrAwardConfigNoRandomDrop),
            "ErrAwardConfigNoSelectAward" => Some(Self::ErrAwardConfigNoSelectAward),
            "ErrAwardConfigSelfSelectContentNoItem" => {
                Some(Self::ErrAwardConfigSelfSelectContentNoItem)
            }
            "ErrAwardConfigWeightRateMustOne" => {
                Some(Self::ErrAwardConfigWeightRateMustOne)
            }
            "ErrAwardConfigGroupContentRandomNoMatch" => {
                Some(Self::ErrAwardConfigGroupContentRandomNoMatch)
            }
            "ErrAwardConfigGroupContentError" => {
                Some(Self::ErrAwardConfigGroupContentError)
            }
            "ErrAwardConfigPackageContentRandomNoMatch" => {
                Some(Self::ErrAwardConfigPackageContentRandomNoMatch)
            }
            "ErrAwardConfigLevelUpPackConfigPackageNoMatch" => {
                Some(Self::ErrAwardConfigLevelUpPackConfigPackageNoMatch)
            }
            "ErrAwardConfigProItemRuleNoMatch" => {
                Some(Self::ErrAwardConfigProItemRuleNoMatch)
            }
            "ErrAwardConfigPackageContentEmpty" => {
                Some(Self::ErrAwardConfigPackageContentEmpty)
            }
            "ErrAwardConfigDropContentSize" => Some(Self::ErrAwardConfigDropContentSize),
            "ErrAwardConfigDropContentNum" => Some(Self::ErrAwardConfigDropContentNum),
            "ErrAwardConfigGroupRateEmpty" => Some(Self::ErrAwardConfigGroupRateEmpty),
            "ErrAwardConfigGroupWeightEmpty" => {
                Some(Self::ErrAwardConfigGroupWeightEmpty)
            }
            "ErrAwardInnerError" => Some(Self::ErrAwardInnerError),
            "ErrAwardIllegalRandomType" => Some(Self::ErrAwardIllegalRandomType),
            "ErrAwardConditionNoMeet" => Some(Self::ErrAwardConditionNoMeet),
            "ErrAwardRandomTypeNone" => Some(Self::ErrAwardRandomTypeNone),
            "ErrAwardRandomTypeNoMatch" => Some(Self::ErrAwardRandomTypeNoMatch),
            "ErrAwardActorIsNull" => Some(Self::ErrAwardActorIsNull),
            "ErrEquipWashAttrNotExist" => Some(Self::ErrEquipWashAttrNotExist),
            "ErrNotEquipInCombat" => Some(Self::ErrNotEquipInCombat),
            "ErrEquipPart" => Some(Self::ErrEquipPart),
            "ErrComposeItemNotExist" => Some(Self::ErrComposeItemNotExist),
            "ErrPickupDropItemDistance" => Some(Self::ErrPickupDropItemDistance),
            "ErrPickupDropItemPackageFull" => Some(Self::ErrPickupDropItemPackageFull),
            "ErrPickupDropItemNoAuthority" => Some(Self::ErrPickupDropItemNoAuthority),
            "ErrLayerActorExist" => Some(Self::ErrLayerActorExist),
            "ErrTeamCreateHas" => Some(Self::ErrTeamCreateHas),
            "ErrTeamIllTarget" => Some(Self::ErrTeamIllTarget),
            "ErrTeamCreateTryLater" => Some(Self::ErrTeamCreateTryLater),
            "ErrTeamGetNo" => Some(Self::ErrTeamGetNo),
            "ErrTeamListEmpty" => Some(Self::ErrTeamListEmpty),
            "ErrTeamInner" => Some(Self::ErrTeamInner),
            "ErrTeamNoLeader" => Some(Self::ErrTeamNoLeader),
            "ErrTeamInMatch" => Some(Self::ErrTeamInMatch),
            "ErrTeamCustomizeTarget" => Some(Self::ErrTeamCustomizeTarget),
            "ErrTeamNoOwn" => Some(Self::ErrTeamNoOwn),
            "ErrTeamTickSelf" => Some(Self::ErrTeamTickSelf),
            "ErrTeamNoMem" => Some(Self::ErrTeamNoMem),
            "ErrTeamApplyingLeader" => Some(Self::ErrTeamApplyingLeader),
            "ErrTeamHasBeLeader" => Some(Self::ErrTeamHasBeLeader),
            "ErrTeamNoTransferSelf" => Some(Self::ErrTeamNoTransferSelf),
            "ErrTeamNoLeaderTransfer" => Some(Self::ErrTeamNoLeaderTransfer),
            "ErrTeamHasOwnTeam" => Some(Self::ErrTeamHasOwnTeam),
            "ErrTeamNoExist" => Some(Self::ErrTeamNoExist),
            "ErrTeamApplyInCD" => Some(Self::ErrTeamApplyInCd),
            "ErrTeamApplyExpire" => Some(Self::ErrTeamApplyExpire),
            "ErrTeamJoinOther" => Some(Self::ErrTeamJoinOther),
            "ErrTeamMemMax" => Some(Self::ErrTeamMemMax),
            "ErrTeamNoInvited" => Some(Self::ErrTeamNoInvited),
            "ErrTeamIsMatching" => Some(Self::ErrTeamIsMatching),
            "ErrTeamIllegalTag" => Some(Self::ErrTeamIllegalTag),
            "ErrTeamNoMatching" => Some(Self::ErrTeamNoMatching),
            "ErrTeamIllegalActivity" => Some(Self::ErrTeamIllegalActivity),
            "ErrTeamInActivity" => Some(Self::ErrTeamInActivity),
            "ErrTeamNoMeetCondition" => Some(Self::ErrTeamNoMeetCondition),
            "ErrTeamWaitVoting" => Some(Self::ErrTeamWaitVoting),
            "ErrTeamDoingActivity" => Some(Self::ErrTeamDoingActivity),
            "ErrTeamNoInVoting" => Some(Self::ErrTeamNoInVoting),
            "ErrTeamVoteEnd" => Some(Self::ErrTeamVoteEnd),
            "ErrTeamHasVoted" => Some(Self::ErrTeamHasVoted),
            "ErrTeamInviteCD" => Some(Self::ErrTeamInviteCd),
            "ErrTeamApplyLeadCD" => Some(Self::ErrTeamApplyLeadCd),
            "ErrTeamMoreMaxWorlds" => Some(Self::ErrTeamMoreMaxWorlds),
            "ErrTeamValidApplyInfo" => Some(Self::ErrTeamValidApplyInfo),
            "ErrTeamInMatchCancelCD" => Some(Self::ErrTeamInMatchCancelCd),
            "ErrTeamMatchFinished" => Some(Self::ErrTeamMatchFinished),
            "ErrTeamMatchWaitSec" => Some(Self::ErrTeamMatchWaitSec),
            "ErrTeamMemWorldFull" => Some(Self::ErrTeamMemWorldFull),
            "ErrTeamMemNotLeader" => Some(Self::ErrTeamMemNotLeader),
            "ErrTeamLeaderNotStaticScene" => Some(Self::ErrTeamLeaderNotStaticScene),
            "ErrTeamLeaderCallDoing" => Some(Self::ErrTeamLeaderCallDoing),
            "ErrTeamIllegalCallOperator" => Some(Self::ErrTeamIllegalCallOperator),
            "ErrTeamLeaderIllegalCallOperator" => {
                Some(Self::ErrTeamLeaderIllegalCallOperator)
            }
            "ErrTeamNoMemCall" => Some(Self::ErrTeamNoMemCall),
            "ErrTeamLeaderCallEnd" => Some(Self::ErrTeamLeaderCallEnd),
            "ErrTeamSameScene" => Some(Self::ErrTeamSameScene),
            "ErrTeamNotSameScene" => Some(Self::ErrTeamNotSameScene),
            "ErrTeamMemTooMore" => Some(Self::ErrTeamMemTooMore),
            "ErrTeamMemInDungeon" => Some(Self::ErrTeamMemInDungeon),
            "ErrTeamMemTooLess" => Some(Self::ErrTeamMemTooLess),
            "ErrTeamIllegalInviteType" => Some(Self::ErrTeamIllegalInviteType),
            "ErrTeamMemberNotInScene" => Some(Self::ErrTeamMemberNotInScene),
            "ErrTeamLeaderReadyCheckTimeNotReady" => {
                Some(Self::ErrTeamLeaderReadyCheckTimeNotReady)
            }
            "ErrTeamExistDungeonCheck" => Some(Self::ErrTeamExistDungeonCheck),
            "ErrTeamTargetMatchTalentLimit" => Some(Self::ErrTeamTargetMatchTalentLimit),
            "ErrTeamEditGroupNotAllowed" => Some(Self::ErrTeamEditGroupNotAllowed),
            "ErrTeamGroupNotExist" => Some(Self::ErrTeamGroupNotExist),
            "ErrTeamTargetNoMatchMemberType" => {
                Some(Self::ErrTeamTargetNoMatchMemberType)
            }
            "ErrDecomposeItemNotExist" => Some(Self::ErrDecomposeItemNotExist),
            "ErrDecomposeItemNotEnough" => Some(Self::ErrDecomposeItemNotEnough),
            "ErrRefineEnergyNotEnough" => Some(Self::ErrRefineEnergyNotEnough),
            "ErrRefineItemMaxCount" => Some(Self::ErrRefineItemMaxCount),
            "ErrRefineItemNotExist" => Some(Self::ErrRefineItemNotExist),
            "ErrRefineItemColumnNotUnlock" => Some(Self::ErrRefineItemColumnNotUnlock),
            "ErrRefineItemColumnUnlock" => Some(Self::ErrRefineItemColumnUnlock),
            "ErrRefineItemExist" => Some(Self::ErrRefineItemExist),
            "ErrEnergyLimitMax" => Some(Self::ErrEnergyLimitMax),
            "ErrRefineItemColumnNotEmpty" => Some(Self::ErrRefineItemColumnNotEmpty),
            "ErrProfessionNotExist" => Some(Self::ErrProfessionNotExist),
            "ErrModSlotNotUnlock" => Some(Self::ErrModSlotNotUnlock),
            "ErrChangeProfessionStateFail" => Some(Self::ErrChangeProfessionStateFail),
            "ErrChangeProfessionCDFail" => Some(Self::ErrChangeProfessionCdFail),
            "ErrProfessionSkinNotActive" => Some(Self::ErrProfessionSkinNotActive),
            "ErrProfessionSkinActive" => Some(Self::ErrProfessionSkinActive),
            "ErrProfessionNotUseSkin" => Some(Self::ErrProfessionNotUseSkin),
            "ErrProfessionSkillSkinActive" => Some(Self::ErrProfessionSkillSkinActive),
            "ErrProfessionSkillSkinNotActive" => {
                Some(Self::ErrProfessionSkillSkinNotActive)
            }
            "ErrProfessionSkillNotActive" => Some(Self::ErrProfessionSkillNotActive),
            "ErrCharOffline" => Some(Self::ErrCharOffline),
            "ErrUserDataBaseError" => Some(Self::ErrUserDataBaseError),
            "ErrCharGetFail" => Some(Self::ErrCharGetFail),
            "ErrAlreadyAlive" => Some(Self::ErrAlreadyAlive),
            "ErrReviveParam" => Some(Self::ErrReviveParam),
            "ErrStateIllegal" => Some(Self::ErrStateIllegal),
            "ErrStateNoChange" => Some(Self::ErrStateNoChange),
            "ErrReviveConsumeNotEnough" => Some(Self::ErrReviveConsumeNotEnough),
            "ErrReviveByOtherForbid" => Some(Self::ErrReviveByOtherForbid),
            "ErrReviveTimeNotArrived" => Some(Self::ErrReviveTimeNotArrived),
            "ErrReviveBossBattle" => Some(Self::ErrReviveBossBattle),
            "ErrReviveCountLimit" => Some(Self::ErrReviveCountLimit),
            "ErrReviveInDeadTp" => Some(Self::ErrReviveInDeadTp),
            "ErrDungeonPlayTypeError" => Some(Self::ErrDungeonPlayTypeError),
            "ErrDungeonNotExist" => Some(Self::ErrDungeonNotExist),
            "ErrDungeonCreateError" => Some(Self::ErrDungeonCreateError),
            "ErrCantChangeDungeon" => Some(Self::ErrCantChangeDungeon),
            "ErrDungeonLock" => Some(Self::ErrDungeonLock),
            "ErrPioneerFail" => Some(Self::ErrPioneerFail),
            "ErrAwardFail" => Some(Self::ErrAwardFail),
            "ErrGsNotEnough" => Some(Self::ErrGsNotEnough),
            "ErrQuestNotCompleted" => Some(Self::ErrQuestNotCompleted),
            "ErrDungeonNotClear" => Some(Self::ErrDungeonNotClear),
            "ErrConditionNotExist" => Some(Self::ErrConditionNotExist),
            "ErrAwardReceived" => Some(Self::ErrAwardReceived),
            "ErrCantRepeatedPlay" => Some(Self::ErrCantRepeatedPlay),
            "ErrNeedPassPreRoom" => Some(Self::ErrNeedPassPreRoom),
            "ErrDungeonEnterCountLimit" => Some(Self::ErrDungeonEnterCountLimit),
            "ErrDungeonScoreError" => Some(Self::ErrDungeonScoreError),
            "ErrDungeonRepeatedVote" => Some(Self::ErrDungeonRepeatedVote),
            "ErrDungeonChallengeAwardState" => Some(Self::ErrDungeonChallengeAwardState),
            "ErrDungeonChallengeAffixNotFound" => {
                Some(Self::ErrDungeonChallengeAffixNotFound)
            }
            "ErrDungeonStateNotActive" => Some(Self::ErrDungeonStateNotActive),
            "ErrDungeonCantVoteSelf" => Some(Self::ErrDungeonCantVoteSelf),
            "ErrDungeonPlayerNotEnough" => Some(Self::ErrDungeonPlayerNotEnough),
            "ErrDungeonPlayerFull" => Some(Self::ErrDungeonPlayerFull),
            "ErrDungeonCantHeroKey" => Some(Self::ErrDungeonCantHeroKey),
            "ErrDungeonNotSettlement" => Some(Self::ErrDungeonNotSettlement),
            "ErrDungeonNotFindRollItem" => Some(Self::ErrDungeonNotFindRollItem),
            "ErrDungeonCantRoll" => Some(Self::ErrDungeonCantRoll),
            "ErrDungeonRollFinish" => Some(Self::ErrDungeonRollFinish),
            "ErrDungeonSelectError" => Some(Self::ErrDungeonSelectError),
            "ErrDungeonAiModeError" => Some(Self::ErrDungeonAiModeError),
            "ErrDungeonTargetNotFinish" => Some(Self::ErrDungeonTargetNotFinish),
            "ErrDungeonTargetBeAward" => Some(Self::ErrDungeonTargetBeAward),
            "ErrDungeonSinglePlayerMore" => Some(Self::ErrDungeonSinglePlayerMore),
            "ErrDungeonAiGroupNotEnough" => Some(Self::ErrDungeonAiGroupNotEnough),
            "ErrDungeonNoPass" => Some(Self::ErrDungeonNoPass),
            "ErrDungeonCloseSceneId" => Some(Self::ErrDungeonCloseSceneId),
            "ErrDungeonEnterTypeError" => Some(Self::ErrDungeonEnterTypeError),
            "ErrDungeonActorCount" => Some(Self::ErrDungeonActorCount),
            "ErrDungeonDiffLocked" => Some(Self::ErrDungeonDiffLocked),
            "ErrDungeonPreBattleVoteCd" => Some(Self::ErrDungeonPreBattleVoteCd),
            "ErrDungeonBossInvalid" => Some(Self::ErrDungeonBossInvalid),
            "ErrDungeonNoUser" => Some(Self::ErrDungeonNoUser),
            "ErrDungeonUserInvalid" => Some(Self::ErrDungeonUserInvalid),
            "ErrDungeonAwardualification" => Some(Self::ErrDungeonAwardualification),
            "ErrDungeonAwardTriesLimit" => Some(Self::ErrDungeonAwardTriesLimit),
            "ErrFashionIsLimit" => Some(Self::ErrFashionIsLimit),
            "ErrFashionNotFound" => Some(Self::ErrFashionNotFound),
            "ErrFashionSlotEmpty" => Some(Self::ErrFashionSlotEmpty),
            "ErrFashionIDNotFound" => Some(Self::ErrFashionIdNotFound),
            "ErrFashionLock" => Some(Self::ErrFashionLock),
            "ErrFashCollectionAwardAlread" => Some(Self::ErrFashCollectionAwardAlread),
            "ErrFashCollectionScoreNotEnough" => {
                Some(Self::ErrFashCollectionScoreNotEnough)
            }
            "ErrFashCollectionAwardAlreadMonth" => {
                Some(Self::ErrFashCollectionAwardAlreadMonth)
            }
            "ErrFashionAlreadUnlock" => Some(Self::ErrFashionAlreadUnlock),
            "ErrFashionAdvanceNotExist" => Some(Self::ErrFashionAdvanceNotExist),
            "ErrFashionBaseNotUnlock" => Some(Self::ErrFashionBaseNotUnlock),
            "ErrFashionAdvanceAlreadyUnlock" => {
                Some(Self::ErrFashionAdvanceAlreadyUnlock)
            }
            "ErrCameraNoExistAlbum" => Some(Self::ErrCameraNoExistAlbum),
            "ErrCameraBeyondPhotoNum" => Some(Self::ErrCameraBeyondPhotoNum),
            "ErrCameraBeyondAlumNum" => Some(Self::ErrCameraBeyondAlumNum),
            "ErrCameraNoAccessRight" => Some(Self::ErrCameraNoAccessRight),
            "ErrCameraNoExistPhoto" => Some(Self::ErrCameraNoExistPhoto),
            "ErrCameraBeyondWordNum" => Some(Self::ErrCameraBeyondWordNum),
            "ErrCameraPhotoNoInAlbum" => Some(Self::ErrCameraPhotoNoInAlbum),
            "ErrCameraInnerError" => Some(Self::ErrCameraInnerError),
            "ErrCameraIllegalRight" => Some(Self::ErrCameraIllegalRight),
            "ErrCameraNoExistChar" => Some(Self::ErrCameraNoExistChar),
            "ErrCameraNoDelCloudAlbum" => Some(Self::ErrCameraNoDelCloudAlbum),
            "ErrCameraBeyondMaxURlLen" => Some(Self::ErrCameraBeyondMaxURlLen),
            "ErrCameraBeyondMaxXMLLen" => Some(Self::ErrCameraBeyondMaxXmlLen),
            "ErrCameraBeyondMaxNameLen" => Some(Self::ErrCameraBeyondMaxNameLen),
            "ErrCameraIllegalUrl" => Some(Self::ErrCameraIllegalUrl),
            "ErrCameraRenderInfoEmpty" => Some(Self::ErrCameraRenderInfoEmpty),
            "ErrCameraBeyondPhotoMaxSize" => Some(Self::ErrCameraBeyondPhotoMaxSize),
            "ErrCameraIllegalPictureType" => Some(Self::ErrCameraIllegalPictureType),
            "ErrCameraTypeRepeated" => Some(Self::ErrCameraTypeRepeated),
            "ErrCameraWithoutOriginal" => Some(Self::ErrCameraWithoutOriginal),
            "ErrCameraWithoutThumbnailOrRender" => {
                Some(Self::ErrCameraWithoutThumbnailOrRender)
            }
            "ErrCameraPhotoNameEmpty" => Some(Self::ErrCameraPhotoNameEmpty),
            "ErrCameraPhotoNameOutMaxLen" => Some(Self::ErrCameraPhotoNameOutMaxLen),
            "ErrCameraAlbumNameEmpty" => Some(Self::ErrCameraAlbumNameEmpty),
            "ErrCameraPhotoHasDel" => Some(Self::ErrCameraPhotoHasDel),
            "ErrCameraSysInnerError" => Some(Self::ErrCameraSysInnerError),
            "ErrCameraIllegalPictureId" => Some(Self::ErrCameraIllegalPictureId),
            "ErrCameraBeyondMaxExtraLen" => Some(Self::ErrCameraBeyondMaxExtraLen),
            "ErrCameraNoIncludeOriginal" => Some(Self::ErrCameraNoIncludeOriginal),
            "ErrCameraNoDealingPhoto" => Some(Self::ErrCameraNoDealingPhoto),
            "ErrCameraNoDealingPhotoType" => Some(Self::ErrCameraNoDealingPhotoType),
            "ErrCameraNoAnyAlbum" => Some(Self::ErrCameraNoAnyAlbum),
            "ErrCameraNoPassReview" => Some(Self::ErrCameraNoPassReview),
            "ErrCameraPhotoMissImage" => Some(Self::ErrCameraPhotoMissImage),
            "ErrCameraWithoutThumbnail" => Some(Self::ErrCameraWithoutThumbnail),
            "ErrCameraBeyondMaxUploadTimes" => Some(Self::ErrCameraBeyondMaxUploadTimes),
            "ErrInvalidLifeProfessionId" => Some(Self::ErrInvalidLifeProfessionId),
            "ErrLifeProfessionIsUnlock" => Some(Self::ErrLifeProfessionIsUnlock),
            "ErrLifeProfessionMaxLevel" => Some(Self::ErrLifeProfessionMaxLevel),
            "ErrLifeProfessionLevelNotEnough" => {
                Some(Self::ErrLifeProfessionLevelNotEnough)
            }
            "ErrLifeProfessionLevelRewardGot" => {
                Some(Self::ErrLifeProfessionLevelRewardGot)
            }
            "ErrInvalidLifeProfessionSpecializationId" => {
                Some(Self::ErrInvalidLifeProfessionSpecializationId)
            }
            "ErrLifeProfessionSpecializationNotEnough" => {
                Some(Self::ErrLifeProfessionSpecializationNotEnough)
            }
            "ErrLifeProfessionSpecializationUpgradeError" => {
                Some(Self::ErrLifeProfessionSpecializationUpgradeError)
            }
            "ErrLifeProfessionPointNotEnough" => {
                Some(Self::ErrLifeProfessionPointNotEnough)
            }
            "ErrInvalidLifeProfessionTargetId" => {
                Some(Self::ErrInvalidLifeProfessionTargetId)
            }
            "ErrLifeProfessionTargetNotEnough" => {
                Some(Self::ErrLifeProfessionTargetNotEnough)
            }
            "ErrLifeProfessionRewardCanNotGet" => {
                Some(Self::ErrLifeProfessionRewardCanNotGet)
            }
            "ErrLifeProfessionEnergyChange" => Some(Self::ErrLifeProfessionEnergyChange),
            "ErrLifeProfessionRecipeIsUnlock" => {
                Some(Self::ErrLifeProfessionRecipeIsUnlock)
            }
            "ErrLifeProfessionRecipeNotExist" => {
                Some(Self::ErrLifeProfessionRecipeNotExist)
            }
            "ErrLifeProfessionRecipeNotUnlock" => {
                Some(Self::ErrLifeProfessionRecipeNotUnlock)
            }
            "ErrLifeProfessionMaxRDRecipeCount" => {
                Some(Self::ErrLifeProfessionMaxRdRecipeCount)
            }
            "ErrLifeProfessionWorkingNotEnd" => {
                Some(Self::ErrLifeProfessionWorkingNotEnd)
            }
            "ErrLifeProfessionAlreadyWorking" => {
                Some(Self::ErrLifeProfessionAlreadyWorking)
            }
            "ErrLifeProfessionNotWorking" => Some(Self::ErrLifeProfessionNotWorking),
            "ErrLifeProfessionWorkingIsEnd" => Some(Self::ErrLifeProfessionWorkingIsEnd),
            "ErrLifeProfessionUnActiveSpecialization" => {
                Some(Self::ErrLifeProfessionUnActiveSpecialization)
            }
            "ErrCurLevelConfigNotExist" => Some(Self::ErrCurLevelConfigNotExist),
            "ErrNeedBreakthrough" => Some(Self::ErrNeedBreakthrough),
            "ErrExperienceConfigNotExist" => Some(Self::ErrExperienceConfigNotExist),
            "ErrExperienceMismatch" => Some(Self::ErrExperienceMismatch),
            "ErrNotNeedToBreakthrough" => Some(Self::ErrNotNeedToBreakthrough),
            "ErrConsumeConfigError" => Some(Self::ErrConsumeConfigError),
            "ErrSkillNotExist" => Some(Self::ErrSkillNotExist),
            "ErrSkillLevelMax" => Some(Self::ErrSkillLevelMax),
            "ErrSkillLevelNotExist" => Some(Self::ErrSkillLevelNotExist),
            "ErrSkillConfigError" => Some(Self::ErrSkillConfigError),
            "ErrStarNotExist" => Some(Self::ErrStarNotExist),
            "ErrMaxStar" => Some(Self::ErrMaxStar),
            "ErrMaxLevel" => Some(Self::ErrMaxLevel),
            "ErrSkillLevelNotEnough" => Some(Self::ErrSkillLevelNotEnough),
            "ErrCanNotChangeActionState" => Some(Self::ErrCanNotChangeActionState),
            "ErrActionNotExist" => Some(Self::ErrActionNotExist),
            "ErrIsInteracting" => Some(Self::ErrIsInteracting),
            "ErrState" => Some(Self::ErrState),
            "ErrRequestExpired" => Some(Self::ErrRequestExpired),
            "ErrStateSetFailed" => Some(Self::ErrStateSetFailed),
            "ErrCollectIdError" => Some(Self::ErrCollectIdError),
            "ErrCollectStateFailed" => Some(Self::ErrCollectStateFailed),
            "ErrCollectActorErr" => Some(Self::ErrCollectActorErr),
            "ErrCollectOutRange" => Some(Self::ErrCollectOutRange),
            "ErrCollectConditionEquip" => Some(Self::ErrCollectConditionEquip),
            "ErrCollectConditionQuest" => Some(Self::ErrCollectConditionQuest),
            "ErrAlreadyCollected" => Some(Self::ErrAlreadyCollected),
            "ErrMailGetFailed" => Some(Self::ErrMailGetFailed),
            "ErrMailIllegality" => Some(Self::ErrMailIllegality),
            "ErrMailIsGet" => Some(Self::ErrMailIsGet),
            "ErrMailIsDel" => Some(Self::ErrMailIsDel),
            "ErrMailAcceptorEmpty" => Some(Self::ErrMailAcceptorEmpty),
            "ErrMailTokenInvalid" => Some(Self::ErrMailTokenInvalid),
            "ErrUnRegisterType" => Some(Self::ErrUnRegisterType),
            "ErrIndexNotFound" => Some(Self::ErrIndexNotFound),
            "ErrCantOpenTreasureBox" => Some(Self::ErrCantOpenTreasureBox),
            "ErrPersonalStateEnd" => Some(Self::ErrPersonalStateEnd),
            "ErrPersonalObjectStatus" => Some(Self::ErrPersonalObjectStatus),
            "ErrExp" => Some(Self::ErrExp),
            "ErrLevel" => Some(Self::ErrLevel),
            "ErrAward" => Some(Self::ErrAward),
            "ErrReceivedLevelAward" => Some(Self::ErrReceivedLevelAward),
            "ErrLevelNotEnough" => Some(Self::ErrLevelNotEnough),
            "ErrRoleLevelNoRewards" => Some(Self::ErrRoleLevelNoRewards),
            "ErrUnionNotHaveLimit" => Some(Self::ErrUnionNotHaveLimit),
            "ErrUnionIsNotMember" => Some(Self::ErrUnionIsNotMember),
            "ErrUnionOfficialNotExits" => Some(Self::ErrUnionOfficialNotExits),
            "ErrUnionOfficialTooMany" => Some(Self::ErrUnionOfficialTooMany),
            "ErrUnionHas" => Some(Self::ErrUnionHas),
            "ErrUnionReqCd" => Some(Self::ErrUnionReqCd),
            "ErrUnionReqHas" => Some(Self::ErrUnionReqHas),
            "ErrUnionFull" => Some(Self::ErrUnionFull),
            "ErrUnionFailed" => Some(Self::ErrUnionFailed),
            "ErrUnionNameWrongful" => Some(Self::ErrUnionNameWrongful),
            "ErrUnionNameUsed" => Some(Self::ErrUnionNameUsed),
            "ErrUnionNameOccupied" => Some(Self::ErrUnionNameOccupied),
            "ErrApplyMax" => Some(Self::ErrApplyMax),
            "ErrUnionChangeNameCD" => Some(Self::ErrUnionChangeNameCd),
            "ErrUnionNameSizeError" => Some(Self::ErrUnionNameSizeError),
            "ErrDeclarationSize" => Some(Self::ErrDeclarationSize),
            "ErrDeclarationError" => Some(Self::ErrDeclarationError),
            "ErrOfficialNameRepeat" => Some(Self::ErrOfficialNameRepeat),
            "ErrDeclarationCd" => Some(Self::ErrDeclarationCd),
            "ErrUnionInfoCd" => Some(Self::ErrUnionInfoCd),
            "ErrUnionNotExist" => Some(Self::ErrUnionNotExist),
            "ErrUnionIllegalConditionType" => Some(Self::ErrUnionIllegalConditionType),
            "ErrUnionRecruitSloganTooLong" => Some(Self::ErrUnionRecruitSloganTooLong),
            "ErrUnionRecruitDescriptionTooLong" => {
                Some(Self::ErrUnionRecruitDescriptionTooLong)
            }
            "ErrUnionCreateTooOften" => Some(Self::ErrUnionCreateTooOften),
            "ErrUnionTagNoExist" => Some(Self::ErrUnionTagNoExist),
            "ErrUnionIconTooMuch" => Some(Self::ErrUnionIconTooMuch),
            "ErrUnionGetListCd" => Some(Self::ErrUnionGetListCd),
            "ErrUnionBatchSearchUnionIdsTooMuch" => {
                Some(Self::ErrUnionBatchSearchUnionIdsTooMuch)
            }
            "ErrUnionBatchSearchCd" => Some(Self::ErrUnionBatchSearchCd),
            "ErrUnionGetCollectedIdsCd" => Some(Self::ErrUnionGetCollectedIdsCd),
            "ErrUnionBeyondMaxCollectedNum" => Some(Self::ErrUnionBeyondMaxCollectedNum),
            "ErrUnionIdHasCollected" => Some(Self::ErrUnionIdHasCollected),
            "ErrUnionIdNoCollected" => Some(Self::ErrUnionIdNoCollected),
            "ErrUnionActiveValueNotEnough" => Some(Self::ErrUnionActiveValueNotEnough),
            "ErrUnionIllegalActiveId" => Some(Self::ErrUnionIllegalActiveId),
            "ErrUnionTooShortForAwards" => Some(Self::ErrUnionTooShortForAwards),
            "ErrUnionHasActiveAwards" => Some(Self::ErrUnionHasActiveAwards),
            "ErrUnionNoJoin" => Some(Self::ErrUnionNoJoin),
            "ErrUnionOnlyEnterSelf" => Some(Self::ErrUnionOnlyEnterSelf),
            "ErrUnionNoUnlockScene" => Some(Self::ErrUnionNoUnlockScene),
            "ErrUnionBuildingMaxLevel" => Some(Self::ErrUnionBuildingMaxLevel),
            "ErrUnionBuildingUpgrading" => Some(Self::ErrUnionBuildingUpgrading),
            "ErrUnionBuildingUpgradeNoFinish" => {
                Some(Self::ErrUnionBuildingUpgradeNoFinish)
            }
            "ErrUnionPrefixBuildNoMeet" => Some(Self::ErrUnionPrefixBuildNoMeet),
            "ErrUnionExperienceNoEnough" => Some(Self::ErrUnionExperienceNoEnough),
            "ErrUnionMoneyNoEnough" => Some(Self::ErrUnionMoneyNoEnough),
            "ErrUnionBuildingNoUpgrading" => Some(Self::ErrUnionBuildingNoUpgrading),
            "ErrUnionSpeedUpItemNoEnough" => Some(Self::ErrUnionSpeedUpItemNoEnough),
            "ErrUnionSpeedUpTimesOut" => Some(Self::ErrUnionSpeedUpTimesOut),
            "ErrUnionTryLater" => Some(Self::ErrUnionTryLater),
            "ErrUnionSpeedUpLevelError" => Some(Self::ErrUnionSpeedUpLevelError),
            "ErrUnionUpgradeHasCompleted" => Some(Self::ErrUnionUpgradeHasCompleted),
            "ErrUnionIllegalBuildIdLv" => Some(Self::ErrUnionIllegalBuildIdLv),
            "ErrUnionBeyMaxCount" => Some(Self::ErrUnionBeyMaxCount),
            "ErrUnionUserNoApply" => Some(Self::ErrUnionUserNoApply),
            "ErrUnionNoOneKeyNoMuch" => Some(Self::ErrUnionNoOneKeyNoMuch),
            "ErrUnionActivityNotStart" => Some(Self::ErrUnionActivityNotStart),
            "ErrUnionActivityNotProgress" => Some(Self::ErrUnionActivityNotProgress),
            "ErrUnionActivityAwardGet" => Some(Self::ErrUnionActivityAwardGet),
            "ErrUnionActivityNotEnjoy" => Some(Self::ErrUnionActivityNotEnjoy),
            "ErrUnionCreateTimeTooShort" => Some(Self::ErrUnionCreateTimeTooShort),
            "ErrUnionFunctionLock" => Some(Self::ErrUnionFunctionLock),
            "ErrUnionEScreenLock" => Some(Self::ErrUnionEScreenLock),
            "ErrUnionEScreenPositionLock" => Some(Self::ErrUnionEScreenPositionLock),
            "ErrUnionEScreenNoSet" => Some(Self::ErrUnionEScreenNoSet),
            "ErrUnionEScreenPositionNoSet" => Some(Self::ErrUnionEScreenPositionNoSet),
            "ErrUnionEffectGridLock" => Some(Self::ErrUnionEffectGridLock),
            "ErrUnionEffectIdLock" => Some(Self::ErrUnionEffectIdLock),
            "ErrUnionEffectPosNoSet" => Some(Self::ErrUnionEffectPosNoSet),
            "ErrUnionEffectPosHasEnd" => Some(Self::ErrUnionEffectPosHasEnd),
            "ErrUnionCrowFuncHasEnd" => Some(Self::ErrUnionCrowFuncHasEnd),
            "ErrUnionCrowFuncPosHasUsed" => Some(Self::ErrUnionCrowFuncPosHasUsed),
            "ErrUnionCrowFuncHasJoined" => Some(Self::ErrUnionCrowFuncHasJoined),
            "ErrUnionCrowFuncNoBegin" => Some(Self::ErrUnionCrowFuncNoBegin),
            "ErrUnionNoFinishBaseBuilding" => Some(Self::ErrUnionNoFinishBaseBuilding),
            "ErrUnionCrowFuncIllegalFuncPos" => {
                Some(Self::ErrUnionCrowFuncIllegalFuncPos)
            }
            "ErrUnionEScreenBeyondMaxTimes" => Some(Self::ErrUnionEScreenBeyondMaxTimes),
            "ErrUnionTargetFunctionLock" => Some(Self::ErrUnionTargetFunctionLock),
            "ErrUnionNoMeet" => Some(Self::ErrUnionNoMeet),
            "ErrUnionActivityAwardCd" => Some(Self::ErrUnionActivityAwardCd),
            "ErrUnionManagerNoKicked" => Some(Self::ErrUnionManagerNoKicked),
            "ErrUnionDanceNoBegin" => Some(Self::ErrUnionDanceNoBegin),
            "ErrUnionDanceEnd" => Some(Self::ErrUnionDanceEnd),
            "ErrUnionDanceDrawnBox" => Some(Self::ErrUnionDanceDrawnBox),
            "ErrUnionDanceBoxDrawn" => Some(Self::ErrUnionDanceBoxDrawn),
            "ErrUnionDanceNoDanceId" => Some(Self::ErrUnionDanceNoDanceId),
            "ErrUnionNoJoinDance" => Some(Self::ErrUnionNoJoinDance),
            "ErrUnionDanceNoDancing" => Some(Self::ErrUnionDanceNoDancing),
            "ErrUnionRejectInvite" => Some(Self::ErrUnionRejectInvite),
            "ErrUnionActivityHuntEnd" => Some(Self::ErrUnionActivityHuntEnd),
            "ErrUnionApplyListFull" => Some(Self::ErrUnionApplyListFull),
            "ErrUionApplyListExist" => Some(Self::ErrUionApplyListExist),
            "ErrUnionGroupIvalid" => Some(Self::ErrUnionGroupIvalid),
            "ErrRepeatedRequest" => Some(Self::ErrRepeatedRequest),
            "ErrHasBeenBlackened" => Some(Self::ErrHasBeenBlackened),
            "ErrNotFoundCharInfo" => Some(Self::ErrNotFoundCharInfo),
            "ErrInner" => Some(Self::ErrInner),
            "ErrParam" => Some(Self::ErrParam),
            "ErrSetShowPicture" => Some(Self::ErrSetShowPicture),
            "ErrSetSignature" => Some(Self::ErrSetSignature),
            "ErrSetHobbyMark" => Some(Self::ErrSetHobbyMark),
            "ErrSetTimeMark" => Some(Self::ErrSetTimeMark),
            "ErrSetRemind" => Some(Self::ErrSetRemind),
            "ErrSetTop" => Some(Self::ErrSetTop),
            "ErrAddFriend" => Some(Self::ErrAddFriend),
            "ErrSetProcessed" => Some(Self::ErrSetProcessed),
            "ErrSetRemark" => Some(Self::ErrSetRemark),
            "ErrDeleteFriend" => Some(Self::ErrDeleteFriend),
            "ErrNotFoundGroup" => Some(Self::ErrNotFoundGroup),
            "ErrNotExistInGroup" => Some(Self::ErrNotExistInGroup),
            "ErrChangeGroup" => Some(Self::ErrChangeGroup),
            "ErrPersonalState" => Some(Self::ErrPersonalState),
            "ErrOtherFriendMax" => Some(Self::ErrOtherFriendMax),
            "ErrCurFriendMax" => Some(Self::ErrCurFriendMax),
            "ErrConfig" => Some(Self::ErrConfig),
            "ErrAlreadyFriend" => Some(Self::ErrAlreadyFriend),
            "ErrSearchSelf" => Some(Self::ErrSearchSelf),
            "ErrSuggestionCd" => Some(Self::ErrSuggestionCd),
            "ErrGroupMax" => Some(Self::ErrGroupMax),
            "ErrGroupNotExist" => Some(Self::ErrGroupNotExist),
            "ErrGroupNameEmpty" => Some(Self::ErrGroupNameEmpty),
            "ErrIllegalCharacter" => Some(Self::ErrIllegalCharacter),
            "ErrStringMax" => Some(Self::ErrStringMax),
            "ErrOtherApplicationMax" => Some(Self::ErrOtherApplicationMax),
            "ErrFriendlinessAwardHasRecord" => Some(Self::ErrFriendlinessAwardHasRecord),
            "ErrFriendlinessLevelLowAwardLevel" => {
                Some(Self::ErrFriendlinessLevelLowAwardLevel)
            }
            "ErrFriendBeyondAllFriendNum" => Some(Self::ErrFriendBeyondAllFriendNum),
            "ErrFriendIsNoUserFriend" => Some(Self::ErrFriendIsNoUserFriend),
            "ErrFriendlinessIllegalAwardLevel" => {
                Some(Self::ErrFriendlinessIllegalAwardLevel)
            }
            "ErrFriendlinessLevelAwardIsEmpty" => {
                Some(Self::ErrFriendlinessLevelAwardIsEmpty)
            }
            "ErrFriendBeBlackenedByTarget" => Some(Self::ErrFriendBeBlackenedByTarget),
            "ErrFriendApplyEachOther" => Some(Self::ErrFriendApplyEachOther),
            "ErrFriendCallBySmallerCharId" => Some(Self::ErrFriendCallBySmallerCharId),
            "ErrFriendCallByBiggerCharId" => Some(Self::ErrFriendCallByBiggerCharId),
            "ErrFriendBeBlackenedBySmaller" => Some(Self::ErrFriendBeBlackenedBySmaller),
            "ErrFriendBeBlackenedByBigger" => Some(Self::ErrFriendBeBlackenedByBigger),
            "ErrFriendNoApply" => Some(Self::ErrFriendNoApply),
            "ErrFriendApplySelf" => Some(Self::ErrFriendApplySelf),
            "ErrUserNameFormat" => Some(Self::ErrUserNameFormat),
            "ErrFriendGetBaseTooOften" => Some(Self::ErrFriendGetBaseTooOften),
            "ErrFriendOnlyGetSelfBaseInfo" => Some(Self::ErrFriendOnlyGetSelfBaseInfo),
            "ErrActorGetFailed" => Some(Self::ErrActorGetFailed),
            "ErrPivotIsActive" => Some(Self::ErrPivotIsActive),
            "ErrPivotIsNotActive" => Some(Self::ErrPivotIsNotActive),
            "ErrBreakPointIsGet" => Some(Self::ErrBreakPointIsGet),
            "ErrActorIsNotPivot" => Some(Self::ErrActorIsNotPivot),
            "ErrActorIsNotBreakPoint" => Some(Self::ErrActorIsNotBreakPoint),
            "ErrActorIsBreakPointNotFull" => Some(Self::ErrActorIsBreakPointNotFull),
            "ErrPivotRewardIsGiven" => Some(Self::ErrPivotRewardIsGiven),
            "ErrNotInsight" => Some(Self::ErrNotInsight),
            "ErrLearnSkillFail" => Some(Self::ErrLearnSkillFail),
            "ErrRemoveSkillFail" => Some(Self::ErrRemoveSkillFail),
            "ErrUpdateSkillFail" => Some(Self::ErrUpdateSkillFail),
            "ErrSkillOperatorType" => Some(Self::ErrSkillOperatorType),
            "ErrContainerOperator" => Some(Self::ErrContainerOperator),
            "ErrExchangeFail" => Some(Self::ErrExchangeFail),
            "ErrExchangeFailInCombat" => Some(Self::ErrExchangeFailInCombat),
            "ErrAvatarBeyondMaxPictureSize" => Some(Self::ErrAvatarBeyondMaxPictureSize),
            "ErrGetTokenFailed" => Some(Self::ErrGetTokenFailed),
            "ErrPictureVerifyFailed" => Some(Self::ErrPictureVerifyFailed),
            "ErrPictureIllegalType" => Some(Self::ErrPictureIllegalType),
            "ErrPictureErrorInfo" => Some(Self::ErrPictureErrorInfo),
            "ErrPictureSizeInconsistent" => Some(Self::ErrPictureSizeInconsistent),
            "ErrPictureFuncTypeIllegal" => Some(Self::ErrPictureFuncTypeIllegal),
            "ErrPictureCallBackJudgeIllegal" => {
                Some(Self::ErrPictureCallBackJudgeIllegal)
            }
            "ErrPictureVerifyNoPass" => Some(Self::ErrPictureVerifyNoPass),
            "ErrPictureVerifyBackParamIllegal" => {
                Some(Self::ErrPictureVerifyBackParamIllegal)
            }
            "ErrPictureCallBackParamIllegal" => {
                Some(Self::ErrPictureCallBackParamIllegal)
            }
            "ErrPictureIllegalId" => Some(Self::ErrPictureIllegalId),
            "ErrPictureCosErrors" => Some(Self::ErrPictureCosErrors),
            "ErrPictureInnerSysErr" => Some(Self::ErrPictureInnerSysErr),
            "ErrPictureNoSetEnvCosSecretId" => Some(Self::ErrPictureNoSetEnvCosSecretId),
            "ErrPictureNoSetEnvCosSecretKey" => {
                Some(Self::ErrPictureNoSetEnvCosSecretKey)
            }
            "ErrPictureCheckInMachineLocked" => {
                Some(Self::ErrPictureCheckInMachineLocked)
            }
            "ErrPictureNoTryOutItem" => Some(Self::ErrPictureNoTryOutItem),
            "ErrPictureNoUploadItem" => Some(Self::ErrPictureNoUploadItem),
            "ErrPictureNoUnion" => Some(Self::ErrPictureNoUnion),
            "ErrNameSizeError" => Some(Self::ErrNameSizeError),
            "ErrSensitiveContent" => Some(Self::ErrSensitiveContent),
            "ErrChangeNameFail" => Some(Self::ErrChangeNameFail),
            "ErrChangeNameCardNotEnough" => Some(Self::ErrChangeNameCardNotEnough),
            "ErrChangeSameName" => Some(Self::ErrChangeSameName),
            "ErrCheckMuteWordsFailed" => Some(Self::ErrCheckMuteWordsFailed),
            "ErrCheckMuteWordsEmpty" => Some(Self::ErrCheckMuteWordsEmpty),
            "ErrChangeShowIdFail" => Some(Self::ErrChangeShowIdFail),
            "ErrChangeShowIdDuplicated" => Some(Self::ErrChangeShowIdDuplicated),
            "ErrChangeShowIdCardNotEnough" => Some(Self::ErrChangeShowIdCardNotEnough),
            "ErrFaceItemLock" => Some(Self::ErrFaceItemLock),
            "ErrFaceItemGender" => Some(Self::ErrFaceItemGender),
            "ErrFaceNoUploading" => Some(Self::ErrFaceNoUploading),
            "ErrFaceNoSupportFileSuffix" => Some(Self::ErrFaceNoSupportFileSuffix),
            "ErrFaceFileSuffixEmpty" => Some(Self::ErrFaceFileSuffixEmpty),
            "ErrFaceIllegalCosKey" => Some(Self::ErrFaceIllegalCosKey),
            "ErrFaceParseSuffixFailed" => Some(Self::ErrFaceParseSuffixFailed),
            "ErrFaceParseShortGuidFailed" => Some(Self::ErrFaceParseShortGuidFailed),
            "ErrProficiencyNeedUnlock" => Some(Self::ErrProficiencyNeedUnlock),
            "ErrProficiencyUnlock" => Some(Self::ErrProficiencyUnlock),
            "ErrUnlockItemNotEnough" => Some(Self::ErrUnlockItemNotEnough),
            "ErrTaskNotFinish" => Some(Self::ErrTaskNotFinish),
            "ErrStickerAwardIsGet" => Some(Self::ErrStickerAwardIsGet),
            "ErrBookAwardIsGet" => Some(Self::ErrBookAwardIsGet),
            "ErrInCd" => Some(Self::ErrInCd),
            "ErrMoneyNotEnough" => Some(Self::ErrMoneyNotEnough),
            "ErrShopItemCantBuy" => Some(Self::ErrShopItemCantBuy),
            "ErrShopBuyBusy" => Some(Self::ErrShopBuyBusy),
            "ErrPaymentConfigNotFound" => Some(Self::ErrPaymentConfigNotFound),
            "ErrRefreshShopCountExceed" => Some(Self::ErrRefreshShopCountExceed),
            "ErrShopCouponNotEnough" => Some(Self::ErrShopCouponNotEnough),
            "ErrShopCouponLimitNum" => Some(Self::ErrShopCouponLimitNum),
            "ErrShopCantBuyNoPrice" => Some(Self::ErrShopCantBuyNoPrice),
            "ErrNotFoundMonster" => Some(Self::ErrNotFoundMonster),
            "ErrNotMonster" => Some(Self::ErrNotMonster),
            "ErrMonsterUnlockExist" => Some(Self::ErrMonsterUnlockExist),
            "ErrMonsterAwardIsGet" => Some(Self::ErrMonsterAwardIsGet),
            "ErrMonsterTargetNotFinish" => Some(Self::ErrMonsterTargetNotFinish),
            "ErrDropTypeNotSupport" => Some(Self::ErrDropTypeNotSupport),
            "ErrCounterNotEnough" => Some(Self::ErrCounterNotEnough),
            "ErrDropItemAlreadyPicked" => Some(Self::ErrDropItemAlreadyPicked),
            "ErrInteractionDoing" => Some(Self::ErrInteractionDoing),
            "ErrInteractionCondition" => Some(Self::ErrInteractionCondition),
            "ErrInteractionNotMore" => Some(Self::ErrInteractionNotMore),
            "ErrInteractionExistPos" => Some(Self::ErrInteractionExistPos),
            "ErrInteractionNotExist" => Some(Self::ErrInteractionNotExist),
            "ErrInteractionEntityNotExist" => Some(Self::ErrInteractionEntityNotExist),
            "ErrInteractionHandleNotExist" => Some(Self::ErrInteractionHandleNotExist),
            "ErrInteractionType" => Some(Self::ErrInteractionType),
            "ErrInteractionBan" => Some(Self::ErrInteractionBan),
            "ErrInteractionConfig" => Some(Self::ErrInteractionConfig),
            "ErrInteractionNotOneself" => Some(Self::ErrInteractionNotOneself),
            "ErrInteractionDistance" => Some(Self::ErrInteractionDistance),
            "ErrShowPieceIllegalPieceType" => Some(Self::ErrShowPieceIllegalPieceType),
            "ErrShowPieceIllegalPieceId" => Some(Self::ErrShowPieceIllegalPieceId),
            "ErrShowPieceNoInOftenUseList" => Some(Self::ErrShowPieceNoInOftenUseList),
            "ErrShowPieceNoUnlockList" => Some(Self::ErrShowPieceNoUnlockList),
            "ErrShowPieceRoulettePositionNoSet" => {
                Some(Self::ErrShowPieceRoulettePositionNoSet)
            }
            "ErrShowPieceBeyondOftenUseMaxLen" => {
                Some(Self::ErrShowPieceBeyondOftenUseMaxLen)
            }
            "ErrShowPieceBeyondOftenRoulettePositionNum" => {
                Some(Self::ErrShowPieceBeyondOftenRoulettePositionNum)
            }
            "ErrShowPieceNoCommonPiece" => Some(Self::ErrShowPieceNoCommonPiece),
            "ErrShowPieceNoTakeOn" => Some(Self::ErrShowPieceNoTakeOn),
            "ErrProfessionActivated" => Some(Self::ErrProfessionActivated),
            "ErrProfessionNotHas" => Some(Self::ErrProfessionNotHas),
            "ErrProfessionSlotErr" => Some(Self::ErrProfessionSlotErr),
            "ErrProfessionRemoveErr" => Some(Self::ErrProfessionRemoveErr),
            "ErrProfessionChangePlanFail" => Some(Self::ErrProfessionChangePlanFail),
            "ErrProfessionStarConfigNotExist" => {
                Some(Self::ErrProfessionStarConfigNotExist)
            }
            "ErrProfessionStarNodeUnlock" => Some(Self::ErrProfessionStarNodeUnlock),
            "ErrProfessionStarNodeNotUnlock" => {
                Some(Self::ErrProfessionStarNodeNotUnlock)
            }
            "ErrProfessionReplaceSkillNotExist" => {
                Some(Self::ErrProfessionReplaceSkillNotExist)
            }
            "ErrProfessionUpgradeNotGreaterCurLevel" => {
                Some(Self::ErrProfessionUpgradeNotGreaterCurLevel)
            }
            "ErrProfessionProfessionBeForged" => {
                Some(Self::ErrProfessionProfessionBeForged)
            }
            "ErrProfessionSlotTwoNotUnlock" => Some(Self::ErrProfessionSlotTwoNotUnlock),
            "ErrProfessionSkillAlreadyActive" => {
                Some(Self::ErrProfessionSkillAlreadyActive)
            }
            "ErrProfessionSkillRemodelLevelWrong" => {
                Some(Self::ErrProfessionSkillRemodelLevelWrong)
            }
            "ErrAoyiSkillAlreadyActive" => Some(Self::ErrAoyiSkillAlreadyActive),
            "ErrAoyiSkillRemodelConfigNotExist" => {
                Some(Self::ErrAoyiSkillRemodelConfigNotExist)
            }
            "ErrAoyiSkillRemodelLevelWrong" => Some(Self::ErrAoyiSkillRemodelLevelWrong),
            "ErrProfessionEquipInCombat" => Some(Self::ErrProfessionEquipInCombat),
            "ErrProfessionSwitchInCombat" => Some(Self::ErrProfessionSwitchInCombat),
            "ErrProfessionDungeonNotAllowSwitch" => {
                Some(Self::ErrProfessionDungeonNotAllowSwitch)
            }
            "ErrTalentIllegalTalentPoolId" => Some(Self::ErrTalentIllegalTalentPoolId),
            "ErrTalentBeyondCurTalentMaxPlanNum" => {
                Some(Self::ErrTalentBeyondCurTalentMaxPlanNum)
            }
            "ErrTalentPoolNoActive" => Some(Self::ErrTalentPoolNoActive),
            "ErrTalentPlanNoActive" => Some(Self::ErrTalentPlanNoActive),
            "ErrTalentIllegalTalentId" => Some(Self::ErrTalentIllegalTalentId),
            "ErrTalentTalentHasUnlocked" => Some(Self::ErrTalentTalentHasUnlocked),
            "ErrTalentTalentNoUnlocked" => Some(Self::ErrTalentTalentNoUnlocked),
            "ErrTalentChangeLvPassiveTalentMoreThanInPool" => {
                Some(Self::ErrTalentChangeLvPassiveTalentMoreThanInPool)
            }
            "ErrTalentRepeatedTalentId" => Some(Self::ErrTalentRepeatedTalentId),
            "ErrTalentNoPoolPassiveTalent" => Some(Self::ErrTalentNoPoolPassiveTalent),
            "ErrTalentTalentPointsNoEnough" => Some(Self::ErrTalentTalentPointsNoEnough),
            "ErrTalentPassiveTalentListNoEmpty" => {
                Some(Self::ErrTalentPassiveTalentListNoEmpty)
            }
            "ErrTalentIllegalTalentLevel" => Some(Self::ErrTalentIllegalTalentLevel),
            "ErrTalentNoMeetUpgradeCondition" => {
                Some(Self::ErrTalentNoMeetUpgradeCondition)
            }
            "ErrTalentNoSupportDownLevelNow" => {
                Some(Self::ErrTalentNoSupportDownLevelNow)
            }
            "ErrTalentNoMeetPrevTalentLv" => Some(Self::ErrTalentNoMeetPrevTalentLv),
            "ErrTalentNoMeetPrevTalentPoint" => {
                Some(Self::ErrTalentNoMeetPrevTalentPoint)
            }
            "ErrTalentTreeNodeBDExclusive" => Some(Self::ErrTalentTreeNodeBdExclusive),
            "ErrTalentTotalTalentPointNotEnough" => {
                Some(Self::ErrTalentTotalTalentPointNotEnough)
            }
            "ErrTalentPreTalentNodeNotActivated" => {
                Some(Self::ErrTalentPreTalentNodeNotActivated)
            }
            "ErrTalentResetTalentInCombat" => Some(Self::ErrTalentResetTalentInCombat),
            "ErrCookBookNotExist" => Some(Self::ErrCookBookNotExist),
            "ErrCookFoodNotEnough" => Some(Self::ErrCookFoodNotEnough),
            "ErrCookTypeMore" => Some(Self::ErrCookTypeMore),
            "ErrCookCountMore" => Some(Self::ErrCookCountMore),
            "ErrCookHasBook" => Some(Self::ErrCookHasBook),
            "ErrCookMaterialNotMatch" => Some(Self::ErrCookMaterialNotMatch),
            "ErrChatIllegalPrivateChatTarget" => {
                Some(Self::ErrChatIllegalPrivateChatTarget)
            }
            "ErrChatInTargetBlockList" => Some(Self::ErrChatInTargetBlockList),
            "ErrChatSendMsgBeyondMaxWords" => Some(Self::ErrChatSendMsgBeyondMaxWords),
            "ErrChatWorldChannelIdIsZero" => Some(Self::ErrChatWorldChannelIdIsZero),
            "ErrChatWorldChannelIdBeyondMaxId" => {
                Some(Self::ErrChatWorldChannelIdBeyondMaxId)
            }
            "ErrChatIllegalChannelType" => Some(Self::ErrChatIllegalChannelType),
            "ErrChatIllegalMsgType" => Some(Self::ErrChatIllegalMsgType),
            "ErrChatNoInGoalChannel" => Some(Self::ErrChatNoInGoalChannel),
            "ErrChatNeedConfigIdNotZero" => Some(Self::ErrChatNeedConfigIdNotZero),
            "ErrChatNeedMsgTextNotEmpty" => Some(Self::ErrChatNeedMsgTextNotEmpty),
            "ErrChatSendCdNoEnd" => Some(Self::ErrChatSendCdNoEnd),
            "ErrChatRecordListIsEmpty" => Some(Self::ErrChatRecordListIsEmpty),
            "ErrChatTargetNotInPrivateList" => Some(Self::ErrChatTargetNotInPrivateList),
            "ErrChatMsgIdMoreThanMaxReadMsgId" => {
                Some(Self::ErrChatMsgIdMoreThanMaxReadMsgId)
            }
            "ErrChatBeyondBlockListLimit" => Some(Self::ErrChatBeyondBlockListLimit),
            "ErrChatWorldChannelIdBeyondMaxNum" => {
                Some(Self::ErrChatWorldChannelIdBeyondMaxNum)
            }
            "ErrChatBeyondMaxRecordId" => Some(Self::ErrChatBeyondMaxRecordId),
            "ErrChatNoCreatePrivateSession" => Some(Self::ErrChatNoCreatePrivateSession),
            "ErrChatPrivateSessionHasExit" => Some(Self::ErrChatPrivateSessionHasExit),
            "ErrChatBeBan" => Some(Self::ErrChatBeBan),
            "ErrChatFileIdTooLong" => Some(Self::ErrChatFileIdTooLong),
            "ErrChatFileIdEmpty" => Some(Self::ErrChatFileIdEmpty),
            "ErrChatMsgInfoEmpty" => Some(Self::ErrChatMsgInfoEmpty),
            "ErrChatNoShareChannel" => Some(Self::ErrChatNoShareChannel),
            "ErrChatIllegalShareType" => Some(Self::ErrChatIllegalShareType),
            "ErrChatIllegalHolderType" => Some(Self::ErrChatIllegalHolderType),
            "ErrChatNoSupportShareType" => Some(Self::ErrChatNoSupportShareType),
            "ErrChatShareTpeNoChatId" => Some(Self::ErrChatShareTpeNoChatId),
            "ErrChatShareNoFishRank" => Some(Self::ErrChatShareNoFishRank),
            "ErrChatLevelLimit" => Some(Self::ErrChatLevelLimit),
            "ErrChatNoFoundBlockListLimit" => Some(Self::ErrChatNoFoundBlockListLimit),
            "ErrTalentModTalentTagNotExist" => Some(Self::ErrTalentModTalentTagNotExist),
            "ErrTextCheckForbidden" => Some(Self::ErrTextCheckForbidden),
            "ErrTextCheckNoSceneType" => Some(Self::ErrTextCheckNoSceneType),
            "ErrTextCheckIllegal" => Some(Self::ErrTextCheckIllegal),
            "ErrTextCheckHttpError" => Some(Self::ErrTextCheckHttpError),
            "ErrTextCheckTooManyItems" => Some(Self::ErrTextCheckTooManyItems),
            "ErrConditionTimerOpen" => Some(Self::ErrConditionTimerOpen),
            "ErrConditionOpenServer" => Some(Self::ErrConditionOpenServer),
            "ErrSkillDisable" => Some(Self::ErrSkillDisable),
            "ErrSkillIsCD" => Some(Self::ErrSkillIsCd),
            "ErrSkillMaxPassiveCount" => Some(Self::ErrSkillMaxPassiveCount),
            "ErrSkillInit" => Some(Self::ErrSkillInit),
            "ErrSkillInfo" => Some(Self::ErrSkillInfo),
            "ErrUseSkillFightResInsufficient" => {
                Some(Self::ErrUseSkillFightResInsufficient)
            }
            "ErrUseSkillBuffNotEnough" => Some(Self::ErrUseSkillBuffNotEnough),
            "ErrUseSkillItemInsufficient" => Some(Self::ErrUseSkillItemInsufficient),
            "ErrUseSkillAttrInsufficient" => Some(Self::ErrUseSkillAttrInsufficient),
            "ErrUseSkillEnduranceInsufficient" => {
                Some(Self::ErrUseSkillEnduranceInsufficient)
            }
            "ErrUseSkillStateChange" => Some(Self::ErrUseSkillStateChange),
            "ErrUseSkillClientSkillUuid" => Some(Self::ErrUseSkillClientSkillUuid),
            "ErrFightLogicConditionBlockInvalid" => {
                Some(Self::ErrFightLogicConditionBlockInvalid)
            }
            "ErrFightLogicActionGroupInvalid" => {
                Some(Self::ErrFightLogicActionGroupInvalid)
            }
            "ErrFightLogicConditionNotMatch" => {
                Some(Self::ErrFightLogicConditionNotMatch)
            }
            "ErrFightLogicRunDataInvalid" => Some(Self::ErrFightLogicRunDataInvalid),
            "ErrSkillStageNotFind" => Some(Self::ErrSkillStageNotFind),
            "ErrConditionCfgSize" => Some(Self::ErrConditionCfgSize),
            "ErrConditionDissatisfy" => Some(Self::ErrConditionDissatisfy),
            "ErrConditionObjectIsNull" => Some(Self::ErrConditionObjectIsNull),
            "ErrConditionTypeNotFound" => Some(Self::ErrConditionTypeNotFound),
            "ErrConditionEntityDeath" => Some(Self::ErrConditionEntityDeath),
            "ErrConditionUnionLevel" => Some(Self::ErrConditionUnionLevel),
            "ErrConditionUnionMoney" => Some(Self::ErrConditionUnionMoney),
            "ErrConditionNotMeet" => Some(Self::ErrConditionNotMeet),
            "ErrConditionNotInShapeShift" => Some(Self::ErrConditionNotInShapeShift),
            "ErrSeasonAchievementNoExist" => Some(Self::ErrSeasonAchievementNoExist),
            "ErrSeasonAchievementNoFinish" => Some(Self::ErrSeasonAchievementNoFinish),
            "ErrSeasonAchievementHasReceived" => {
                Some(Self::ErrSeasonAchievementHasReceived)
            }
            "ErrSeasonAchievementPrevIdNoReceived" => {
                Some(Self::ErrSeasonAchievementPrevIdNoReceived)
            }
            "ErrSeasonAchievementPrevIdNoExist" => {
                Some(Self::ErrSeasonAchievementPrevIdNoExist)
            }
            "ErrSeasonAchievementTargetConfigError" => {
                Some(Self::ErrSeasonAchievementTargetConfigError)
            }
            "ErrSeasonRankHasMax" => Some(Self::ErrSeasonRankHasMax),
            "ErrSeasonRankHasReceived" => Some(Self::ErrSeasonRankHasReceived),
            "ErrSeasonRankNoAchieve" => Some(Self::ErrSeasonRankNoAchieve),
            "ErrSeasonRankCurSeasonIdZero" => Some(Self::ErrSeasonRankCurSeasonIdZero),
            "ErrSeasonRankNoMeetCondition" => Some(Self::ErrSeasonRankNoMeetCondition),
            "ErrSeasonRankSeasonNoSame" => Some(Self::ErrSeasonRankSeasonNoSame),
            "ErrBattlePassBuyLevel" => Some(Self::ErrBattlePassBuyLevel),
            "ErrBattlePassBuyMaterial" => Some(Self::ErrBattlePassBuyMaterial),
            "ErrBattlePassAwardGet" => Some(Self::ErrBattlePassAwardGet),
            "ErrBattlePassAwardNotUnlock" => Some(Self::ErrBattlePassAwardNotUnlock),
            "ErrBattlePassBuyWeekExpLimit" => Some(Self::ErrBattlePassBuyWeekExpLimit),
            "ErrBattlePassLevelError" => Some(Self::ErrBattlePassLevelError),
            "ErrNoRefreshTimes" => Some(Self::ErrNoRefreshTimes),
            "ErrTargetNotCompleted" => Some(Self::ErrTargetNotCompleted),
            "ErrOnlinePeriodTooMore" => Some(Self::ErrOnlinePeriodTooMore),
            "ErrPersonalTagTooMore" => Some(Self::ErrPersonalTagTooMore),
            "ErrPersonalTagNotFound" => Some(Self::ErrPersonalTagNotFound),
            "ErrPersonalAvatarUnearned" => Some(Self::ErrPersonalAvatarUnearned),
            "ErrPersonalAvatarFrameUnearned" => {
                Some(Self::ErrPersonalAvatarFrameUnearned)
            }
            "ErrPersonalCardStyleUnearned" => Some(Self::ErrPersonalCardStyleUnearned),
            "ErrPersonalPhotoTooMore" => Some(Self::ErrPersonalPhotoTooMore),
            "ErrPersonalMedalUnearned" => Some(Self::ErrPersonalMedalUnearned),
            "ErrPersonalTargetUnlock" => Some(Self::ErrPersonalTargetUnlock),
            "ErrPersonalTargetAlreadyGet" => Some(Self::ErrPersonalTargetAlreadyGet),
            "ErrPersonalMedalInvalidSlot" => Some(Self::ErrPersonalMedalInvalidSlot),
            "ErrPersonalMedalDuplicateValue" => {
                Some(Self::ErrPersonalMedalDuplicateValue)
            }
            "ErrOnlinePeriodDuplicate" => Some(Self::ErrOnlinePeriodDuplicate),
            "ErrPersonalTagDuplicate" => Some(Self::ErrPersonalTagDuplicate),
            "ErrPersonalPhotoInvalidSlot" => Some(Self::ErrPersonalPhotoInvalidSlot),
            "ErrPersonalPhotoDuplicateValue" => {
                Some(Self::ErrPersonalPhotoDuplicateValue)
            }
            "ErrSeasonMedalNoMeetActiveCondition" => {
                Some(Self::ErrSeasonMedalNoMeetActiveCondition)
            }
            "ErrSeasonMedalNoMeetUpgradeCondition" => {
                Some(Self::ErrSeasonMedalNoMeetUpgradeCondition)
            }
            "ErrSeasonMedalActiveMeetNoEnough" => {
                Some(Self::ErrSeasonMedalActiveMeetNoEnough)
            }
            "ErrSeasonMedalUpgradeMeetNoEnough" => {
                Some(Self::ErrSeasonMedalUpgradeMeetNoEnough)
            }
            "ErrSeasonMedalIllegalNodeId" => Some(Self::ErrSeasonMedalIllegalNodeId),
            "ErrSeasonMedalChooseNodeIdBeyondMax" => {
                Some(Self::ErrSeasonMedalChooseNodeIdBeyondMax)
            }
            "ErrSeasonMedalHoleNoExist" => Some(Self::ErrSeasonMedalHoleNoExist),
            "ErrSeasonMedalHoleLock" => Some(Self::ErrSeasonMedalHoleLock),
            "ErrSeasonMedalNodeNoExist" => Some(Self::ErrSeasonMedalNodeNoExist),
            "ErrSeasonMedalHoleNoGet" => Some(Self::ErrSeasonMedalHoleNoGet),
            "ErrSeasonMedalMaxHoleLevel" => Some(Self::ErrSeasonMedalMaxHoleLevel),
            "ErrSeasonMedalCoreHoleLock" => Some(Self::ErrSeasonMedalCoreHoleLock),
            "ErrSeasonMedalUpgradeMoneyNoEnough" => {
                Some(Self::ErrSeasonMedalUpgradeMoneyNoEnough)
            }
            "ErrSeasonNoCoreHole" => Some(Self::ErrSeasonNoCoreHole),
            "ErrSeasonNoNormalHole" => Some(Self::ErrSeasonNoNormalHole),
            "ErrSeasonMedalNoUpgradeNormalHoleItem" => {
                Some(Self::ErrSeasonMedalNoUpgradeNormalHoleItem)
            }
            "ErrSceneLineNotExists" => Some(Self::ErrSceneLineNotExists),
            "ErrSceneLineRefreshCd" => Some(Self::ErrSceneLineRefreshCd),
            "ErrSceneLineNotSameScene" => Some(Self::ErrSceneLineNotSameScene),
            "ErrSceneLineSameLine" => Some(Self::ErrSceneLineSameLine),
            "ErrSceneLineInteracting" => Some(Self::ErrSceneLineInteracting),
            "ErrSceneLineUserDead" => Some(Self::ErrSceneLineUserDead),
            "ErrSceneLineFull" => Some(Self::ErrSceneLineFull),
            "ErrSceneLineChangeCd" => Some(Self::ErrSceneLineChangeCd),
            "ErrSceneVersionRecycle" => Some(Self::ErrSceneVersionRecycle),
            "ErrSceneLineKick" => Some(Self::ErrSceneLineKick),
            "ErrInstallSlotFailed" => Some(Self::ErrInstallSlotFailed),
            "ErrUseSlotFailed" => Some(Self::ErrUseSlotFailed),
            "ErrUseSlotInCd" => Some(Self::ErrUseSlotInCd),
            "ErrInstatallSlotFailedInCombat" => {
                Some(Self::ErrInstatallSlotFailedInCombat)
            }
            "ErrSlotSkillUnLoad" => Some(Self::ErrSlotSkillUnLoad),
            "ErrUseCfgSkillFailed" => Some(Self::ErrUseCfgSkillFailed),
            "ErrResonanceNotExists" => Some(Self::ErrResonanceNotExists),
            "ErrResonanceUnLoad" => Some(Self::ErrResonanceUnLoad),
            "ErrUseDodgeFailed" => Some(Self::ErrUseDodgeFailed),
            "ErrUseFixedSkillFailed" => Some(Self::ErrUseFixedSkillFailed),
            "ErrUseBlockedSkill" => Some(Self::ErrUseBlockedSkill),
            "ErrInstallBlockedSkill" => Some(Self::ErrInstallBlockedSkill),
            "ErrExchangeNotFound" => Some(Self::ErrExchangeNotFound),
            "ErrExchangeNotEnough" => Some(Self::ErrExchangeNotEnough),
            "ErrExchangeItemLimit" => Some(Self::ErrExchangeItemLimit),
            "ErrExchangeStepRange" => Some(Self::ErrExchangeStepRange),
            "ErrExchangeItemFull" => Some(Self::ErrExchangeItemFull),
            "ErrExchangePackageFull" => Some(Self::ErrExchangePackageFull),
            "ErrExchangePriceItemNotFind" => Some(Self::ErrExchangePriceItemNotFind),
            "ErrExchangeBuyNumNotEnough" => Some(Self::ErrExchangeBuyNumNotEnough),
            "ErrExchangeBuyItemNotFound" => Some(Self::ErrExchangeBuyItemNotFound),
            "ErrExchangeTakeFailDelayTime" => Some(Self::ErrExchangeTakeFailDelayTime),
            "ErrExchangeTakeFailSellNum" => Some(Self::ErrExchangeTakeFailSellNum),
            "ErrExchangeTakeItemNotFound" => Some(Self::ErrExchangeTakeItemNotFound),
            "ErrExchangeWithdrawNoMoney" => Some(Self::ErrExchangeWithdrawNoMoney),
            "ErrExchangeDepositNotEnough" => Some(Self::ErrExchangeDepositNotEnough),
            "ErrExchangeItemNotBindOrCooldownNotExpire" => {
                Some(Self::ErrExchangeItemNotBindOrCooldownNotExpire)
            }
            "ErrExchangeInCd" => Some(Self::ErrExchangeInCd),
            "ErrExchangeBuyCurrencyNoEnough" => {
                Some(Self::ErrExchangeBuyCurrencyNoEnough)
            }
            "ErrExchangeItemDelayTimeOver" => Some(Self::ErrExchangeItemDelayTimeOver),
            "ErrExchangeItemIsNotWithdraw" => Some(Self::ErrExchangeItemIsNotWithdraw),
            "ErrExchangeBuyItemLimit" => Some(Self::ErrExchangeBuyItemLimit),
            "ErrExchangeItemIsNotNoticeShopItem" => {
                Some(Self::ErrExchangeItemIsNotNoticeShopItem)
            }
            "ErrExchangeItemIsPreBuyAlready" => {
                Some(Self::ErrExchangeItemIsPreBuyAlready)
            }
            "ErrExchangeItemNotPublic" => Some(Self::ErrExchangeItemNotPublic),
            "ErrExchangeSaleRankExist" => Some(Self::ErrExchangeSaleRankExist),
            "ErrExchangeSaleItemFull" => Some(Self::ErrExchangeSaleItemFull),
            "ErrExchangeSaleDiamondNotEnough" => {
                Some(Self::ErrExchangeSaleDiamondNotEnough)
            }
            "ErrExchangeSaleItemNotExists" => Some(Self::ErrExchangeSaleItemNotExists),
            "ErrExchangeBuySaleCurrencyNoEnough" => {
                Some(Self::ErrExchangeBuySaleCurrencyNoEnough)
            }
            "ErrExchangeDiamondNotEnough" => Some(Self::ErrExchangeDiamondNotEnough),
            "ErrExchangeSaleTakeOffCd" => Some(Self::ErrExchangeSaleTakeOffCd),
            "ErrExchangeSaleRateInvalid" => Some(Self::ErrExchangeSaleRateInvalid),
            "ErrExchangePreItemFull" => Some(Self::ErrExchangePreItemFull),
            "ErrExchangeSaleNumInvalid" => Some(Self::ErrExchangeSaleNumInvalid),
            "ErrExchangeCareItemAlready" => Some(Self::ErrExchangeCareItemAlready),
            "ErrExchangePriceRange" => Some(Self::ErrExchangePriceRange),
            "ErrExchangeRequestLimit" => Some(Self::ErrExchangeRequestLimit),
            "ErrExchangeItemBanned" => Some(Self::ErrExchangeItemBanned),
            "ErrExchangePriceNotLow" => Some(Self::ErrExchangePriceNotLow),
            "ErrExchangeItemNotFind" => Some(Self::ErrExchangeItemNotFind),
            "ErrExchangeItemExistMinPrice" => Some(Self::ErrExchangeItemExistMinPrice),
            "ErrExchangeNoticeItemMin" => Some(Self::ErrExchangeNoticeItemMin),
            "ErrExchangePreBuyUserFull" => Some(Self::ErrExchangePreBuyUserFull),
            "ErrModHoleNotUnlock" => Some(Self::ErrModHoleNotUnlock),
            "ErrModNotExist" => Some(Self::ErrModNotExist),
            "ErrModSimilarRepeated" => Some(Self::ErrModSimilarRepeated),
            "ErrModTypeLimitExceeded" => Some(Self::ErrModTypeLimitExceeded),
            "ErrModPartNotExist" => Some(Self::ErrModPartNotExist),
            "ErrModPartEnhanceLimit" => Some(Self::ErrModPartEnhanceLimit),
            "ErrModInUse" => Some(Self::ErrModInUse),
            "ErrModAlreadyInstalled" => Some(Self::ErrModAlreadyInstalled),
            "ErrModInitConfigNotExist" => Some(Self::ErrModInitConfigNotExist),
            "ErrModPartOverflow" => Some(Self::ErrModPartOverflow),
            "ErrModCanNotLink" => Some(Self::ErrModCanNotLink),
            "ErrFishingNotUseBait" => Some(Self::ErrFishingNotUseBait),
            "ErrFishingRandomFailed" => Some(Self::ErrFishingRandomFailed),
            "ErrFishingAlreadyGetFishItem" => Some(Self::ErrFishingAlreadyGetFishItem),
            "ErrFishingGetFishIdWrong" => Some(Self::ErrFishingGetFishIdWrong),
            "ErrFishingNotGet" => Some(Self::ErrFishingNotGet),
            "ErrFishingNotResearchYet" => Some(Self::ErrFishingNotResearchYet),
            "ErrFishingNotUseRod" => Some(Self::ErrFishingNotUseRod),
            "ErrFishingNoSeat" => Some(Self::ErrFishingNoSeat),
            "ErrFishingCantResearch" => Some(Self::ErrFishingCantResearch),
            "ErrFishDrawnLevelAward" => Some(Self::ErrFishDrawnLevelAward),
            "ErrFishCannotDrawLevelAward" => Some(Self::ErrFishCannotDrawLevelAward),
            "ErrFishDrawnNoLevelAward" => Some(Self::ErrFishDrawnNoLevelAward),
            "ErrFreightNoRefreshGoods" => Some(Self::ErrFreightNoRefreshGoods),
            "ErrFreightBeyondMaxValue" => Some(Self::ErrFreightBeyondMaxValue),
            "ErrFreightDownMinValue" => Some(Self::ErrFreightDownMinValue),
            "ErrFreightHasSetOff" => Some(Self::ErrFreightHasSetOff),
            "ErrFreightNoSetOff" => Some(Self::ErrFreightNoSetOff),
            "ErrFreightHasReward" => Some(Self::ErrFreightHasReward),
            "ErrFreightIllegalGoodsId" => Some(Self::ErrFreightIllegalGoodsId),
            "ErrFreightItemNoEnough" => Some(Self::ErrFreightItemNoEnough),
            "ErrFreightNoUpSetOffTime" => Some(Self::ErrFreightNoUpSetOffTime),
            "ErrFreightNoUpRewardTime" => Some(Self::ErrFreightNoUpRewardTime),
            "ErrFreightAutoSetOff" => Some(Self::ErrFreightAutoSetOff),
            "ErrTrialRoadAwardNotFinished" => Some(Self::ErrTrialRoadAwardNotFinished),
            "ErrTrialRoadAwardRoomGet" => Some(Self::ErrTrialRoadAwardRoomGet),
            "ErrNotCanRide" => Some(Self::ErrNotCanRide),
            "ErrCombatStateNotRide" => Some(Self::ErrCombatStateNotRide),
            "ErrAlreadyRide" => Some(Self::ErrAlreadyRide),
            "ErrRideNotEnough" => Some(Self::ErrRideNotEnough),
            "ErrCreateVehicleActorFailed" => Some(Self::ErrCreateVehicleActorFailed),
            "ErrNotVehicleOwner" => Some(Self::ErrNotVehicleOwner),
            "ErrVehicleHasController" => Some(Self::ErrVehicleHasController),
            "ErrVehicleNoSeat" => Some(Self::ErrVehicleNoSeat),
            "ErrVehicleHasSeat" => Some(Self::ErrVehicleHasSeat),
            "ErrNotRideVehicle" => Some(Self::ErrNotRideVehicle),
            "ErrVehicleNotExits" => Some(Self::ErrVehicleNotExits),
            "ErrInvalidRidePropertyType" => Some(Self::ErrInvalidRidePropertyType),
            "ErrRideApplyTargetUserNotExist" => {
                Some(Self::ErrRideApplyTargetUserNotExist)
            }
            "ErrRideConfigNotFind" => Some(Self::ErrRideConfigNotFind),
            "ErrRideNotUnlock" => Some(Self::ErrRideNotUnlock),
            "ErrRideNotFind" => Some(Self::ErrRideNotFind),
            "ErrInvalidRideType" => Some(Self::ErrInvalidRideType),
            "ErrRideApplyAlreadyExist" => Some(Self::ErrRideApplyAlreadyExist),
            "ErrRideApplyNotRideVehicle" => Some(Self::ErrRideApplyNotRideVehicle),
            "ErrRideApplyVehicleNotSeat" => Some(Self::ErrRideApplyVehicleNotSeat),
            "ErrRideAlReadyRide" => Some(Self::ErrRideAlReadyRide),
            "ErrRideApplyTargetTooFar" => Some(Self::ErrRideApplyTargetTooFar),
            "ErrRideNotTake" => Some(Self::ErrRideNotTake),
            "ErrRideInteracting" => Some(Self::ErrRideInteracting),
            "ErrShapeshiftNotRide" => Some(Self::ErrShapeshiftNotRide),
            "ErrFishingNotRide" => Some(Self::ErrFishingNotRide),
            "ErrRideStateReject" => Some(Self::ErrRideStateReject),
            "ErrRideTypeNotSupport" => Some(Self::ErrRideTypeNotSupport),
            "ErrRideNotControl" => Some(Self::ErrRideNotControl),
            "ErrRideNotFunction" => Some(Self::ErrRideNotFunction),
            "ErrRideSkinNotSupport" => Some(Self::ErrRideSkinNotSupport),
            "ErrRideSkinNotUnlock" => Some(Self::ErrRideSkinNotUnlock),
            "ErrRideSkinDataAddFailed" => Some(Self::ErrRideSkinDataAddFailed),
            "ErrRideSkinNotSkin" => Some(Self::ErrRideSkinNotSkin),
            "ErrRideSkinAlreadyActivate" => Some(Self::ErrRideSkinAlreadyActivate),
            "ErrWarehouseHas" => Some(Self::ErrWarehouseHas),
            "ErrWarehouseNoHas" => Some(Self::ErrWarehouseNoHas),
            "ErrWarehouseNoMem" => Some(Self::ErrWarehouseNoMem),
            "ErrWarehouseNoPresident" => Some(Self::ErrWarehouseNoPresident),
            "ErrWarehouseNoHasItem" => Some(Self::ErrWarehouseNoHasItem),
            "ErrWarehouseItemNoDeposit" => Some(Self::ErrWarehouseItemNoDeposit),
            "ErrWarehouseGridPosNoExist" => Some(Self::ErrWarehouseGridPosNoExist),
            "ErrWarehouseGridPosItemNoEnough" => {
                Some(Self::ErrWarehouseGridPosItemNoEnough)
            }
            "ErrWarehouseNoInviteSelf" => Some(Self::ErrWarehouseNoInviteSelf),
            "ErrWarehouseInviteesHas" => Some(Self::ErrWarehouseInviteesHas),
            "ErrWarehouseMemBeyondMax" => Some(Self::ErrWarehouseMemBeyondMax),
            "ErrWarehouseGridBeyondMax" => Some(Self::ErrWarehouseGridBeyondMax),
            "ErrWarehouseNoSelf" => Some(Self::ErrWarehouseNoSelf),
            "ErrWarehouseIsMem" => Some(Self::ErrWarehouseIsMem),
            "ErrWarehouseNoExist" => Some(Self::ErrWarehouseNoExist),
            "ErrWarehouseDepositBeyondMax" => Some(Self::ErrWarehouseDepositBeyondMax),
            "ErrWarehouseTakeOutBeyondMax" => Some(Self::ErrWarehouseTakeOutBeyondMax),
            "ErrWarehouseItemIdNotSame" => Some(Self::ErrWarehouseItemIdNotSame),
            "ErrWarehouseParams" => Some(Self::ErrWarehouseParams),
            "ErrWarehouseNoKickSelf" => Some(Self::ErrWarehouseNoKickSelf),
            "ErrWarehousePresidentNoExit" => Some(Self::ErrWarehousePresidentNoExit),
            "ErrGashaDrawCount" => Some(Self::ErrGashaDrawCount),
            "ErrGashaDrawLimit" => Some(Self::ErrGashaDrawLimit),
            "ErrGashaInvalidWishId" => Some(Self::ErrGashaInvalidWishId),
            "EErGashaWishRepeated" => Some(Self::EErGashaWishRepeated),
            "EErGashaWishCountNoEnough" => Some(Self::EErGashaWishCountNoEnough),
            "ErrWarehouseAuthority" => Some(Self::ErrWarehouseAuthority),
            "ErrEquipCantDecompose" => Some(Self::ErrEquipCantDecompose),
            "ErrEquipNotRecastRecord" => Some(Self::ErrEquipNotRecastRecord),
            "ErrEquipOnCantUsedRecastConsume" => {
                Some(Self::ErrEquipOnCantUsedRecastConsume)
            }
            "ErrEquipWeaponNotEqualProfession" => {
                Some(Self::ErrEquipWeaponNotEqualProfession)
            }
            "ErrEquipSlotRefineBlessNotFit" => Some(Self::ErrEquipSlotRefineBlessNotFit),
            "ErrEquipNotRecast" => Some(Self::ErrEquipNotRecast),
            "ErrEquipEnchantItemMismatch" => Some(Self::ErrEquipEnchantItemMismatch),
            "ErrEquipEnchantAlreadyEnchanted" => {
                Some(Self::ErrEquipEnchantAlreadyEnchanted)
            }
            "ErrEquipAnyItemMismatch" => Some(Self::ErrEquipAnyItemMismatch),
            "ErrEquipSlotRefineBlessNumTooMuch" => {
                Some(Self::ErrEquipSlotRefineBlessNumTooMuch)
            }
            "ErrEquipNameGroupNoMatch" => Some(Self::ErrEquipNameGroupNoMatch),
            "ErrEquipPerfectionNoMatch" => Some(Self::ErrEquipPerfectionNoMatch),
            "ErrEquipNotBreak" => Some(Self::ErrEquipNotBreak),
            "ErrEquipPutOnIng" => Some(Self::ErrEquipPutOnIng),
            "ErrUserIsMatching" => Some(Self::ErrUserIsMatching),
            "ErrUserNotInMatching" => Some(Self::ErrUserNotInMatching),
            "ErrUseNotWaitReady" => Some(Self::ErrUseNotWaitReady),
            "ErrDungeonCantMatch" => Some(Self::ErrDungeonCantMatch),
            "ErrMatchQueueFull" => Some(Self::ErrMatchQueueFull),
            "ErrCommonAwardCantReceive" => Some(Self::ErrCommonAwardCantReceive),
            "ErrCommonAwardHasReceived" => Some(Self::ErrCommonAwardHasReceived),
            "ErrCraftEnergyNotEnough" => Some(Self::ErrCraftEnergyNotEnough),
            "ErrCraftEnergyFull" => Some(Self::ErrCraftEnergyFull),
            "ErrRecommendPlayNotOpen" => Some(Self::ErrRecommendPlayNotOpen),
            "ErrWeeklyTowerNoStart" => Some(Self::ErrWeeklyTowerNoStart),
            "ErrWeeklyTowerHasEnd" => Some(Self::ErrWeeklyTowerHasEnd),
            "ErrWeeklyNoMeetProcessAward" => Some(Self::ErrWeeklyNoMeetProcessAward),
            "ErrWeeklyHasRewardProcessAward" => {
                Some(Self::ErrWeeklyHasRewardProcessAward)
            }
            "ErrWeeklyNoLayerStageAward" => Some(Self::ErrWeeklyNoLayerStageAward),
            "ErrWeekOnlyCurSeasonAward" => Some(Self::ErrWeekOnlyCurSeasonAward),
            "ErrWeeklyTowerCannotEnterLayer" => {
                Some(Self::ErrWeeklyTowerCannotEnterLayer)
            }
            "ErrWeeklyTowerBoxHasOpen" => Some(Self::ErrWeeklyTowerBoxHasOpen),
            "ErrWeeklyTowerNoBox" => Some(Self::ErrWeeklyTowerNoBox),
            "ErrWeeklyTowerNoStageAward" => Some(Self::ErrWeeklyTowerNoStageAward),
            "ErrWeeklyTowerNoTowerDungeon" => Some(Self::ErrWeeklyTowerNoTowerDungeon),
            "ErrFunctionNoAward" => Some(Self::ErrFunctionNoAward),
            "ErrFunctionHasDrawn" => Some(Self::ErrFunctionHasDrawn),
            "ErrTLogIllegalExportArea" => Some(Self::ErrTLogIllegalExportArea),
            "ErrPayOrderFail" => Some(Self::ErrPayOrderFail),
            "ErrPayCostNotEnough" => Some(Self::ErrPayCostNotEnough),
            "ErrPayCantBuy" => Some(Self::ErrPayCantBuy),
            "ErrPayCantExplore" => Some(Self::ErrPayCantExplore),
            "ErrActivityNotFind" => Some(Self::ErrActivityNotFind),
            "ErrActivityOffline" => Some(Self::ErrActivityOffline),
            "ErrActivityNotOpen" => Some(Self::ErrActivityNotOpen),
            "ErrActivityRewardNotFound" => Some(Self::ErrActivityRewardNotFound),
            "ErrActivityConditionNotFinish" => Some(Self::ErrActivityConditionNotFinish),
            "ErrActivityAlreadyObtain" => Some(Self::ErrActivityAlreadyObtain),
            "ErrActivityNotUnlock" => Some(Self::ErrActivityNotUnlock),
            "ErrEmojiConfigError" => Some(Self::ErrEmojiConfigError),
            "ErrEmojiAlreadyUnlock" => Some(Self::ErrEmojiAlreadyUnlock),
            "ErrEmojiUnlockItemError" => Some(Self::ErrEmojiUnlockItemError),
            "ErrEmojiUnlockItemErrorItemNotEnough" => {
                Some(Self::ErrEmojiUnlockItemErrorItemNotEnough)
            }
            "ErrEmojiUnlock" => Some(Self::ErrEmojiUnlock),
            "ErrGlobalConditionNotFound" => Some(Self::ErrGlobalConditionNotFound),
            "ErrGlobalConditionNotLuckyValue" => {
                Some(Self::ErrGlobalConditionNotLuckyValue)
            }
            "ErrPathFindingCant" => Some(Self::ErrPathFindingCant),
            "ErrPathFindingDataError" => Some(Self::ErrPathFindingDataError),
            "ErrPathFindingEndPosError" => Some(Self::ErrPathFindingEndPosError),
            "ErrPathFindingStartPosError" => Some(Self::ErrPathFindingStartPosError),
            "ErrPathFindingNoPath" => Some(Self::ErrPathFindingNoPath),
            "ErrSignNotOpen" => Some(Self::ErrSignNotOpen),
            "ErrSignNotSigned" => Some(Self::ErrSignNotSigned),
            "ErrSignAlreadySigned" => Some(Self::ErrSignAlreadySigned),
            "ErrSignTimeError" => Some(Self::ErrSignTimeError),
            "ErrTokenBucketLimit" => Some(Self::ErrTokenBucketLimit),
            "ErrUnknown" => Some(Self::ErrUnknown),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EItemBindFlag {
    ItemBindNone = 0,
    ItemNotBind = 1,
    ItemBindAll = 2,
}
impl EItemBindFlag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ItemBindNone => "ItemBindNone",
            Self::ItemNotBind => "ItemNotBind",
            Self::ItemBindAll => "ItemBindAll",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ItemBindNone" => Some(Self::ItemBindNone),
            "ItemNotBind" => Some(Self::ItemNotBind),
            "ItemBindAll" => Some(Self::ItemBindAll),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EQuestStepStatus {
    QuestStepGoing = 0,
    QuestStepFinish = 1,
    QuestStepFail = 2,
}
impl EQuestStepStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::QuestStepGoing => "QuestStepGoing",
            Self::QuestStepFinish => "QuestStepFinish",
            Self::QuestStepFail => "QuestStepFail",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QuestStepGoing" => Some(Self::QuestStepGoing),
            "QuestStepFinish" => Some(Self::QuestStepFinish),
            "QuestStepFail" => Some(Self::QuestStepFail),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EEquipEnchantType {
    EEquipEnchantNone = 0,
    EEquipEnchantOrdinary = 1,
    EEquipEnchantIntermediate = 2,
    EEquipEnchantAdvanced = 3,
}
impl EEquipEnchantType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EEquipEnchantNone => "EEquipEnchantNone",
            Self::EEquipEnchantOrdinary => "EEquipEnchantOrdinary",
            Self::EEquipEnchantIntermediate => "EEquipEnchantIntermediate",
            Self::EEquipEnchantAdvanced => "EEquipEnchantAdvanced",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EEquipEnchantNone" => Some(Self::EEquipEnchantNone),
            "EEquipEnchantOrdinary" => Some(Self::EEquipEnchantOrdinary),
            "EEquipEnchantIntermediate" => Some(Self::EEquipEnchantIntermediate),
            "EEquipEnchantAdvanced" => Some(Self::EEquipEnchantAdvanced),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EShowPieceType {
    ShowPieceNull = 0,
    ShowPieceNormalAction = 1,
    ShowPieceEmote = 2,
    ShowPieceDoubleAction = 3,
    ShowPieceSticker = 4,
}
impl EShowPieceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ShowPieceNull => "ShowPieceNull",
            Self::ShowPieceNormalAction => "ShowPieceNormalAction",
            Self::ShowPieceEmote => "ShowPieceEmote",
            Self::ShowPieceDoubleAction => "ShowPieceDoubleAction",
            Self::ShowPieceSticker => "ShowPieceSticker",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ShowPieceNull" => Some(Self::ShowPieceNull),
            "ShowPieceNormalAction" => Some(Self::ShowPieceNormalAction),
            "ShowPieceEmote" => Some(Self::ShowPieceEmote),
            "ShowPieceDoubleAction" => Some(Self::ShowPieceDoubleAction),
            "ShowPieceSticker" => Some(Self::ShowPieceSticker),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MonsterTargetAward {
    Null = 0,
    Get = 1,
    Received = 2,
}
impl MonsterTargetAward {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "MonsterTargetAwardNull",
            Self::Get => "MonsterTargetAwardGet",
            Self::Received => "MonsterTargetAwardReceived",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MonsterTargetAwardNull" => Some(Self::Null),
            "MonsterTargetAwardGet" => Some(Self::Get),
            "MonsterTargetAwardReceived" => Some(Self::Received),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EReceiveRewardStatus {
    NotReceive = 0,
    CanReceive = 1,
    Received = 2,
}
impl EReceiveRewardStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotReceive => "EReceiveRewardStatusNotReceive",
            Self::CanReceive => "EReceiveRewardStatusCanReceive",
            Self::Received => "EReceiveRewardStatusReceived",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EReceiveRewardStatusNotReceive" => Some(Self::NotReceive),
            "EReceiveRewardStatusCanReceive" => Some(Self::CanReceive),
            "EReceiveRewardStatusReceived" => Some(Self::Received),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ERidePropertyType {
    RidePropertyTypeNone = 0,
    RidePropertyTypeLand = 11,
    RidePropertyTypeWater = 12,
    RidePropertyTypeMax = 13,
}
impl ERidePropertyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RidePropertyTypeNone => "RidePropertyTypeNone",
            Self::RidePropertyTypeLand => "RidePropertyTypeLand",
            Self::RidePropertyTypeWater => "RidePropertyTypeWater",
            Self::RidePropertyTypeMax => "RidePropertyTypeMax",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RidePropertyTypeNone" => Some(Self::RidePropertyTypeNone),
            "RidePropertyTypeLand" => Some(Self::RidePropertyTypeLand),
            "RidePropertyTypeWater" => Some(Self::RidePropertyTypeWater),
            "RidePropertyTypeMax" => Some(Self::RidePropertyTypeMax),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LaunchPlatform {
    Null = 0,
    WeXin = 1001,
    Qq = 1002,
}
impl LaunchPlatform {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "LaunchPlatformNull",
            Self::WeXin => "LaunchPlatformWeXin",
            Self::Qq => "LaunchPlatformQq",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LaunchPlatformNull" => Some(Self::Null),
            "LaunchPlatformWeXin" => Some(Self::WeXin),
            "LaunchPlatformQq" => Some(Self::Qq),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EHomelandLamplightState {
    HomelandLamplightStateDefault = 0,
    HomelandLamplightStateOn = 1,
    HomelandLamplightStateOff = 2,
}
impl EHomelandLamplightState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HomelandLamplightStateDefault => "HomelandLamplightStateDefault",
            Self::HomelandLamplightStateOn => "HomelandLamplightStateOn",
            Self::HomelandLamplightStateOff => "HomelandLamplightStateOff",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HomelandLamplightStateDefault" => Some(Self::HomelandLamplightStateDefault),
            "HomelandLamplightStateOn" => Some(Self::HomelandLamplightStateOn),
            "HomelandLamplightStateOff" => Some(Self::HomelandLamplightStateOff),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EFarmlandState {
    Empty = 0,
    Grow = 1,
    Pollen = 2,
    Harvest = 3,
    Over = 4,
}
impl EFarmlandState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Empty => "EFarmlandStateEmpty",
            Self::Grow => "EFarmlandStateGrow",
            Self::Pollen => "EFarmlandStatePollen",
            Self::Harvest => "EFarmlandStateHarvest",
            Self::Over => "EFarmlandStateOver",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EFarmlandStateEmpty" => Some(Self::Empty),
            "EFarmlandStateGrow" => Some(Self::Grow),
            "EFarmlandStatePollen" => Some(Self::Pollen),
            "EFarmlandStateHarvest" => Some(Self::Harvest),
            "EFarmlandStateOver" => Some(Self::Over),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StructureOpType {
    Add = 0,
    Update = 1,
    Delete = 2,
}
impl StructureOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "StructureOpTypeAdd",
            Self::Update => "StructureOpTypeUpdate",
            Self::Delete => "StructureOpTypeDelete",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "StructureOpTypeAdd" => Some(Self::Add),
            "StructureOpTypeUpdate" => Some(Self::Update),
            "StructureOpTypeDelete" => Some(Self::Delete),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorldReconnectStatus {
    FastReconnect = 0,
    NewSession = 1,
}
impl WorldReconnectStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::FastReconnect => "FastReconnect",
            Self::NewSession => "NewSession",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FastReconnect" => Some(Self::FastReconnect),
            "NewSession" => Some(Self::NewSession),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonEventState {
    Null = 0,
    Running = 1,
    End = 2,
}
impl DungeonEventState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "DungeonEventStateNull",
            Self::Running => "DungeonEventStateRunning",
            Self::End => "DungeonEventStateEnd",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DungeonEventStateNull" => Some(Self::Null),
            "DungeonEventStateRunning" => Some(Self::Running),
            "DungeonEventStateEnd" => Some(Self::End),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DungeonEventResult {
    Null = 0,
    Success = 1,
    TimeOut = 2,
    Failed = 3,
    End = 4,
}
impl DungeonEventResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "DungeonEventResultNull",
            Self::Success => "DungeonEventResultSuccess",
            Self::TimeOut => "DungeonEventResultTimeOut",
            Self::Failed => "DungeonEventResultFailed",
            Self::End => "DungeonEventResultEnd",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DungeonEventResultNull" => Some(Self::Null),
            "DungeonEventResultSuccess" => Some(Self::Success),
            "DungeonEventResultTimeOut" => Some(Self::TimeOut),
            "DungeonEventResultFailed" => Some(Self::Failed),
            "DungeonEventResultEnd" => Some(Self::End),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDungeonState {
    DungeonStateNull = 0,
    DungeonStateActive = 1,
    DungeonStateReady = 2,
    DungeonStatePlaying = 3,
    DungeonStateEnd = 4,
    DungeonStateSettlement = 5,
    DungeonStateVote = 6,
}
impl EDungeonState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DungeonStateNull => "DungeonStateNull",
            Self::DungeonStateActive => "DungeonStateActive",
            Self::DungeonStateReady => "DungeonStateReady",
            Self::DungeonStatePlaying => "DungeonStatePlaying",
            Self::DungeonStateEnd => "DungeonStateEnd",
            Self::DungeonStateSettlement => "DungeonStateSettlement",
            Self::DungeonStateVote => "DungeonStateVote",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DungeonStateNull" => Some(Self::DungeonStateNull),
            "DungeonStateActive" => Some(Self::DungeonStateActive),
            "DungeonStateReady" => Some(Self::DungeonStateReady),
            "DungeonStatePlaying" => Some(Self::DungeonStatePlaying),
            "DungeonStateEnd" => Some(Self::DungeonStateEnd),
            "DungeonStateSettlement" => Some(Self::DungeonStateSettlement),
            "DungeonStateVote" => Some(Self::DungeonStateVote),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EHeroKeyRollType {
    HeroKeyRollTypeNull = 0,
    HeroKeyRollTypeGiveup = 1,
    HeroKeyRollTypeRoll = 2,
    HeroKeyRollTypeGet = 3,
    HeroKeyRollTypeRollGet = 4,
    HeroKeyRollTypeCountFull = 5,
}
impl EHeroKeyRollType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HeroKeyRollTypeNull => "HeroKeyRollTypeNull",
            Self::HeroKeyRollTypeGiveup => "HeroKeyRollTypeGiveup",
            Self::HeroKeyRollTypeRoll => "HeroKeyRollTypeRoll",
            Self::HeroKeyRollTypeGet => "HeroKeyRollTypeGet",
            Self::HeroKeyRollTypeRollGet => "HeroKeyRollTypeRollGet",
            Self::HeroKeyRollTypeCountFull => "HeroKeyRollTypeCountFull",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HeroKeyRollTypeNull" => Some(Self::HeroKeyRollTypeNull),
            "HeroKeyRollTypeGiveup" => Some(Self::HeroKeyRollTypeGiveup),
            "HeroKeyRollTypeRoll" => Some(Self::HeroKeyRollTypeRoll),
            "HeroKeyRollTypeGet" => Some(Self::HeroKeyRollTypeGet),
            "HeroKeyRollTypeRollGet" => Some(Self::HeroKeyRollTypeRollGet),
            "HeroKeyRollTypeCountFull" => Some(Self::HeroKeyRollTypeCountFull),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDungeonTimerType {
    DungeonTimerTypeNull = 0,
    DungeonTimerTypeRightCommon = 1,
    DungeonTimerTypeMiddlerCommon = 2,
    DungeonTimerTypeHero = 3,
    DungeonTimerTypeWait = 4,
    DungeonTimerTypePrepare = 5,
}
impl EDungeonTimerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DungeonTimerTypeNull => "DungeonTimerTypeNull",
            Self::DungeonTimerTypeRightCommon => "DungeonTimerTypeRightCommon",
            Self::DungeonTimerTypeMiddlerCommon => "DungeonTimerTypeMiddlerCommon",
            Self::DungeonTimerTypeHero => "DungeonTimerTypeHero",
            Self::DungeonTimerTypeWait => "DungeonTimerTypeWait",
            Self::DungeonTimerTypePrepare => "DungeonTimerTypePrepare",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DungeonTimerTypeNull" => Some(Self::DungeonTimerTypeNull),
            "DungeonTimerTypeRightCommon" => Some(Self::DungeonTimerTypeRightCommon),
            "DungeonTimerTypeMiddlerCommon" => Some(Self::DungeonTimerTypeMiddlerCommon),
            "DungeonTimerTypeHero" => Some(Self::DungeonTimerTypeHero),
            "DungeonTimerTypeWait" => Some(Self::DungeonTimerTypeWait),
            "DungeonTimerTypePrepare" => Some(Self::DungeonTimerTypePrepare),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDungeonTimerDirection {
    DungeonTimerDirectionDown = 0,
    DungeonTimerDirectionUp = 1,
}
impl EDungeonTimerDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DungeonTimerDirectionDown => "DungeonTimerDirectionDown",
            Self::DungeonTimerDirectionUp => "DungeonTimerDirectionUp",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DungeonTimerDirectionDown" => Some(Self::DungeonTimerDirectionDown),
            "DungeonTimerDirectionUp" => Some(Self::DungeonTimerDirectionUp),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDungeonTimerEffectType {
    Null = 0,
    Add = 1,
    Sub = 2,
    Change = 3,
}
impl EDungeonTimerEffectType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "EDungeonTimerEffectTypeNull",
            Self::Add => "EDungeonTimerEffectTypeAdd",
            Self::Sub => "EDungeonTimerEffectTypeSub",
            Self::Change => "EDungeonTimerEffectTypeChange",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDungeonTimerEffectTypeNull" => Some(Self::Null),
            "EDungeonTimerEffectTypeAdd" => Some(Self::Add),
            "EDungeonTimerEffectTypeSub" => Some(Self::Sub),
            "EDungeonTimerEffectTypeChange" => Some(Self::Change),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDungeonTimerTimerLookType {
    Default = 0,
    Red = 1,
}
impl EDungeonTimerTimerLookType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "EDungeonTimerTimerLookTypeDefault",
            Self::Red => "EDungeonTimerTimerLookTypeRed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDungeonTimerTimerLookTypeDefault" => Some(Self::Default),
            "EDungeonTimerTimerLookTypeRed" => Some(Self::Red),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EPictureType {
    ENormalPicture = 0,
    ECameraOriginal = 1,
    ECameraRender = 2,
    ECameraThumbnail = 3,
    EProfileSnapShot = 4,
    EProfileHalfBody = 5,
}
impl EPictureType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ENormalPicture => "ENormalPicture",
            Self::ECameraOriginal => "ECameraOriginal",
            Self::ECameraRender => "ECameraRender",
            Self::ECameraThumbnail => "ECameraThumbnail",
            Self::EProfileSnapShot => "EProfileSnapShot",
            Self::EProfileHalfBody => "EProfileHalfBody",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENormalPicture" => Some(Self::ENormalPicture),
            "ECameraOriginal" => Some(Self::ECameraOriginal),
            "ECameraRender" => Some(Self::ECameraRender),
            "ECameraThumbnail" => Some(Self::ECameraThumbnail),
            "EProfileSnapShot" => Some(Self::EProfileSnapShot),
            "EProfileHalfBody" => Some(Self::EProfileHalfBody),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EEntityType {
    EntErrType = 0,
    EntMonster = 1,
    EntNpc = 2,
    EntSceneObject = 3,
    EntZone = 5,
    EntBullet = 6,
    EntClientBullet = 7,
    EntPet = 8,
    EntChar = 10,
    EntDummy = 11,
    EntDrop = 12,
    EntField = 14,
    EntTrap = 15,
    EntCollection = 16,
    EntStaticObject = 18,
    EntVehicle = 19,
    EntToy = 20,
    EntCommunityHouse = 21,
    EntHouseItem = 22,
    EntCount = 23,
}
impl EEntityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EntErrType => "EntErrType",
            Self::EntMonster => "EntMonster",
            Self::EntNpc => "EntNpc",
            Self::EntSceneObject => "EntSceneObject",
            Self::EntZone => "EntZone",
            Self::EntBullet => "EntBullet",
            Self::EntClientBullet => "EntClientBullet",
            Self::EntPet => "EntPet",
            Self::EntChar => "EntChar",
            Self::EntDummy => "EntDummy",
            Self::EntDrop => "EntDrop",
            Self::EntField => "EntField",
            Self::EntTrap => "EntTrap",
            Self::EntCollection => "EntCollection",
            Self::EntStaticObject => "EntStaticObject",
            Self::EntVehicle => "EntVehicle",
            Self::EntToy => "EntToy",
            Self::EntCommunityHouse => "EntCommunityHouse",
            Self::EntHouseItem => "EntHouseItem",
            Self::EntCount => "EntCount",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EntErrType" => Some(Self::EntErrType),
            "EntMonster" => Some(Self::EntMonster),
            "EntNpc" => Some(Self::EntNpc),
            "EntSceneObject" => Some(Self::EntSceneObject),
            "EntZone" => Some(Self::EntZone),
            "EntBullet" => Some(Self::EntBullet),
            "EntClientBullet" => Some(Self::EntClientBullet),
            "EntPet" => Some(Self::EntPet),
            "EntChar" => Some(Self::EntChar),
            "EntDummy" => Some(Self::EntDummy),
            "EntDrop" => Some(Self::EntDrop),
            "EntField" => Some(Self::EntField),
            "EntTrap" => Some(Self::EntTrap),
            "EntCollection" => Some(Self::EntCollection),
            "EntStaticObject" => Some(Self::EntStaticObject),
            "EntVehicle" => Some(Self::EntVehicle),
            "EntToy" => Some(Self::EntToy),
            "EntCommunityHouse" => Some(Self::EntCommunityHouse),
            "EntHouseItem" => Some(Self::EntHouseItem),
            "EntCount" => Some(Self::EntCount),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EAppearType {
    EAppearNull = 0,
    EAppearTransferIn = 1,
    EAppearTransferPassLineIn = 2,
}
impl EAppearType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EAppearNull => "EAppearNull",
            Self::EAppearTransferIn => "EAppearTransferIn",
            Self::EAppearTransferPassLineIn => "EAppearTransferPassLineIn",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EAppearNull" => Some(Self::EAppearNull),
            "EAppearTransferIn" => Some(Self::EAppearTransferIn),
            "EAppearTransferPassLineIn" => Some(Self::EAppearTransferPassLineIn),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EGmParsingType {
    GmParsingJson = 0,
    GmParsingString = 1,
}
impl EGmParsingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GmParsingJson => "GmParsingJson",
            Self::GmParsingString => "GmParsingString",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GmParsingJson" => Some(Self::GmParsingJson),
            "GmParsingString" => Some(Self::GmParsingString),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EInteractionTemplateAction {
    EInteractionTemplateDefault = 0,
    EInteractionTemplateBegin = 1,
    EInteractionTemplateUpdate = 2,
    EInteractionTemplateEnd = 3,
    EInteractionTemplateAbort = 4,
    EInteractionTemplateStageEnd = 5,
}
impl EInteractionTemplateAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EInteractionTemplateDefault => "EInteractionTemplateDefault",
            Self::EInteractionTemplateBegin => "EInteractionTemplateBegin",
            Self::EInteractionTemplateUpdate => "EInteractionTemplateUpdate",
            Self::EInteractionTemplateEnd => "EInteractionTemplateEnd",
            Self::EInteractionTemplateAbort => "EInteractionTemplateAbort",
            Self::EInteractionTemplateStageEnd => "EInteractionTemplateStageEnd",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EInteractionTemplateDefault" => Some(Self::EInteractionTemplateDefault),
            "EInteractionTemplateBegin" => Some(Self::EInteractionTemplateBegin),
            "EInteractionTemplateUpdate" => Some(Self::EInteractionTemplateUpdate),
            "EInteractionTemplateEnd" => Some(Self::EInteractionTemplateEnd),
            "EInteractionTemplateAbort" => Some(Self::EInteractionTemplateAbort),
            "EInteractionTemplateStageEnd" => Some(Self::EInteractionTemplateStageEnd),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BuildFurnitureOpType {
    BuildFurnitureOpAdd = 0,
    BuildFurnitureOpUpdate = 1,
    BuildFurnitureOpDelete = 2,
}
impl BuildFurnitureOpType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BuildFurnitureOpAdd => "BuildFurnitureOpAdd",
            Self::BuildFurnitureOpUpdate => "BuildFurnitureOpUpdate",
            Self::BuildFurnitureOpDelete => "BuildFurnitureOpDelete",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BuildFurnitureOpAdd" => Some(Self::BuildFurnitureOpAdd),
            "BuildFurnitureOpUpdate" => Some(Self::BuildFurnitureOpUpdate),
            "BuildFurnitureOpDelete" => Some(Self::BuildFurnitureOpDelete),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EUserTransferType {
    Default = 0,
    ScenePosition = 1,
    ScenePosId = 2,
    Pivot = 3,
    CutScene = 4,
    Near = 5,
}
impl EUserTransferType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "EUserTransferTypeDefault",
            Self::ScenePosition => "EUserTransferTypeScenePosition",
            Self::ScenePosId => "EUserTransferTypeScenePosId",
            Self::Pivot => "EUserTransferTypePivot",
            Self::CutScene => "EUserTransferTypeCutScene",
            Self::Near => "EUserTransferTypeNear",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EUserTransferTypeDefault" => Some(Self::Default),
            "EUserTransferTypeScenePosition" => Some(Self::ScenePosition),
            "EUserTransferTypeScenePosId" => Some(Self::ScenePosId),
            "EUserTransferTypePivot" => Some(Self::Pivot),
            "EUserTransferTypeCutScene" => Some(Self::CutScene),
            "EUserTransferTypeNear" => Some(Self::Near),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ESceneLineStatus {
    SceneLineStatusNone = 0,
    SceneLineStatusLow = 1,
    SceneLineStatusMedium = 2,
    SceneLineStatusHigh = 3,
    SceneLineStatusFull = 4,
    SceneLineStatusRecycle = 5,
}
impl ESceneLineStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SceneLineStatusNone => "SceneLineStatusNone",
            Self::SceneLineStatusLow => "SceneLineStatusLow",
            Self::SceneLineStatusMedium => "SceneLineStatusMedium",
            Self::SceneLineStatusHigh => "SceneLineStatusHigh",
            Self::SceneLineStatusFull => "SceneLineStatusFull",
            Self::SceneLineStatusRecycle => "SceneLineStatusRecycle",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SceneLineStatusNone" => Some(Self::SceneLineStatusNone),
            "SceneLineStatusLow" => Some(Self::SceneLineStatusLow),
            "SceneLineStatusMedium" => Some(Self::SceneLineStatusMedium),
            "SceneLineStatusHigh" => Some(Self::SceneLineStatusHigh),
            "SceneLineStatusFull" => Some(Self::SceneLineStatusFull),
            "SceneLineStatusRecycle" => Some(Self::SceneLineStatusRecycle),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ETimerType {
    TimerTypeNull = 0,
    TimerTypePoint = 1,
    TimerTypeDay = 2,
    TimerTypeMonth = 3,
    TimerTypeWeek = 4,
    TimerTypeInterval = 5,
}
impl ETimerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TimerTypeNull => "TimerTypeNull",
            Self::TimerTypePoint => "TimerType_Point",
            Self::TimerTypeDay => "TimerType_Day",
            Self::TimerTypeMonth => "TimerType_Month",
            Self::TimerTypeWeek => "TimerType_Week",
            Self::TimerTypeInterval => "TimerType_Interval",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TimerTypeNull" => Some(Self::TimerTypeNull),
            "TimerType_Point" => Some(Self::TimerTypePoint),
            "TimerType_Day" => Some(Self::TimerTypeDay),
            "TimerType_Month" => Some(Self::TimerTypeMonth),
            "TimerType_Week" => Some(Self::TimerTypeWeek),
            "TimerType_Interval" => Some(Self::TimerTypeInterval),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ETimerExeType {
    TimerExeTypeNull = 0,
    TimerExeTypeStart = 1,
    TimerExeTypeEnd = 2,
    TimerExeTypeCycleStart = 3,
    TimerExeTypeCycleEnd = 4,
}
impl ETimerExeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TimerExeTypeNull => "TimerExeTypeNull",
            Self::TimerExeTypeStart => "TimerExeType_Start",
            Self::TimerExeTypeEnd => "TimerExeType_End",
            Self::TimerExeTypeCycleStart => "TimerExeType_Cycle_Start",
            Self::TimerExeTypeCycleEnd => "TimerExeType_Cycle_End",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TimerExeTypeNull" => Some(Self::TimerExeTypeNull),
            "TimerExeType_Start" => Some(Self::TimerExeTypeStart),
            "TimerExeType_End" => Some(Self::TimerExeTypeEnd),
            "TimerExeType_Cycle_Start" => Some(Self::TimerExeTypeCycleStart),
            "TimerExeType_Cycle_End" => Some(Self::TimerExeTypeCycleEnd),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ENotifyTrigger {
    ETypeInZone = 0,
    ETypeOutZone = 1,
    ETypeRange = 2,
}
impl ENotifyTrigger {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ETypeInZone => "ETypeInZone",
            Self::ETypeOutZone => "ETypeOutZone",
            Self::ETypeRange => "ETypeRange",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ETypeInZone" => Some(Self::ETypeInZone),
            "ETypeOutZone" => Some(Self::ETypeOutZone),
            "ETypeRange" => Some(Self::ETypeRange),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EUseSlotType {
    UseSlotTypeOther = 0,
    UseSlotTypeSkill = 1,
}
impl EUseSlotType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UseSlotTypeOther => "UseSlotType_Other",
            Self::UseSlotTypeSkill => "UseSlotType_Skill",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UseSlotType_Other" => Some(Self::UseSlotTypeOther),
            "UseSlotType_Skill" => Some(Self::UseSlotTypeSkill),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDisappearType {
    EDisappearNormal = 0,
    EDisappearDead = 1,
    EDisappearDestroy = 2,
    EDisappearTransferLeave = 3,
    EDisappearTransferPassLineLeave = 4,
}
impl EDisappearType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EDisappearNormal => "EDisappearNormal",
            Self::EDisappearDead => "EDisappearDead",
            Self::EDisappearDestroy => "EDisappearDestroy",
            Self::EDisappearTransferLeave => "EDisappearTransferLeave",
            Self::EDisappearTransferPassLineLeave => "EDisappearTransferPassLineLeave",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDisappearNormal" => Some(Self::EDisappearNormal),
            "EDisappearDead" => Some(Self::EDisappearDead),
            "EDisappearDestroy" => Some(Self::EDisappearDestroy),
            "EDisappearTransferLeave" => Some(Self::EDisappearTransferLeave),
            "EDisappearTransferPassLineLeave" => {
                Some(Self::EDisappearTransferPassLineLeave)
            }
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EActorState {
    ActorStateDefault = 0,
    ActorStateSinging = 1,
    ActorStateSkill = 2,
    ActorStateJump = 3,
    ActorStateRush = 4,
    ActorStateClimb = 5,
    ActorStateSwim = 6,
    ActorStateFishing = 7,
    ActorStateAction = 8,
    ActorStateDead = 9,
    ActorStateStiff = 10,
    ActorStateSwimStiff = 11,
    ActorStateBorn = 12,
    ActorStateTelePort = 13,
    ActorStateFall = 14,
    ActorStateFlow = 16,
    ActorStateGlide = 17,
    ActorStatePedalWall = 18,
    ActorStateFallTelePort = 19,
    ActorStateSelfPhoto = 20,
    ActorStateCollection = 21,
    ActorStateReset = 22,
    ActorStateBreaking = 23,
    ActorStateWeakness = 24,
    ActorStateFracture = 25,
    ActorStateAbnormal = 26,
    ActorStateResurrection = 27,
    ActorStateInteraction = 28,
    ActorStateSceneInteraction = 29,
    ActorStateTunnelFly = 30,
    ActorStateLevitation = 31,
    ActorStateHomelandEdit = 32,
    ActorStateRide = 33,
    ActorStateRideControl = 34,
    ActorStateAll = 35,
}
impl EActorState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ActorStateDefault => "ActorStateDefault",
            Self::ActorStateSinging => "ActorStateSinging",
            Self::ActorStateSkill => "ActorStateSkill",
            Self::ActorStateJump => "ActorStateJump",
            Self::ActorStateRush => "ActorStateRush",
            Self::ActorStateClimb => "ActorStateClimb",
            Self::ActorStateSwim => "ActorStateSwim",
            Self::ActorStateFishing => "ActorStateFishing",
            Self::ActorStateAction => "ActorStateAction",
            Self::ActorStateDead => "ActorStateDead",
            Self::ActorStateStiff => "ActorStateStiff",
            Self::ActorStateSwimStiff => "ActorStateSwimStiff",
            Self::ActorStateBorn => "ActorStateBorn",
            Self::ActorStateTelePort => "ActorStateTelePort",
            Self::ActorStateFall => "ActorStateFall",
            Self::ActorStateFlow => "ActorStateFlow",
            Self::ActorStateGlide => "ActorStateGlide",
            Self::ActorStatePedalWall => "ActorStatePedalWall",
            Self::ActorStateFallTelePort => "ActorStateFallTelePort",
            Self::ActorStateSelfPhoto => "ActorStateSelfPhoto",
            Self::ActorStateCollection => "ActorStateCollection",
            Self::ActorStateReset => "ActorStateReset",
            Self::ActorStateBreaking => "ActorStateBreaking",
            Self::ActorStateWeakness => "ActorStateWeakness",
            Self::ActorStateFracture => "ActorStateFracture",
            Self::ActorStateAbnormal => "ActorStateAbnormal",
            Self::ActorStateResurrection => "ActorStateResurrection",
            Self::ActorStateInteraction => "ActorStateInteraction",
            Self::ActorStateSceneInteraction => "ActorStateSceneInteraction",
            Self::ActorStateTunnelFly => "ActorStateTunnelFly",
            Self::ActorStateLevitation => "ActorStateLevitation",
            Self::ActorStateHomelandEdit => "ActorStateHomelandEdit",
            Self::ActorStateRide => "ActorStateRide",
            Self::ActorStateRideControl => "ActorStateRideControl",
            Self::ActorStateAll => "ActorStateAll",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ActorStateDefault" => Some(Self::ActorStateDefault),
            "ActorStateSinging" => Some(Self::ActorStateSinging),
            "ActorStateSkill" => Some(Self::ActorStateSkill),
            "ActorStateJump" => Some(Self::ActorStateJump),
            "ActorStateRush" => Some(Self::ActorStateRush),
            "ActorStateClimb" => Some(Self::ActorStateClimb),
            "ActorStateSwim" => Some(Self::ActorStateSwim),
            "ActorStateFishing" => Some(Self::ActorStateFishing),
            "ActorStateAction" => Some(Self::ActorStateAction),
            "ActorStateDead" => Some(Self::ActorStateDead),
            "ActorStateStiff" => Some(Self::ActorStateStiff),
            "ActorStateSwimStiff" => Some(Self::ActorStateSwimStiff),
            "ActorStateBorn" => Some(Self::ActorStateBorn),
            "ActorStateTelePort" => Some(Self::ActorStateTelePort),
            "ActorStateFall" => Some(Self::ActorStateFall),
            "ActorStateFlow" => Some(Self::ActorStateFlow),
            "ActorStateGlide" => Some(Self::ActorStateGlide),
            "ActorStatePedalWall" => Some(Self::ActorStatePedalWall),
            "ActorStateFallTelePort" => Some(Self::ActorStateFallTelePort),
            "ActorStateSelfPhoto" => Some(Self::ActorStateSelfPhoto),
            "ActorStateCollection" => Some(Self::ActorStateCollection),
            "ActorStateReset" => Some(Self::ActorStateReset),
            "ActorStateBreaking" => Some(Self::ActorStateBreaking),
            "ActorStateWeakness" => Some(Self::ActorStateWeakness),
            "ActorStateFracture" => Some(Self::ActorStateFracture),
            "ActorStateAbnormal" => Some(Self::ActorStateAbnormal),
            "ActorStateResurrection" => Some(Self::ActorStateResurrection),
            "ActorStateInteraction" => Some(Self::ActorStateInteraction),
            "ActorStateSceneInteraction" => Some(Self::ActorStateSceneInteraction),
            "ActorStateTunnelFly" => Some(Self::ActorStateTunnelFly),
            "ActorStateLevitation" => Some(Self::ActorStateLevitation),
            "ActorStateHomelandEdit" => Some(Self::ActorStateHomelandEdit),
            "ActorStateRide" => Some(Self::ActorStateRide),
            "ActorStateRideControl" => Some(Self::ActorStateRideControl),
            "ActorStateAll" => Some(Self::ActorStateAll),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EInteractionAction {
    None = 0,
    ToServer = 1,
    NpcTalk = 2,
    DungeonEntry = 3,
    FunctionEntry = 4,
    ClientSceneEvent = 5,
    OptionSelect = 6,
    HeroNormalDungeon = 7,
    HeroChallengeDungeon = 8,
    Revive = 9,
    VmFuction = 10,
    Tips = 11,
    OpenUi = 12,
    WindZone = 13,
    WindRing = 14,
    WindTornado = 15,
    DanceTogether = 16,
    StartFlow = 17,
    ShowCutScene = 18,
    UnionHuntEntry = 19,
    UnionBuild = 20,
    UnionBuildFunc = 21,
    ExploreMonsterDeplete = 22,
    UseSkill = 23,
    Fishing = 24,
    SendClientAiEvent = 25,
    DoNoThing = 27,
    CookFunc = 28,
    MoveToDistance = 29,
    MoveToPosition = 30,
    MoveToInteractionSeat = 31,
    RotateToTarget = 32,
    RotateToTargetAndWait = 33,
    AddClientBuff = 34,
    AddClientBuffAndWait = 35,
    AddClientBuffToTarget = 36,
    AddClientBuffToTargetAndWait = 37,
    ProgressBar = 38,
    CameraInvoke = 39,
    WaitUiConfirm = 40,
    IgnoreInput = 41,
    HideHud = 42,
    HideUi = 43,
    MoveToStaticObj = 44,
    UnionWarDance = 45,
    WaitInputMove = 46,
    RemoveClientBuff = 47,
    RemoveTargetClientBuff = 48,
    EnterAutoFlow = 49,
    NpcTalkFlow = 51,
    StartFlowAndWait = 52,
    ShowCutSceneAndWait = 53,
    SittingControl = 54,
    MagneticAttach = 55,
    SwitchCameraTemplate = 56,
    HomeFarm = 57,
    Lua = 999,
    Base = 1000,
    Pivot = 1001,
    PivotBreak = 1002,
    TransferPoint = 1003,
    LogicResonance = 1004,
    LogicStatic = 1005,
    LogicDance = 1006,
    AddBuff = 1007,
    Teleport = 1008,
    EnterDungeon = 1009,
    EnterVisualLayer = 1010,
    ExitVisualLayer = 1011,
    TriggerSceneEvent = 1012,
    TriggerSceneCustomEvent = 1013,
    UserDoAction = 1014,
    Pickup = 1015,
    OpenEliteTreasureBox = 1016,
    OpenBossTreasureBox = 1017,
    Quest = 1018,
    QuestEvent = 1019,
    KillSelf = 1020,
    SendAiEvent = 1021,
    DanceAwardNpc = 1022,
    RequestInteractionSeat = 1023,
    RemoveBuff = 1024,
    AddBuffToTarget = 1025,
    RemoveBuffToTarget = 1026,
    PaintToySwitchPage = 1027,
    OpenTowerTreasureBox = 1030,
    RoughCollection = 1031,
    FineCollection = 1032,
    BubbleActStart = 1033,
    BubbleActEnd = 1034,
    RaidOpenBox = 1035,
}
impl EInteractionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "EInteractionActionNone",
            Self::ToServer => "EInteractionActionToServer",
            Self::NpcTalk => "EInteractionActionNpcTalk",
            Self::DungeonEntry => "EInteractionActionDungeonEntry",
            Self::FunctionEntry => "EInteractionActionFunctionEntry",
            Self::ClientSceneEvent => "EInteractionActionClientSceneEvent",
            Self::OptionSelect => "EInteractionActionOptionSelect",
            Self::HeroNormalDungeon => "EInteractionActionHeroNormalDungeon",
            Self::HeroChallengeDungeon => "EInteractionActionHeroChallengeDungeon",
            Self::Revive => "EInteractionActionRevive",
            Self::VmFuction => "EInteractionActionVMFuction",
            Self::Tips => "EInteractionActionTips",
            Self::OpenUi => "EInteractionActionOpenUI",
            Self::WindZone => "EInteractionActionWindZone",
            Self::WindRing => "EInteractionActionWindRing",
            Self::WindTornado => "EInteractionActionWindTornado",
            Self::DanceTogether => "EInteractionActionDanceTogether",
            Self::StartFlow => "EInteractionActionStartFlow",
            Self::ShowCutScene => "EInteractionActionShowCutScene",
            Self::UnionHuntEntry => "EInteractionActionUnionHuntEntry",
            Self::UnionBuild => "EInteractionActionUnionBuild",
            Self::UnionBuildFunc => "EInteractionActionUnionBuildFunc",
            Self::ExploreMonsterDeplete => "EInteractionActionExploreMonsterDeplete",
            Self::UseSkill => "EInteractionActionUseSkill",
            Self::Fishing => "EInteractionActionFishing",
            Self::SendClientAiEvent => "EInteractionActionSendClientAiEvent",
            Self::DoNoThing => "EInteractionActionDoNoThing",
            Self::CookFunc => "EInteractionActionCookFunc",
            Self::MoveToDistance => "EInteractionActionMoveToDistance",
            Self::MoveToPosition => "EInteractionActionMoveToPosition",
            Self::MoveToInteractionSeat => "EInteractionActionMoveToInteractionSeat",
            Self::RotateToTarget => "EInteractionActionRotateToTarget",
            Self::RotateToTargetAndWait => "EInteractionActionRotateToTargetAndWait",
            Self::AddClientBuff => "EInteractionActionAddClientBuff",
            Self::AddClientBuffAndWait => "EInteractionActionAddClientBuffAndWait",
            Self::AddClientBuffToTarget => "EInteractionActionAddClientBuffToTarget",
            Self::AddClientBuffToTargetAndWait => {
                "EInteractionActionAddClientBuffToTargetAndWait"
            }
            Self::ProgressBar => "EInteractionActionProgressBar",
            Self::CameraInvoke => "EInteractionActionCameraInvoke",
            Self::WaitUiConfirm => "EInteractionActionWaitUiConfirm",
            Self::IgnoreInput => "EInteractionActionIgnoreInput",
            Self::HideHud => "EInteractionActionHideHud",
            Self::HideUi => "EInteractionActionHideUI",
            Self::MoveToStaticObj => "EInteractionActionMoveToStaticObj",
            Self::UnionWarDance => "EInteractionActionUnionWarDance",
            Self::WaitInputMove => "EInteractionActionWaitInputMove",
            Self::RemoveClientBuff => "EInteractionActionRemoveClientBuff",
            Self::RemoveTargetClientBuff => "EInteractionActionRemoveTargetClientBuff",
            Self::EnterAutoFlow => "EInteractionActionEnterAutoFlow",
            Self::NpcTalkFlow => "EInteractionActionNpcTalkFlow",
            Self::StartFlowAndWait => "EInteractionActionStartFlowAndWait",
            Self::ShowCutSceneAndWait => "EInteractionActionShowCutSceneAndWait",
            Self::SittingControl => "EInteractionActionSittingControl",
            Self::MagneticAttach => "EInteractionActionMagneticAttach",
            Self::SwitchCameraTemplate => "EInteractionActionSwitchCameraTemplate",
            Self::HomeFarm => "EInteractionActionHomeFarm",
            Self::Lua => "EInteractionActionLua",
            Self::Base => "EInteractionActionBase",
            Self::Pivot => "EInteractionActionPivot",
            Self::PivotBreak => "EInteractionActionPivotBreak",
            Self::TransferPoint => "EInteractionActionTransferPoint",
            Self::LogicResonance => "EInteractionActionLogicResonance",
            Self::LogicStatic => "EInteractionActionLogicStatic",
            Self::LogicDance => "EInteractionActionLogicDance",
            Self::AddBuff => "EInteractionActionAddBuff",
            Self::Teleport => "EInteractionActionTeleport",
            Self::EnterDungeon => "EInteractionActionEnterDungeon",
            Self::EnterVisualLayer => "EInteractionActionEnterVisualLayer",
            Self::ExitVisualLayer => "EInteractionActionExitVisualLayer",
            Self::TriggerSceneEvent => "EInteractionActionTriggerSceneEvent",
            Self::TriggerSceneCustomEvent => "EInteractionActionTriggerSceneCustomEvent",
            Self::UserDoAction => "EInteractionActionUserDoAction",
            Self::Pickup => "EInteractionActionPickup",
            Self::OpenEliteTreasureBox => "EInteractionActionOpenEliteTreasureBox",
            Self::OpenBossTreasureBox => "EInteractionActionOpenBossTreasureBox",
            Self::Quest => "EInteractionActionQuest",
            Self::QuestEvent => "EInteractionActionQuestEvent",
            Self::KillSelf => "EInteractionActionKillSelf",
            Self::SendAiEvent => "EInteractionActionSendAiEvent",
            Self::DanceAwardNpc => "EInteractionActionDanceAwardNPC",
            Self::RequestInteractionSeat => "EInteractionActionRequestInteractionSeat",
            Self::RemoveBuff => "EInteractionActionRemoveBuff",
            Self::AddBuffToTarget => "EInteractionActionAddBuffToTarget",
            Self::RemoveBuffToTarget => "EInteractionActionRemoveBuffToTarget",
            Self::PaintToySwitchPage => "EInteractionActionPaintToySwitchPage",
            Self::OpenTowerTreasureBox => "EInteractionActionOpenTowerTreasureBox",
            Self::RoughCollection => "EInteractionActionRoughCollection",
            Self::FineCollection => "EInteractionActionFineCollection",
            Self::BubbleActStart => "EInteractionActionBubbleActStart",
            Self::BubbleActEnd => "EInteractionActionBubbleActEnd",
            Self::RaidOpenBox => "EInteractionActionRaidOpenBox",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EInteractionActionNone" => Some(Self::None),
            "EInteractionActionToServer" => Some(Self::ToServer),
            "EInteractionActionNpcTalk" => Some(Self::NpcTalk),
            "EInteractionActionDungeonEntry" => Some(Self::DungeonEntry),
            "EInteractionActionFunctionEntry" => Some(Self::FunctionEntry),
            "EInteractionActionClientSceneEvent" => Some(Self::ClientSceneEvent),
            "EInteractionActionOptionSelect" => Some(Self::OptionSelect),
            "EInteractionActionHeroNormalDungeon" => Some(Self::HeroNormalDungeon),
            "EInteractionActionHeroChallengeDungeon" => Some(Self::HeroChallengeDungeon),
            "EInteractionActionRevive" => Some(Self::Revive),
            "EInteractionActionVMFuction" => Some(Self::VmFuction),
            "EInteractionActionTips" => Some(Self::Tips),
            "EInteractionActionOpenUI" => Some(Self::OpenUi),
            "EInteractionActionWindZone" => Some(Self::WindZone),
            "EInteractionActionWindRing" => Some(Self::WindRing),
            "EInteractionActionWindTornado" => Some(Self::WindTornado),
            "EInteractionActionDanceTogether" => Some(Self::DanceTogether),
            "EInteractionActionStartFlow" => Some(Self::StartFlow),
            "EInteractionActionShowCutScene" => Some(Self::ShowCutScene),
            "EInteractionActionUnionHuntEntry" => Some(Self::UnionHuntEntry),
            "EInteractionActionUnionBuild" => Some(Self::UnionBuild),
            "EInteractionActionUnionBuildFunc" => Some(Self::UnionBuildFunc),
            "EInteractionActionExploreMonsterDeplete" => {
                Some(Self::ExploreMonsterDeplete)
            }
            "EInteractionActionUseSkill" => Some(Self::UseSkill),
            "EInteractionActionFishing" => Some(Self::Fishing),
            "EInteractionActionSendClientAiEvent" => Some(Self::SendClientAiEvent),
            "EInteractionActionDoNoThing" => Some(Self::DoNoThing),
            "EInteractionActionCookFunc" => Some(Self::CookFunc),
            "EInteractionActionMoveToDistance" => Some(Self::MoveToDistance),
            "EInteractionActionMoveToPosition" => Some(Self::MoveToPosition),
            "EInteractionActionMoveToInteractionSeat" => {
                Some(Self::MoveToInteractionSeat)
            }
            "EInteractionActionRotateToTarget" => Some(Self::RotateToTarget),
            "EInteractionActionRotateToTargetAndWait" => {
                Some(Self::RotateToTargetAndWait)
            }
            "EInteractionActionAddClientBuff" => Some(Self::AddClientBuff),
            "EInteractionActionAddClientBuffAndWait" => Some(Self::AddClientBuffAndWait),
            "EInteractionActionAddClientBuffToTarget" => {
                Some(Self::AddClientBuffToTarget)
            }
            "EInteractionActionAddClientBuffToTargetAndWait" => {
                Some(Self::AddClientBuffToTargetAndWait)
            }
            "EInteractionActionProgressBar" => Some(Self::ProgressBar),
            "EInteractionActionCameraInvoke" => Some(Self::CameraInvoke),
            "EInteractionActionWaitUiConfirm" => Some(Self::WaitUiConfirm),
            "EInteractionActionIgnoreInput" => Some(Self::IgnoreInput),
            "EInteractionActionHideHud" => Some(Self::HideHud),
            "EInteractionActionHideUI" => Some(Self::HideUi),
            "EInteractionActionMoveToStaticObj" => Some(Self::MoveToStaticObj),
            "EInteractionActionUnionWarDance" => Some(Self::UnionWarDance),
            "EInteractionActionWaitInputMove" => Some(Self::WaitInputMove),
            "EInteractionActionRemoveClientBuff" => Some(Self::RemoveClientBuff),
            "EInteractionActionRemoveTargetClientBuff" => {
                Some(Self::RemoveTargetClientBuff)
            }
            "EInteractionActionEnterAutoFlow" => Some(Self::EnterAutoFlow),
            "EInteractionActionNpcTalkFlow" => Some(Self::NpcTalkFlow),
            "EInteractionActionStartFlowAndWait" => Some(Self::StartFlowAndWait),
            "EInteractionActionShowCutSceneAndWait" => Some(Self::ShowCutSceneAndWait),
            "EInteractionActionSittingControl" => Some(Self::SittingControl),
            "EInteractionActionMagneticAttach" => Some(Self::MagneticAttach),
            "EInteractionActionSwitchCameraTemplate" => Some(Self::SwitchCameraTemplate),
            "EInteractionActionHomeFarm" => Some(Self::HomeFarm),
            "EInteractionActionLua" => Some(Self::Lua),
            "EInteractionActionBase" => Some(Self::Base),
            "EInteractionActionPivot" => Some(Self::Pivot),
            "EInteractionActionPivotBreak" => Some(Self::PivotBreak),
            "EInteractionActionTransferPoint" => Some(Self::TransferPoint),
            "EInteractionActionLogicResonance" => Some(Self::LogicResonance),
            "EInteractionActionLogicStatic" => Some(Self::LogicStatic),
            "EInteractionActionLogicDance" => Some(Self::LogicDance),
            "EInteractionActionAddBuff" => Some(Self::AddBuff),
            "EInteractionActionTeleport" => Some(Self::Teleport),
            "EInteractionActionEnterDungeon" => Some(Self::EnterDungeon),
            "EInteractionActionEnterVisualLayer" => Some(Self::EnterVisualLayer),
            "EInteractionActionExitVisualLayer" => Some(Self::ExitVisualLayer),
            "EInteractionActionTriggerSceneEvent" => Some(Self::TriggerSceneEvent),
            "EInteractionActionTriggerSceneCustomEvent" => {
                Some(Self::TriggerSceneCustomEvent)
            }
            "EInteractionActionUserDoAction" => Some(Self::UserDoAction),
            "EInteractionActionPickup" => Some(Self::Pickup),
            "EInteractionActionOpenEliteTreasureBox" => Some(Self::OpenEliteTreasureBox),
            "EInteractionActionOpenBossTreasureBox" => Some(Self::OpenBossTreasureBox),
            "EInteractionActionQuest" => Some(Self::Quest),
            "EInteractionActionQuestEvent" => Some(Self::QuestEvent),
            "EInteractionActionKillSelf" => Some(Self::KillSelf),
            "EInteractionActionSendAiEvent" => Some(Self::SendAiEvent),
            "EInteractionActionDanceAwardNPC" => Some(Self::DanceAwardNpc),
            "EInteractionActionRequestInteractionSeat" => {
                Some(Self::RequestInteractionSeat)
            }
            "EInteractionActionRemoveBuff" => Some(Self::RemoveBuff),
            "EInteractionActionAddBuffToTarget" => Some(Self::AddBuffToTarget),
            "EInteractionActionRemoveBuffToTarget" => Some(Self::RemoveBuffToTarget),
            "EInteractionActionPaintToySwitchPage" => Some(Self::PaintToySwitchPage),
            "EInteractionActionOpenTowerTreasureBox" => Some(Self::OpenTowerTreasureBox),
            "EInteractionActionRoughCollection" => Some(Self::RoughCollection),
            "EInteractionActionFineCollection" => Some(Self::FineCollection),
            "EInteractionActionBubbleActStart" => Some(Self::BubbleActStart),
            "EInteractionActionBubbleActEnd" => Some(Self::BubbleActEnd),
            "EInteractionActionRaidOpenBox" => Some(Self::RaidOpenBox),
            _ => None,
        }
    }
}
#[derive(specta::Type)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDetachMagneticType {
    EOperate = 0,
    EFall = 1,
}
impl EDetachMagneticType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EOperate => "EOperate",
            Self::EFall => "EFall",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EOperate" => Some(Self::EOperate),
            "EFall" => Some(Self::EFall),
            _ => None,
        }
    }
}
